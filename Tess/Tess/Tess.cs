#region License
/*
 * Copyright (C) 2001-2005 Wouter van Oortmerssen.
 * 
 * This software is provided 'as-is', without any express or implied
 * warranty.  In no event will the authors be held liable for any damages
 * arising from the use of this software.
 * 
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 * 
 * 1. The origin of this software must not be misrepresented; you must not
 * claim that you wrote the original software. If you use this software
 * in a product, an acknowledgment in the product documentation would be
 * appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 * misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 * 
 * additional clause specific to Cube:
 * 
 * 4. Source versions may not be "relicensed" under a different license
 * without my explicitly written permission.
 *
 */

/* 
 * All code Copyright (C) 2006 David Y. Hudson
 */
#endregion License

using System;
using System.IO;
using Tao.Sdl;
using Tao.OpenGl;
using SdlDotNet;
using System.Runtime.InteropServices;

namespace Tess
{
	enum BlockTypes                         // block types, order matters!
	{
		SOLID = 0,                  // entirely solid cube [only specifies wtex]
		CORNER,                     // half full corner of a wall
		FHF,                        // floor heightfield using neighbour vdelta values
		CHF,                        // idem ceiling
		SPACE,                      // entirely empty cube
		SEMISOLID,                  // generated by mipmapping
		MAXTYPE
	}

	enum TextureNumbers
	{
		DEFAULT_SKY = 0,
		DEFAULT_LIQUID,
		DEFAULT_WALL,
		DEFAULT_FLOOR,
		DEFAULT_CEIL
	}

	[StructLayout(LayoutKind.Sequential, Pack=4)]
	public struct vertex 
	{ 
		float u, v, x, y, z; 
		char r, g, b, a; 
	}

	enum StaticEntity                       // static entity types
	{
		NOTUSED = 0,                // entity slot not in use in map
		LIGHT,                      // lightsource, attr1 = radius, attr2 = intensity
		PLAYERSTART,                // attr1 = angle
		I_SHELLS, I_BULLETS, I_ROCKETS, I_ROUNDS,
		I_HEALTH, I_BOOST,
		I_GREENARMOUR, I_YELLOWARMOUR,
		I_QUAD,
		TELEPORT,                   // attr1 = idx
		TELEDEST,                   // attr1 = angle, attr2 = idx
		MAPMODEL,                   // attr1 = angle, attr2 = idx
		MONSTER,                    // attr1 = angle, attr2 = monstertype
		CARROT,                     // attr1 = tag, attr2 = type
		JUMPPAD,                    // attr1 = zpush, attr2 = ypush, attr3 = xpush
		MAXENTTYPES
	}

	enum CSStatus
	{ 
		CS_ALIVE = 0, 
		CS_DEAD, 
		CS_LAGGED, 
		CS_EDITING
	}

	// hardcoded sounds, defined in sounds.cfg
	enum Sounds
	{
		S_JUMP = 0, S_LAND, S_RIFLE, S_PUNCH1, S_SG, S_CG,
		S_RLFIRE, S_RLHIT, S_WEAPLOAD, S_ITEMAMMO, S_ITEMHEALTH,
		S_ITEMARMOUR, S_ITEMPUP, S_ITEMSPAWN, S_TELEPORT, S_NOAMMO, S_PUPOUT,
		S_PAIN1, S_PAIN2, S_PAIN3, S_PAIN4, S_PAIN5, S_PAIN6,
		S_DIE1, S_DIE2,
		S_FLAUNCH, S_FEXPLODE,
		S_SPLASH1, S_SPLASH2,
		S_GRUNT1, S_GRUNT2, S_RUMBLE,
		S_PAINO,
		S_PAINR, S_DEATHR, 
		S_PAINE, S_DEATHE, 
		S_PAINS, S_DEATHS,
		S_PAINB, S_DEATHB, 
		S_PAINP, S_PIGGR2, 
		S_PAINH, S_DEATHH,
		S_PAIND, S_DEATHD,
		S_PIGR1, S_ICEBALL, S_SLIMEBALL,
		S_JUMPPAD,
	}


	[StructLayout(LayoutKind.Sequential, Pack=4)]
	public struct Vector
	{ 
		public float x;
		public float y;
		public float z; 
	}

	[StructLayout(LayoutKind.Sequential, Pack=4)]
	public struct Square
	{
		char type;                 // one of the BlockTypes
		char floor, ceil;           // height, in cubes
		char wtex, ftex, ctex;     // wall/floor/ceil texture ids
		char r, g, b;              // light value at upper left vertex
		char vdelta;               // vertex delta, used for heightfield cubes
		char defer;                 // used in mipmapping, when true this cube is not a perfect mip
		char occluded;              // true when occluded
		char utex;                 // upper wall tex id
		char tag;                  // used by triggers
	};

	[StructLayout(LayoutKind.Sequential, Pack=4)]
	public struct MapHeader                   // map file format header
	{
		[MarshalAs( UnmanagedType.ByValArray, SizeConst=4 )]
		char[] head;               // "CUBE"
		int version;                // any >8bit quantity is a little indian
		int headersize;             // sizeof(header)
		int sfactor;                // in bits
		int numents;
		[MarshalAs( UnmanagedType.ByValArray, SizeConst=128 )]
		char[] maptitle;
		//uchar texlists[3][256];
		IntPtr texlists;
		int waterlevel;
		[MarshalAs( UnmanagedType.ByValArray, SizeConst=15 )]
		int[] reserved;
	};

	[StructLayout(LayoutKind.Sequential, Pack=4)]
	public struct block 
	{ 
		int x, y, xs, ys; 
	};

	// armour types... take 20/40/60 % off
	enum ArmorTypes
	{ 
		A_BLUE, 
		A_GREEN, 
		A_YELLOW 
	}; 
    
	enum MonsterStates
	{ 
		M_NONE = 0, 
		M_SEARCH, 
		M_HOME, 
		M_ATTACKING, 
		M_PAIN, 
		M_SLEEP, 
		M_AIMING };  // monster states


	enum Weapon
	{ 
		GUN_FIST = 0, 
		GUN_SG, 
		GUN_CG, 
		GUN_RL, 
		GUN_RIFLE, 
		GUN_FIREBALL, 
		GUN_ICEBALL, 
		GUN_SLIMEBALL, 
		GUN_BITE, 
		NUMGUNS };


	[StructLayout(LayoutKind.Sequential, Pack=4)]
	public struct mapmodelinfo 
	{ 
		int rad, h, zoff, snap; 
		string name; 
	};


	[StructLayout(LayoutKind.Sequential, Pack=4)]
	public struct PersistentEntity        // map entity
	{
		short x, y, z;              // cube aligned position
		short attr1;
		char type;                 // type is one of the above
		char attr2, attr3, attr4;        
	};

	[StructLayout(LayoutKind.Sequential, Pack=4)]
	public struct Entity        // map entity
	{
		short x, y, z;              // cube aligned position
		short attr1;
		char type;                 // type is one of the above
		char attr2, attr3, attr4;
		bool spawned;               // the only dynamic state of a map entity
	};

	enum FunctionSignatures// function signatures for script functions, see command.cpp
	{
		ARG_1INT, ARG_2INT, ARG_3INT, ARG_4INT,
		ARG_NONE,
		ARG_1STR, ARG_2STR, ARG_3STR, ARG_5STR,
		ARG_DOWN, ARG_DWN1,
		ARG_1EXP, ARG_2EXP,
		ARG_1EST, ARG_2EST,
		ARG_VARI
	}

	enum NetworkMessages
	{
		SV_INITS2C, SV_INITC2S, SV_POS, SV_TEXT, SV_SOUND, SV_CDIS,
		SV_DIED, SV_DAMAGE, SV_SHOT, SV_FRAGS,
		SV_TIMEUP, SV_EDITENT, SV_MAPRELOAD, SV_ITEMACC,
		SV_MAPCHANGE, SV_ITEMSPAWN, SV_ITEMPICKUP, SV_DENIED,
		SV_PING, SV_PONG, SV_CLIENTPING, SV_GAMEMODE,
		SV_EDITH, SV_EDITT, SV_EDITS, SV_EDITD, SV_EDITE,
		SV_SENDMAP, SV_RECVMAP, SV_SERVMSG, SV_ITEMLIST,
		SV_EXT,
	}   

	/// <summary>
	/// Summary description for Tess.
	/// </summary>
	class Tess
	{
		float DMF = 16.0f ;
		float DAF = 1.0f ;
		float DVF = 100.0f;

		int VIRTW = 2400;                      // virtual screen size for text & HUD
		int VIRTH = 1800;
		int FONTH = 64;
		//int PIXELTAB = (VIRTW/12);
		//#define SWS(w,x,y,s) (&(w)[(y)*(s)+(x)])
		//#define SW(w,x,y) SWS(w,x,y,ssize)
		//#define S(x,y) SW(world,x,y)            // convenient lookup of a lowest mip cube
		int SMALLEST_FACTOR = 6;             // determines number of mips there can be
		int DEFAULT_FACTOR = 8;
		int LARGEST_FACTOR = 11;               // 10 is already insane
		//#define SOLID(x) ((x)->type==SOLID)
		int MINBORD = 2;                       // 2 cubes from the edge of the world are always solid
		//#define OUTBORD(x,y) ((x)<MINBORD || (y)<MINBORD || (x)>=ssize-MINBORD || (y)>=ssize-MINBORD)

		int mapVersion = 5; // bump if map format changes, see worldio.cpp
		int SAVEGAMEVERSION = 4;
		int MAXCLIENTS = 256;               // in a multiplayer game, can be arbitrarily changed
		int MAXTRANS = 5000;                // max amount of data to swallow in 1 go
		int CUBE_SERVER_PORT = 28765;
		int CUBE_SERVINFO_PORT = 28766;
		int PROTOCOL_VERSION = 122;            // bump when protocol changes
		static DynamicEntity player1;
		int NUMGUNS = 9;
		int ignore = 5;
		static IntPtr player1Ptr;
		float fps = 30.0f;
		int screenWidth = 640;
		int screenHeight = 480;
		int gamespeed = 100;
		int lastmillis = 0;
		bool demoplayback;
		int curtime;
		int framesinmap = 0;
		byte lasttype = 0;
		byte lastbut = 0;
		int minmillis = 5;

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			Tess tess = new Tess();
			tess.Run(args);
		}
		void Log(string input)
		{
			Console.WriteLine("init: {0}", input);
		}

		internal static void Fatal(string s, string o)
		{
			Console.WriteLine(s + o + Sdl.SDL_GetError());
			Bindings.cleanup(s + o + Sdl.SDL_GetError());
		}
		internal static void Fatal(string s)
		{
			Fatal(s, "");
		}

		void Run(string[] args)
		{
			bool dedicated = false;
			int uprate = 0;
			int maxcl = 4;
			string sdesc = "";
			string ip = "";
			string master = null; 
			string passwd = "";

			//int retval = ManagedWrapper.minitialize();

			Log("sdl");
    
			foreach(string a in args)
			{
				if(a.StartsWith("-"))
				{
					switch(a.Substring(1,1))
					{
						case "d": 
							dedicated = true; 
							break;
						case "t": 
							//fs = 0; 
							break;
						case "w": 
							screenWidth  = Convert.ToInt32(a.Substring(2, a.Length - 2)); 
							break;
						case "h": 
							screenHeight  = Convert.ToInt32(a.Substring(2, a.Length - 2)); 
							break;
						case "u": 
							uprate = Convert.ToInt32(a.Substring(2, a.Length - 2)); 
							break;
						case "n": 
							sdesc = a.Substring(2, a.Length - 2); 
							break;
						case "i": 
							ip     = a.Substring(2, a.Length - 2); 
							break;
						case "m": 
							master = a.Substring(2, a.Length - 2); 
							break;
						case "p": 
							passwd = a.Substring(2, a.Length - 2); 
							break;
						case "c": 
							maxcl  = Convert.ToInt32(a.Substring(2, a.Length - 2)); 
							break;
						default:  
							Log("unknown commandline option");
							break;
					}
				}
				else
				{ 
					Log("unknown commandline argument");
				}
			};
			
			Log("net");
			if(Bindings.enet_initialize()<0)
			{
				Fatal("Unable to initialise network module");
			}
			ClientGame.initclient();
			Bindings.initserver(dedicated, uprate, sdesc, ip, out master, passwd, maxcl);  // never returns if dedicated    
			Log("world");
			Bindings.empty_world(7, true);
			Log("video: sdl");
			Video.GLDoubleBufferEnabled = false;
			Log("video: mode");
			Video.WindowIcon();
			Video.WindowCaption = "Tess Engine";
			Video.GrabInput();
			Video.SetVideoModeWindowOpenGL(screenWidth, screenHeight);
			
			Log("video: misc");
			Keyboard.KeyRepeat = false;
			Mouse.ShowCursor = false;
			
			Log("gl");
				
			RenderGl.GlInit(screenWidth, screenHeight);

			string dataDirectory = @"game/";
			string filepath = @"../../";

			if (File.Exists(dataDirectory + "newchars.png"))
			{
				filepath = "";
			}
			
			Log("basetex");
			int xs = 0;
			int ys = 0;
			if(!Bindings.installtex(2, filepath + dataDirectory + "data/newchars.png", out xs, out ys, false) ||
				!Bindings.installtex(3, filepath + dataDirectory + "data/martin/base.png", out xs, out ys, false) ||
				!Bindings.installtex(6, filepath + dataDirectory + "data/martin/ball1.png", out xs, out ys, false) ||
				!Bindings.installtex(7, filepath + dataDirectory + "data/martin/smoke.png", out xs, out ys, false) ||
				!Bindings.installtex(8, filepath + dataDirectory + "data/martin/ball2.png", out xs, out ys, false) ||
				!Bindings.installtex(9, filepath + dataDirectory + "data/martin/ball3.png", out xs, out ys, false) ||
				!Bindings.installtex(4, filepath + dataDirectory + "data/explosion.jpg", out xs, out ys, false) ||
				!Bindings.installtex(5, filepath + dataDirectory + "data/items.png", out xs, out ys, false) ||
				!Bindings.installtex(1, filepath + dataDirectory + "data/crosshair.png", out xs, out ys, false)) 
			{
				Fatal("could not find core textures (hint: run cube from the parent of the bin directory)");
			}
			
			Log("sound");
			Mixer.Initialize();
			
			Log("cfg");
			Bindings.newmenu("frags\tpj\tping\tteam\tname");
			Bindings.newmenu("ping\tplr\tserver");
			Bindings.exec( filepath + dataDirectory + "data/keymap.cfg");
			Bindings.exec( filepath + dataDirectory + "data/menus.cfg");
			Bindings.exec( filepath + dataDirectory + "data/prefabs.cfg");
			Bindings.exec( filepath + dataDirectory + "data/sounds.cfg");
			Bindings.exec( filepath + dataDirectory + "servers.cfg");
			if(!Bindings.execfile( filepath + dataDirectory + "config.cfg")) 
			{
				Bindings.execfile( filepath + dataDirectory + "data/defaults.cfg");
			}
			Bindings.exec( filepath + dataDirectory + "autoexec.cfg");
			
			Log("localconnect");
			Bindings.localconnect();
			// if this map is changed, also change depthcorrect()   
			Bindings.changemap("metl3");		
			Log("mainloop");
			
			Events.KeyboardDown += new KeyboardEventHandler(this.KeyDown);
			Events.KeyboardUp += new KeyboardEventHandler(this.KeyUp);
			Events.Tick += new TickEventHandler(this.Tick);
			Events.Quit += new QuitEventHandler(this.Quit);
			Events.MouseMotion += new MouseMotionEventHandler(this.MouseMotion);
			Events.MouseButtonUp += new MouseButtonEventHandler(this.MouseButtonUp);
			Events.MouseButtonDown += new MouseButtonEventHandler(this.MouseButtonDown);
			Events.Run();
		}
		private void Tick(object sender, TickEventArgs e)
		{
			int millis = Timer.TicksElapsed*gamespeed/100;
			if(millis-lastmillis>200) 
			{
				lastmillis = millis-200;
			}
			else if(millis-lastmillis<1) 
			{
				lastmillis = millis-1;
			}
			if(millis-lastmillis<minmillis) 
			{
				Timer.DelayTicks(minmillis-(millis-lastmillis));
			}
			Bindings.cleardlights();
			Bindings.updateworld(millis);
			if(!demoplayback)
			{
				Bindings.serverslice(DateTime.Now.Second, 0);
			}

			fps = 30.0f;
			//fps = (1000.0f/curtime+fps*50)/51;
			player1Ptr = Bindings.getplayer1();
			
			//player1 = (DynamicEntity)Marshal.PtrToStructure(player1Ptr, typeof(DynamicEntity));
			Bindings.computeraytable(Player1.o.x, Player1.o.y);
			Bindings.readdepth(screenWidth, screenHeight);
					
			Video.GLSwapBuffers();
			Bindings.updatevol();
				
			if(framesinmap++<5)	// cheap hack to get rid of initial sparklies, even when triple buffering etc.
			{
				player1.yaw += 5;
				Player1 = player1;
				Bindings.gl_drawframe(screenWidth, screenHeight, fps);
				player1.yaw -= 5;
				Player1 = player1;
			};
			Bindings.gl_drawframe(screenWidth, screenHeight, fps);
		}

		private void Quit(object sender, QuitEventArgs e)
		{
			Bindings.writeservercfg();
			Bindings.cleanup(null);
		}

		private void KeyDown(object sender, KeyboardEventArgs e)
		{
			Bindings.keypress((int)e.Key, e.Down == true, e.Unicode);	
		}

		private void KeyUp(object sender, KeyboardEventArgs e)
		{
			Bindings.keypress((int)e.Key, e.Down == true, e.Unicode);
		}

		private void MouseMotion(object sender, MouseMotionEventArgs e)
		{
			if(ignore > 0)
			{ 
				ignore--; 
			}
			else
			{
				Bindings.mousemove(e.RelativeX, e.RelativeY);
			}
		}

		private void MouseButtonUp(object sender, MouseButtonEventArgs e)
		{
			if(lasttype==(byte)e.Type && lastbut == (byte)e.Button)
			{
			}
			else
			{
				Bindings.keypress(-1*(byte)e.Button, e.ButtonPressed != false, 0);
				lasttype = (byte)e.Type;
				lastbut = (byte)e.Button;
			}
		}

		private void MouseButtonDown(object sender, MouseButtonEventArgs e)
		{
			if(lasttype==(byte)e.Type && lastbut == (byte)e.Button)
			{
			}
			else
			{
				Bindings.keypress(-1*(byte)e.Button, e.ButtonPressed != false, 0);
				lasttype = (byte)e.Type;
				lastbut = (byte)e.Button;
			}
		}
		internal static DynamicEntity Player1
		{
			get
			{
				return player1 = (DynamicEntity)Marshal.PtrToStructure(player1Ptr, typeof(DynamicEntity));
			}
			set
			{
				Marshal.StructureToPtr(value, player1Ptr, false);
			}
		}
	}
}
