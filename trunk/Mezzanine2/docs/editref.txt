Mezzanine Mapping Command ReferenceEditing Related Console Commands
edittoggleSwitches between map edit mode and normal (default key = e). In map edit mode 
you can select bits of the map by clicking or dragging your crosshair on the 
cubes (using the "attack" command, normally MOUSE1), then use the commands below 
to modify the selection. While in edit mode, physics & collision don't apply 
(noclip), and key repeat is ON. 
editface D NThis is the main editing command. D is the direction of the action, -1 for 
towards you, 1 for away from you. N=0 to push all corners in the white box. N=1 
create or destroy cubes. N=2 push or pull a corner you are pointing at. 
editheight D (OBSOLETE)Similar to editface N=2, but pushes all four corners surronding the pointed-at 
vertex. 
heighttoggleToggles height map mode on and off. In this mode, the editface commands are 
replaced with an editheight style command. As a bonus to editheight, you can 
also pull up a vertex from a flat side of a cube. Unlike Cube, the edited cubes 
are not treated special, so you can later tweak the terrain like you would any 
other cube. 

While in height map mode, the cursor will turn green and its orientation will be 
locked until the mode is switched off again. Like every other command, terrain 
editing can be done using any orientation. 
edittex DChanges the texture on current selection by browsing through a list of textures 
directly shown on the cubes. D is the direction you want to cycle the textures 
in (1 = forwards, -1 = backwards). By default bound to holding F and using the 
mouse wheel. 

The way this works is slightly strange at first, but allows for very fast 
texture assignment. All textures are in a list. and each time a texture is used, 
it is moved to the top of the list. So after a bit of editing, all your most 
frequently used textures will come first, and the most recently used texture is 
set immediately when you press the forward key for the type. These lists are 
saved with the map. 
gridpower NChanges the size of the grid. 
reorientChange the side the white box is on to be the same as where you are currently 
pointing. 
flipFlip (mirror) the selected cubes front to back relative to the side of the white 
box. 
rotate DRotates the selection 90 degrees around the side of the white box. Automatically 
squares the selection if it isn't already. 
undoMulti-level undo of any of the changes caused by the above operations (default 
key = z). 
undomegs NSets the number of megabytes used for the undo buffer (default 1, max 10). 
Undo's work for any size areas, so the amount of undo steps per megabyte is more 
for small areas than for big ones. 
copy
pasteCopy copies the current selection into a buffer. For pasting, if the current 
selection is not the same size as the copy, the corner of the red reference box 
will be used as the origin. If the current gridsize is changed from the copy, 
the pasted copy will be stretched by the same factor. 
replaceRepeats the last texture edit across a selection. Only those faces with textures 
and orientations matching the one that was last edited will be replaced. 
newent type    value1 value2 value3 value4Adds a new entity where (x,y) is determined by the current selection (the red 
dot corner) and z by the camera height, of said type. Type is a string giving 
the type of entity, such as "light", and may optionally take values (depending 
on the entity). The types are defines below in the Entity Types section. 
delentdeletes the entity closest to the player 
dropentPositions the closest entity according to the entdrop variable. 
entdrop Nvariable controlling where entities created with "newent" will be placed.
N=0 place entities at your current eye position.
N=1 drop entities to the floor beneath you. Lights, however, will be placed at 
your current eye position as for N=0.
N=2 place entities at the center of the currently selected cube face. If a 
corner is selected, the entity will be placed at the corner vertex.
N=3 behaves as with N=2, except all entities, including lights, will then 
bedropped from that position to whatever floor lies beneath. This mode is useful 
for placing objects on selected floors. Lights are also dropped to the floor, 
unlike for N=1. 
entproperty P AChanges property P (0..3) of the closest entity by amount A. For example 
"entproperty 0 2" when executed near a lightsource would increase its radius by 
2. 
clearents typeDeletes all entities of said type. 
editmatChanges the type of material left behind when a cube is deleted. Currently the 
following types of materials are supported: 
  air: the default material, has no effect. 
  water: acts as you would expect. Only renders from the top, so treat it like 
  real water and keep all 4 sides contained. Shows blue volume in edit mode. 
  clip: an invisible wall that blocks players movement but not bullets. Is 
  ideally used to keep players "in bounds" in a map. Can be used sparingly to 
  smooth out the flow around decoration. Shows red volume in edit mode. 
  noclip: cubes are always treated as empty in physics. Shows green volume in 
  edit mode. 
  glass: a clip-like material with a blended surface. Glass also stops bullets. 
  Shows cyan volume in edit mode. 
showmat BThis variables whether volumes are shown for invisible material surfaces in edit 
mode. Material volumes may also be selected while this is enabled. Default = 1. 
optmats BThis variables controls whether material rendering should be optimized by 
grouping materials into the largest possible surfaces. This will always make 
rendering faster, so the only reason to disable it is for testing. Default = 1. 
watercolour R G BChanges the blended color of all water to RGB. This may be used to simulate 
various lighting conditions for water. 
selextendExtend current selection to include the cursor. 
map nameLoads up map "name" in the gamemode set previously by "mode". A map given as 
"blah" refers to "packages/base/blah.cgz", "mypackage/blah" refers to 
"packages/mypackage/blah.cgz". The menu has a set of maps that can be loaded. 
See also map in the gameplay docs. 

At every map load, "data/default_map_settings.cfg" is loaded which sets up all 
texture definitions etc. Everything defined in there can be overridden per 
package or per map by creating a "package.cfg" or "mapname.cfg" which contains 
whatever you want to do differently from the default. It can also set up 
triggers scripts per map etc. 

When the map finishes it will load the next map when one is defined, otherwise 
reloads the current map. You can define what map follows a particular map by 
making an alias like (in the map script): alias nextmap_blah1 blah2 (loads 
"blah2" after "blah1"). 
savemap nameSaves the current map, using the same naming scheme as "map". makes a versioned 
backup (mapname_N.BAK) if a map by that name already exists, so you can never 
lose a map. If you leave out the "name" argument, it is saved under the current 
map name. 

Where you store a map depends on the complexity of what you are creating: if its 
a single map (maybe with its own .cfg) then the "base" package is the best 
place. If its multiple maps or a map with new media (textures etc.) its better 
to store it in its own package (a directory under "packages"), which makes 
distributing it less messy. 
newmap sizeCreates a new map of size^2 cubes (on the smallest grid size). 10 is a small 
map, 13 is a large map but it goes up to 16. Use newmap -1 to double the 
dimensions of the current map. 
mapmsg "Title by Author"sets the map msg, which will be displayed when the map loads. Either use the 
above format, or simply "by Author" if the map has no particular title (always 
displayed after the map load msg). 
recalcRecalculates scene geometry. Shouldn't be needed under normal curcumstances. 
textureresetSets the texture slot to 0 for the subsequent "texture" commands. 
texture subnum filename flagsBinds the texture indicated in filename to the current texture slot, then 
increments the slot number. This is for use in texture.cfg files only. subnum 
allows secondary textures to be specified for a single texture slot, for use in 
shaders and other features (unused for now, should be set to 0 to indicate 
primary texture). Flags allow you to specify preprocessing on the image, 
currently only rotation (0 = none, 1 = 90 CW, 2 = 180, 3 = 270 CW). 
shader NAME VS PSdefines a shader NAME with vertex shader VS and pixel shader PS (both in ARB 
OpenGL 1.5 assembly format). See data/stdshader.cfg for examples. These 
definitions can be put in map cfg files or anywhere else, and will only be 
compiled once. Requires DX9 / shader 2 class hardware (radeon 9500 or better, 
geforce 5200 or better) to run (older hardware will default to basic rendering). 

setshader NAMESets a previously defined shader as the current shader. Any following texture 
slots (see "texture" command) will have this shader attached to it. 
trigger N TTriggers trigger N of type T, as if the player had picked up the equivalent 
"trigger" entity (see below). 
music name
music name ondonePlays song "name" (with "packages" as base dir). This command is best used from 
map cfg files or triggers. Evaluates ondone when the song is finished, or just 
keeps looping the song if ondone is missing. Example: 
music "songs/music.ogg" [ echo "Song dong playing!" ] 
N = registersound name VRegisters sound "name" with cube (see for example data/sounds.cfg). This command 
returns the sound number N, which is assigned from 0 onwards, and which can be 
used with "sound" command below. if the sound was already registered, its 
existing index is returned. registersound does not actually load the sound, this 
is done on first play. V is volume adjustment, if not specified (0), it is the 
default 100, valid range is 1-255.
sound NPlays sound N, see data/sounds.cfg for default sounds, and use registersound to 
register your own. for example, sound 0 and sound (registersound 
"aard/jump")both play the standard jump sound. 
mapmodel R H Z N SHregisters a mapmodel that can be placed in maps using newent mapmodel (see 
newent). N is the name, R is the square radius, H the height, Z the initial 
Z-offset above ground, and SH toggles whether the it will cast shadows (not 
given or 1 casts shadows, 0 has no shadows). The radius R and height H define 
the collision bounding box of the model (if either is 0, players won't collide 
with the mapmodel). Name N is the name of a folder inside packages/models 
folder, e.g. "hudguns/rifle". Loaded from that folder are: tris.md2 and skin.jpg 
(and if not available, skin.png, or the same from the parent folder to allow 
skin sharing). 

Example: mapmodel 4 32 0 "tree1" 
This map model is loaded from packages/models/tree1/. It has a collision box 
8x8x32 in size (x=2*R, y=2*R, z=H). It is flat on the ground (Z-offset = 0). It 
casts shadows (default).
importcube Nimports a cube map (.cgz) and converts it to Mezzanine's map format. N is the 
name of the map, without the .cgz. The map file must reside in packages/cube, 
which is because that folder has a package.cfg that sets the default cube 
textures. If the cube map in question has a custom texture list, it will have to 
be adapted manually. Currently converts everything relatively faithfully, except 
heighfields which are converted as best as possible but not always accurately. 
Slopes tend to work faultlessly, landscape style stuff is usuable, but 
curves/arches are problematic, and may have to be redone. All entities are 
converted though mapmodels may not be present, and light entities are useless 
because of their 2d nature, so probably the first thing to do after converting a 
map is /clearents light, and place some new lights. Pickups and other items may 
spawn inside the walls because they have no proper Z value, you may have to 
correct these manually. The importcube command does not automatically save the 
map, you still have to do a /savecurrentmap which will create 
packages/cube/N.ogz. Reload the map to be able to pick up stuff. Waterlevel is 
also not supported, you will have to add water using the new material system.
wireframe 0/1Turns on wireframe drawing of the map.
gettexmoves the texture on the current selection to the top of the texture list. 
Useful for quickly texturing things using already textured geometry
allfaces 0/1when on, causes the texturing commands to apply the new texture to all sides of 
the selected cubes rather than just the selected face.
passthroughnormally cubes of equal size to the grid are given priority when selecting. 
passthrough removes this priority while held down so that the cube the cursor is 
directly on is selected.
Lighting Commands
calclight QThis calculates all lightmaps. Usually takes only a few seconds, depending on 
map size and settings. If you "savemap", the lightmap will be stored along with 
it. Q is these predefined quality settinsg: 
  2: 8x anti aliasing, shadows for mapmodels also (maximum quality, very slow) 
  1: 8x anti aliasing, world shadows only (better lighting quality for huge 
  maps, slow) 
  0: 4x anti aliasing, world shadows only (default, good enough for most maps) 
  -1: no anti aliasing, but still shadowed (good for shadow previews) 
  -2: no anti aliasing and no shadows (VERY fast, good for lighting previews) 
patchlightThis will calculate lightmaps for any newly created cubes. This will generally 
be much quicker than doing a "calclight", and so is very useful when editing. 
However, it will make very inefficient use of lightmap textures, and any new 
cubes will not properly cast shadows on surfaces that are already lit. It is 
recommended you do a "calclight" on your map before you publish it with 
"savemap". 
fullbright BThis variable controls whether the map will be shown with lighting disabled. 
Fullbright 1 will disable lighting, whereas 0 will enable lighting. (Default = 
0) 
lerpangle ADefault = 44. This variable controls whether surface normals are interpolated 
for lighting. Normals are sampled at each vertex of the surface. If the angle 
between two surfaces' normals (which meet at a vertex) is less than A, then the 
resulting normal will be the average of the two. Normals are then later 
interpolated between the normals at the vertexes of a surface. 
lerpsubdiv NDefault = 2. This allows more normals to be sampled at points along an edge 
between two vertexes of a surface. 2^N-1 extra normals will be sampled along the 
edge, i.e. the edge is split in half for every increment of N. 
lerpsubdivsize NDefault = 4. This sets the minimum size to which an edge may be subdivided. 
Edges smaller than N or edge sections smaller than N will not be sampled. 
lightprecision PDefault = 32. This is the most important variable for tweaking the lighting, it 
determines what the resolution of the lightmap is. As such has a BIG effect on 
calculation time, video memory usage, and map file size. The default is good for 
most maps, you may go as low as 16 if you are lighting a really small map and 
love hard shadows, and for bigger maps you may need to set it to 64 or so to get 
reasonable memory usage. 

The number to watch out for is the number of lightmaps generated which are shown 
on the HUD (and also as output after a calclight). 1 or 2 lightmap textures is 
very good, over 10 lightmap textures is excessive. 

The map file size is for 90% determined by the lightmaps, so tweak this value to 
get an acceptable quality to size ratio. Look at the size of the map files, 
sometimes a slightly higher lightprecision can halve the size of your .ogz. 

Every surface matters, even though Mezzanine attempts to compress surfaces with 
a uniform lightvalue, it is always a good ideas to delete parts of the world 
that are not part of your map. Lightprecision, lighterror, and lightlod are 
stored as part of map files. 
lighterror EThere should be little reason to tweak this. If in your map you can see visible 
polygon boundaries caused by lighting, you can try stepping this down to 6 or 4 
to improve quality at the expense of lightmap space. If you have an insanely 
large map and looking for ways to reduce file size, increasing error up to 16 
may help. (Default = 8) 
lightlod DDefault = 0. This will double the resolution of lightmaps (cut the 
lightprecision in half) if size of the surface being lit is smaller than 2^D 
units. This allows large maps to have pockets of detailed lighting without using 
a high resolution over everything. 

NOTE: if you feel like using this, test it thoroughly. On medium or small sized 
detailed maps, this command wastes space, use lightlod 0. Lightlod > 0 is only 
useful for huge maps 
dumplmsDumps all lightmaps to a set of .bmps. Mostly interesting for developers, but 
mappers may find it interesting too. 
lodsize NTurn on world LOD (level of detail) for this map if N=32 (default is N=0, off). 
The state of this command is saved with the map. N is the size of the blocks 
that will be used for LOD, in theory you can use 16 or 64 as well, but this 
usually just either just hurts performance, memory usage or visual quality. Use 
32 unless you know exactly what you are doing. After setting this var, LOD will 
only become apparent after a "recalc" (and "calclight") command. Turning LOD on 
for a map is only useful on really large maps with lots of detail where you can 
see for half a mile, on smaller maps it will have no effect and only wastes 
memory / lightmap space. LOD works on entire vertex array blocks at a time, and 
is dependent on the "loddistance" variable which the player can set to trade off 
speed vs visual quality. 
writeobj NWrites out the current map as N.obj, so you could use Mezzanine as a generic 
modeller with any program/engine that uses meshes. The meshes aren't very 
optimal and don't have texture/lighting information. 
Entity Types
"light" radius brightness
"light" radius r g bIf G and B are 0 the R value will be taken as brightness for a white light. A 
good radius for a small wall light is 64, for a middle sized room 128... for a 
sun probably more like 1000. Lights with a radius of 0 do not attenuate and may 
be more appropriate for simulating sunlight or ambient light; however, this 
comes at the cost of slightly greater map file sizes. See the lighting commands 
for an indepth list of all lighting related commands. 
"playerstart"Spawn spot, yaw is taken from the current camera yaw. 
"shells"
"bullets"
"rockets"
"riflerounds"
"grenades"
"cartridges"
"health"
"healthboost"
"greenarmour"
"yellowarmour"
"quaddamage"A variety of pickup-able items, see here. 
"teleport" N
"teledest" Ncreates a teleport connection, teleports are linked to a teledest with the same 
N (of which there should be exactly one). N can be 0..255. The teledest uses the 
current camera yaw. 
"mapmodel" NA map model, i.e. an object rendered as md2 which you collide against but has no 
behaviour/movement. N determines which mapmodel you want, currently there is 
only one, a tree (N = 0). yaw of the model is taken from the current camera yaw. 



"monster" NA monster, currently N = 0..4 (see gameplay docs). Monster entities will be 
spawned when in classic single player mode, and will attack you when you come 
into view. yaw is taken from the current camera yaw. 


"trigger" N TA trigger of type T affecting all cubes with tag N when triggered in game (see 
"edittag" on how to set tags on cubes). Triggers are rendered as a carrot which, 
when "eaten", trigger an event (only once). The following trigger types are 
available: 

0: doesn't do anything currently 

1: invisible: same as 0 but without the carrot. Since the trigger radius is 
fairly small, be sure to place them in tiny hallways and other areas you are 
sure the player will pass through. 

2: end of map marker. Ends the map and triggers the intermission. carrot spins 
wildly. 

Scripting: each trigger automatically executes the alias "level_trigger_N" where 
N is the trigger number. This means you can add any scripting you can do through 
the available commands, by simply putting aliases of this kind in the level .cfg 
file. For example, to print a message when the user hits trigger 1: 

alias level_trigger_1 "echo A door opened nearby" 

Entities are shown in editmode by blue sparklies, and the closest one is 
indicated on the HUD. 
The HUD
On the bottom right of the screen are a bunch of stats. You'll find out what 
they mean below. 
  cube: the number of cubes in the current selection. Only the visible (leaf) 
  cubes are counted. 
  fps: frames per second 
  ond: number of cubes in the system. This includes parent cubes, copied cubes, 
  and undos. 
  va: number of vertex arrays used to store vertecies in the map. you probably 
  don't need to use this. 
  vtr: number of triangles currently being displayed. will be a useful stat when 
  culling is done. 
  vvt: number of vertecies currently being displayed. again, useful when culling 
  is done. 
  tri: number of triangles in the entire map 
  wvt: number of vertecies in the entire map 
  evt: misc rendering effects. stuff like particles displayed, or text written 
  on screen.
