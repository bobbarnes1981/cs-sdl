using System;
using System.IO;
using Tao.Sdl;
using Tao.OpenGl;
using SdlDotNet;
using System.Runtime.InteropServices;


namespace TessLib
{
	enum BlockTypes                         // block types, order matters!
	{
		SOLID = 0,                  // entirely solid cube [only specifies wtex]
		CORNER,                     // half full corner of a wall
		FHF,                        // floor heightfield using neighbour vdelta values
		CHF,                        // idem ceiling
		SPACE,                      // entirely empty cube
		SEMISOLID,                  // generated by mipmapping
		MAXTYPE
	}

	enum TextureNumbers
	{
		DEFAULT_SKY = 0,
		DEFAULT_LIQUID,
		DEFAULT_WALL,
		DEFAULT_FLOOR,
		DEFAULT_CEIL
	}

	[StructLayout(LayoutKind.Sequential, Pack=4)]
	public struct vertex 
	{ 
		float u, v, x, y, z; 
		char r, g, b, a; 
	}

	enum StaticEntity                       // static entity types
	{
		NOTUSED = 0,                // entity slot not in use in map
		LIGHT,                      // lightsource, attr1 = radius, attr2 = intensity
		PLAYERSTART,                // attr1 = angle
		I_SHELLS, I_BULLETS, I_ROCKETS, I_ROUNDS,
		I_HEALTH, I_BOOST,
		I_GREENARMOUR, I_YELLOWARMOUR,
		I_QUAD,
		TELEPORT,                   // attr1 = idx
		TELEDEST,                   // attr1 = angle, attr2 = idx
		MAPMODEL,                   // attr1 = angle, attr2 = idx
		MONSTER,                    // attr1 = angle, attr2 = monstertype
		CARROT,                     // attr1 = tag, attr2 = type
		JUMPPAD,                    // attr1 = zpush, attr2 = ypush, attr3 = xpush
		MAXENTTYPES
	}

	enum CSStatus
	{ 
		CS_ALIVE = 0, 
		CS_DEAD, 
		CS_LAGGED, 
		CS_EDITING
	}

	// hardcoded sounds, defined in sounds.cfg
	enum Sounds
	{
		S_JUMP = 0, S_LAND, S_RIFLE, S_PUNCH1, S_SG, S_CG,
		S_RLFIRE, S_RLHIT, S_WEAPLOAD, S_ITEMAMMO, S_ITEMHEALTH,
		S_ITEMARMOUR, S_ITEMPUP, S_ITEMSPAWN, S_TELEPORT, S_NOAMMO, S_PUPOUT,
		S_PAIN1, S_PAIN2, S_PAIN3, S_PAIN4, S_PAIN5, S_PAIN6,
		S_DIE1, S_DIE2,
		S_FLAUNCH, S_FEXPLODE,
		S_SPLASH1, S_SPLASH2,
		S_GRUNT1, S_GRUNT2, S_RUMBLE,
		S_PAINO,
		S_PAINR, S_DEATHR, 
		S_PAINE, S_DEATHE, 
		S_PAINS, S_DEATHS,
		S_PAINB, S_DEATHB, 
		S_PAINP, S_PIGGR2, 
		S_PAINH, S_DEATHH,
		S_PAIND, S_DEATHD,
		S_PIGR1, S_ICEBALL, S_SLIMEBALL,
		S_JUMPPAD,
	}


	[StructLayout(LayoutKind.Sequential, Pack=4)]
	public struct Vector
	{ 
		public float x;
		public float y;
		public float z; 
	}

	[StructLayout(LayoutKind.Sequential, Pack=4)]
	public struct Square
	{
		char type;                 // one of the BlockTypes
		char floor, ceil;           // height, in cubes
		char wtex, ftex, ctex;     // wall/floor/ceil texture ids
		char r, g, b;              // light value at upper left vertex
		char vdelta;               // vertex delta, used for heightfield cubes
		char defer;                 // used in mipmapping, when true this cube is not a perfect mip
		char occluded;              // true when occluded
		char utex;                 // upper wall tex id
		char tag;                  // used by triggers
	};

	[StructLayout(LayoutKind.Sequential, Pack=4)]
	public struct MapHeader                   // map file format header
	{
		[MarshalAs( UnmanagedType.ByValArray, SizeConst=4 )]
		char[] head;               // "CUBE"
		int version;                // any >8bit quantity is a little indian
		int headersize;             // sizeof(header)
		int sfactor;                // in bits
		int numents;
		[MarshalAs( UnmanagedType.ByValArray, SizeConst=128 )]
		char[] maptitle;
		//uchar texlists[3][256];
		IntPtr texlists;
		int waterlevel;
		[MarshalAs( UnmanagedType.ByValArray, SizeConst=15 )]
		int[] reserved;
	};

	[StructLayout(LayoutKind.Sequential, Pack=4)]
	public struct block 
	{ 
		int x, y, xs, ys; 
	};

	// armour types... take 20/40/60 % off
	enum ArmorTypes
	{ 
		A_BLUE, 
		A_GREEN, 
		A_YELLOW 
	}; 
    
	enum MonsterStates
	{ 
		M_NONE = 0, 
		M_SEARCH, 
		M_HOME, 
		M_ATTACKING, 
		M_PAIN, 
		M_SLEEP, 
		M_AIMING };  // monster states


	enum Weapon
	{ 
		GUN_FIST = 0, 
		GUN_SG, 
		GUN_CG, 
		GUN_RL, 
		GUN_RIFLE, 
		GUN_FIREBALL, 
		GUN_ICEBALL, 
		GUN_SLIMEBALL, 
		GUN_BITE, 
		NUMGUNS };


	[StructLayout(LayoutKind.Sequential, Pack=4)]
	public struct mapmodelinfo 
	{ 
		int rad, h, zoff, snap; 
		string name; 
	};


	[StructLayout(LayoutKind.Sequential, Pack=4)]
	public struct PersistentEntity        // map entity
	{
		short x, y, z;              // cube aligned position
		short attr1;
		char type;                 // type is one of the above
		char attr2, attr3, attr4;        
	};

	[StructLayout(LayoutKind.Sequential, Pack=4)]
	public struct Entity        // map entity
	{
		short x, y, z;              // cube aligned position
		short attr1;
		char type;                 // type is one of the above
		char attr2, attr3, attr4;
		bool spawned;               // the only dynamic state of a map entity
	};

	enum FunctionSignatures// function signatures for script functions, see command.cpp
	{
		ARG_1INT, ARG_2INT, ARG_3INT, ARG_4INT,
		ARG_NONE,
		ARG_1STR, ARG_2STR, ARG_3STR, ARG_5STR,
		ARG_DOWN, ARG_DWN1,
		ARG_1EXP, ARG_2EXP,
		ARG_1EST, ARG_2EST,
		ARG_VARI
	}

	enum NetworkMessages
	{
		SV_INITS2C, SV_INITC2S, SV_POS, SV_TEXT, SV_SOUND, SV_CDIS,
		SV_DIED, SV_DAMAGE, SV_SHOT, SV_FRAGS,
		SV_TIMEUP, SV_EDITENT, SV_MAPRELOAD, SV_ITEMACC,
		SV_MAPCHANGE, SV_ITEMSPAWN, SV_ITEMPICKUP, SV_DENIED,
		SV_PING, SV_PONG, SV_CLIENTPING, SV_GAMEMODE,
		SV_EDITH, SV_EDITT, SV_EDITS, SV_EDITD, SV_EDITE,
		SV_SENDMAP, SV_RECVMAP, SV_SERVMSG, SV_ITEMLIST,
		SV_EXT,
	}   
	/// <summary>
	/// Summary description for Main.
	/// </summary>
	public class Main
	{
		
		static IntPtr player1Ptr;
		static DynamicEntity player1;

		public Main()
		{
			//
			// TODO: Add constructor logic here
			//
		}
		public static void Log(string input)
		{
			Console.WriteLine("init: {0}", input);
		}

		public static void Fatal(string s, string o)
		{
			Console.WriteLine(s + o + Sdl.SDL_GetError());
			Bindings.cleanup(s + o + Sdl.SDL_GetError());
		}
		public static void Fatal(string s)
		{
			Fatal(s, "");
		}
		public static DynamicEntity Player1
		{
			get
			{
				return player1 = (DynamicEntity)Marshal.PtrToStructure(player1Ptr, typeof(DynamicEntity));
			}
			set
			{
				Marshal.StructureToPtr(value, player1Ptr, false);
			}
		}
		public static IntPtr Player1Ptr
		{
			get
			{
				return player1Ptr;
			}
			set
			{
				player1Ptr = value;
			}
		}
	}
}
