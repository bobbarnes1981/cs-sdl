<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Tao: src/Tao.Sdl/Sdl.cs File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Packages</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>src/Tao.Sdl/Sdl.cs File Reference</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Tao.Sdl.Sdl</b></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple DirectMedia Layer binding for .NET, implementing SDL 1.2.13. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___audio_spec.html">Tao.Sdl.Sdl.SDL_AudioSpec</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Audio Specification Structure.  <a href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___audio_spec.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___audio_c_v_t.html">Tao.Sdl.Sdl.SDL_AudioCVT</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Audio Conversion Structure.  <a href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___audio_c_v_t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___c_dtrack.html">Tao.Sdl.Sdl.SDL_CDtrack</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CD Track Information Structure.  <a href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___c_dtrack.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___c_d.html">Tao.Sdl.Sdl.SDL_CD</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CDROM Drive Information.  <a href="class_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___c_d.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___c_d_track_data.html">Tao.Sdl.Sdl.SDL_CDTrackData</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___active_event.html">Tao.Sdl.Sdl.SDL_ActiveEvent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application visibility event structure.  <a href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___active_event.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___keyboard_event.html">Tao.Sdl.Sdl.SDL_KeyboardEvent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Keyboard event structure.  <a href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___keyboard_event.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___mouse_motion_event.html">Tao.Sdl.Sdl.SDL_MouseMotionEvent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mouse motion event structure.  <a href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___mouse_motion_event.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___mouse_button_event.html">Tao.Sdl.Sdl.SDL_MouseButtonEvent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mouse button event structure.  <a href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___mouse_button_event.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___joy_axis_event.html">Tao.Sdl.Sdl.SDL_JoyAxisEvent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Joystick axis motion event structure.  <a href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___joy_axis_event.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___joy_ball_event.html">Tao.Sdl.Sdl.SDL_JoyBallEvent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Joystick trackball motion event structure.  <a href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___joy_ball_event.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___joy_hat_event.html">Tao.Sdl.Sdl.SDL_JoyHatEvent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Joystick hat position change event structure.  <a href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___joy_hat_event.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___joy_button_event.html">Tao.Sdl.Sdl.SDL_JoyButtonEvent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Joystick button event structure.  <a href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___joy_button_event.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___resize_event.html">Tao.Sdl.Sdl.SDL_ResizeEvent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Window resized event.  <a href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___resize_event.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___expose_event.html">Tao.Sdl.Sdl.SDL_ExposeEvent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Screen redraw event.  <a href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___expose_event.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___quit_event.html">Tao.Sdl.Sdl.SDL_QuitEvent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Quit requested event.  <a href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___quit_event.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___user_event.html">Tao.Sdl.Sdl.SDL_UserEvent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A user-defined event type.  <a href="struct_tao_1_1_sdl_1_1_sdl_1_1_s_d_l___user_event.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tao_1_1_sdl_1_1_s_d_l___sys_w_m_event.html">Tao.Sdl.SDL_SysWMEvent</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tao_1_1_sdl_1_1_s_d_l___event.html">Tao.Sdl.SDL_Event</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">General event structure.  <a href="struct_tao_1_1_sdl_1_1_s_d_l___event.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tao_1_1_sdl_1_1_s_d_l__keysym.html">Tao.Sdl.SDL_keysym</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="struct_tao_1_1_sdl_1_1_s_d_l__keysym.html" title="The SDL_keysym structure describes a key press or a key release.">SDL_keysym</a> structure describes a key press or a key release.  <a href="struct_tao_1_1_sdl_1_1_s_d_l__keysym.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_d_l___cursor.html">SDL_Cursor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_d_l___sys_w_mmsg___unix.html">SDL_SysWMmsg_Unix</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The UNIX custom event structure. TODO.  <a href="struct_s_d_l___sys_w_mmsg___unix.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_d_l___sys_w_minfo___unix.html">SDL_SysWMinfo_Unix</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The UNIX custom window manager information structure. TODO.  <a href="struct_s_d_l___sys_w_minfo___unix.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_d_l___sys_w_mmsg___windows.html">SDL_SysWMmsg_Windows</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The Windows custom event structure. TODO.  <a href="struct_s_d_l___sys_w_mmsg___windows.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_d_l___sys_w_minfo___windows.html">SDL_SysWMinfo_Windows</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The Windows custom window manager information structure. TODO.  <a href="struct_s_d_l___sys_w_minfo___windows.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_d_l___sys_w_mmsg___risc_o_s.html">SDL_SysWMmsg_RiscOS</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RISC OS custom event structure.  <a href="struct_s_d_l___sys_w_mmsg___risc_o_s.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_d_l___sys_w_minfo___risc_o_s.html">SDL_SysWMinfo_RiscOS</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The RISCOS custom window manager information structure.  <a href="struct_s_d_l___sys_w_minfo___risc_o_s.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_d_l___sys_w_mmsg.html">SDL_SysWMmsg</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The generic custom event structure.  <a href="struct_s_d_l___sys_w_mmsg.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_d_l___sys_w_minfo.html">SDL_SysWMinfo</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The generic custom window manager information structure.  <a href="struct_s_d_l___sys_w_minfo.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_d_l___timer_i_d.html">SDL_TimerID</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_d_l__version.html">SDL_version</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure to hold version number of the SDL library.  <a href="struct_s_d_l__version.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_d_l___rect.html">SDL_Rect</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines a rectangular area.  <a href="struct_s_d_l___rect.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_d_l___color.html">SDL_Color</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Format independent color description.  <a href="struct_s_d_l___color.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_d_l___palette.html">SDL_Palette</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Color palette for 8-bit pixel formats.  <a href="struct_s_d_l___palette.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_d_l___surface.html">SDL_Surface</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Graphical Surface Structure.  <a href="struct_s_d_l___surface.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_d_l___video_info.html">SDL_VideoInfo</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Video Target information. Useful for determining the video hardware capabilities. Not finished. The C struct uses a set of bit-fields that need to be marshalled. The vfmt IntPtr works and provided useful information.  <a href="struct_s_d_l___video_info.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_d_l___overlay.html">SDL_Overlay</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The YUV hardware video overlay.  <a href="struct_s_d_l___overlay.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="namespaces"></a>
Packages</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">package &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tao_1_1_sdl.html">Tao.Sdl</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ad1c3562c62aaf55f95641f0bafab9e8f">SDL_LockSurface</a> (<a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock a surface for directly access.  <a href="#ad1c3562c62aaf55f95641f0bafab9e8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a575d113e5463394a260668c1eb9a7390">SDL_UnlockSurface</a> (<a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#acf16cb12f21e38e5544fbe0f6a0869d6">printf</a> (&quot;Pixel Color - R: %d,  G: %d,  B: %d,  A: %d\n&quot;, red, <a class="el" href="_sdl_8cs.html#ad83fb941855ba7c4aa2bb65245437777">green</a>, <a class="el" href="_sdl_8cs.html#aa6074166cc77c18081343a82d3af99bf">blue</a>, <a class="el" href="_sdl_8cs.html#a62197192f0fbf4e0675eb37be1c4c175">alpha</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">delegate void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a663d1d3a216c06e59bc607a84058f913">AudioSpecCallbackDelegate</a> (IntPtr userdata, IntPtr stream, int len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used in the SDL_AudioSpec struct.  <a href="#a663d1d3a216c06e59bc607a84058f913"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">delegate int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a4c40631c6aad689b8c805e443823aa42">SDL_EventFilter</a> ([Out] SDL_Event evt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function sets up a filter to process all events before they change internal state and are posted to the internal event queue.  <a href="#a4c40631c6aad689b8c805e443823aa42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">delegate int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a68ebfaab030d39e9670dc4cad092e7e5">ThreadDelegate</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">int (SDLCALL *fn)(void *)  <a href="#a68ebfaab030d39e9670dc4cad092e7e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">delegate int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a43a7c7ef24b53b00cb058b4e7d446d75">SDL_TimerCallback</a> (int interval)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prototype for the timer callback.  <a href="#a43a7c7ef24b53b00cb058b4e7d446d75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">delegate int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a643398553379a3feb14d264cbaf343d3">SDL_NewTimerCallback</a> (int interval)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prototype for the new timer callback.  <a href="#a643398553379a3feb14d264cbaf343d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ada019f86ff1d7d9d7ebf28e8f71cdea1">SDL_QuitSubSystem</a> (int flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shuts down specified subsystems.  <a href="#ada019f86ff1d7d9d7ebf28e8f71cdea1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ac9fba8906c8de0e5bffa554258d92118">SDL_QuitSubSystem</a> (uint flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shuts down specified subsystems.  <a href="#ac9fba8906c8de0e5bffa554258d92118"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a566e12eb1fbcbae53808b0124a5b29b4">SDL_WasInit</a> (int flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks which SDL subsystems are initialized.  <a href="#a566e12eb1fbcbae53808b0124a5b29b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ad2572facb30aa0280ff452ce779ece11">SDL_WasInit</a> (uint flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks which SDL subsystems are initialized.  <a href="#ad2572facb30aa0280ff452ce779ece11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a3acfba2794297d8a0a6d5b047dbaa53c">SDL_Quit</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shuts down SDL.  <a href="#a3acfba2794297d8a0a6d5b047dbaa53c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static byte&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a09dacf1e51fd361c9ddbddf72848ac18">SDL_GetAppState</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function returns the current state of the application, which is a bitwise combination of SDL_APPMOUSEFOCUS, SDL_APPINPUTFOCUS, and SDL_APPACTIVE.  <a href="#a09dacf1e51fd361c9ddbddf72848ac18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a647e403f5077884be644cc50c8374278">SDL_AudioInit</a> (string driver_name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is used internally, and should not be used unless you have a specific need to specify the audio driver you want to use. You should normally use SDL_Init(int) or SDL_InitSubSystem(int).  <a href="#a647e403f5077884be644cc50c8374278"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a788bfa14eb012dad53e2e300d508db01">SDL_AudioQuit</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is used internally, and should not be used unless you have a specific need to specify the audio driver you want to use. You should normally use SDL_Init() or SDL_InitSubSystem().  <a href="#a788bfa14eb012dad53e2e300d508db01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ad374c9d61753113b30c8c4b96295ff3b">SDL_OpenAudio</a> (IntPtr desired, IntPtr obtained)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opens the audio device with the desired parameters.  <a href="#ad374c9d61753113b30c8c4b96295ff3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a577477314e53e0fc9c7edd3af022dbf5">SDL_GetAudioStatus</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current audio state.  <a href="#a577477314e53e0fc9c7edd3af022dbf5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a557320f482d1aa5bfe6121ee7cb7ad9f">SDL_PauseAudio</a> (int pause_on)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pauses and unpauses the audio callback processing.  <a href="#a557320f482d1aa5bfe6121ee7cb7ad9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#aa8db921890dcf82c3a3d759d07a594f6">SDL_LoadWAV_RW</a> (IntPtr src, int freesrc, out IntPtr spec, out IntPtr audio_buf, out int audio_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function loads a WAVE from the data source, automatically freeing that source if 'freesrc' is non-zero. For example, to load a WAVE file, you could do: SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, ...);.  <a href="#aa8db921890dcf82c3a3d759d07a594f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a4b1642f748d1819ccb0d085a5c243c81">SDL_LoadWAV_RW</a> (IntPtr src, int freesrc, out IntPtr spec, out IntPtr audio_buf, out uint audio_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function loads a WAVE from the data source, automatically freeing that source if 'freesrc' is non-zero. For example, to load a WAVE file, you could do: SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, ...);.  <a href="#a4b1642f748d1819ccb0d085a5c243c81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#aa59c06f2223e64f2b5f74b82625dd43f">SDL_FreeWAV</a> (ref IntPtr audio_buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees previously opened WAV data.  <a href="#aa59c06f2223e64f2b5f74b82625dd43f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ab290a18bf5bf8a161042ceb8c43c5654">SDL_BuildAudioCVT</a> (IntPtr cvt, short src_format, byte src_channels, int src_rate, short dst_format, byte dst_channels, int dst_rate)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes a SDL_AudioCVT structure for conversion.  <a href="#ab290a18bf5bf8a161042ceb8c43c5654"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a739fd042edf0170fb6f4ec390763ff3c">SDL_BuildAudioCVT</a> (IntPtr cvt, ushort src_format, byte src_channels, int src_rate, ushort dst_format, byte dst_channels, int dst_rate)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes a SDL_AudioCVT structure for conversion.  <a href="#a739fd042edf0170fb6f4ec390763ff3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a7ed641a1e339dc97cfd58c08dd9af2e2">SDL_ConvertAudio</a> (IntPtr cvt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert audio data to a desired audio format.  <a href="#a7ed641a1e339dc97cfd58c08dd9af2e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#affaed37dcb295519bdb4bce591c66797">SDL_MixAudio</a> (IntPtr dst, IntPtr src, int len, int volume)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mix audio data.  <a href="#affaed37dcb295519bdb4bce591c66797"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a64dae2fd7e298f7ce4f3185af1a7f676">SDL_MixAudio</a> (IntPtr dst, IntPtr src, uint len, int volume)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mix audio data.  <a href="#a64dae2fd7e298f7ce4f3185af1a7f676"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a228aa7a773a8820468022d53fed4ecd2">SDL_LockAudio</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock out the callback function.  <a href="#a228aa7a773a8820468022d53fed4ecd2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a0a82eaee2425abf8428bca38acbbd8e6">SDL_UnlockAudio</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock the callback function.  <a href="#a0a82eaee2425abf8428bca38acbbd8e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a5382731aad3887b1285712f976de3843">SDL_CloseAudio</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shuts down audio processing and closes the audio device.  <a href="#a5382731aad3887b1285712f976de3843"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a4610e2722bd3b4c4951ab3c18f4f9a6f">SDL_CDNumDrives</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of CD-ROM drives on the system.  <a href="#a4610e2722bd3b4c4951ab3c18f4f9a6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a66f1e7b4fe4df8529b3afd7c3600d7bc">SDL_CDName</a> (int drive)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a human-readable, system-dependent identifier for the CD-ROM.  <a href="#a66f1e7b4fe4df8529b3afd7c3600d7bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a8ce19531378969ac823e35d181c1079d">SDL_CDPlay</a> (IntPtr cdrom, int start, int length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opens a CD-ROM drive for access.  <a href="#a8ce19531378969ac823e35d181c1079d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#aee7740538b0cf769097abc2b21b4945e">SDL_CDPlayTracks</a> (IntPtr cdrom, int start_track, int start_frame, int ntracks, int nframes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Play the given CD track(s).  <a href="#aee7740538b0cf769097abc2b21b4945e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#adbd88a5c674464c86f076180aef2fec6">SDL_CDPause</a> (IntPtr cdrom)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pauses a CDROM.  <a href="#adbd88a5c674464c86f076180aef2fec6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a12336ccd2439a851f6c616ab5f7bf148">SDL_CDResume</a> (IntPtr cdrom)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resumes a CDROM.  <a href="#a12336ccd2439a851f6c616ab5f7bf148"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a26572955a5bba8a2c73b4458554c900d">SDL_CDStop</a> (IntPtr cdrom)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stops a CDROM.  <a href="#a26572955a5bba8a2c73b4458554c900d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#aca5ade1a8680f4cf001bee830373b14f">SDL_CDEject</a> (IntPtr cdrom)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ejects a CDROM.  <a href="#aca5ade1a8680f4cf001bee830373b14f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a4414db092d107b121633e8b3863e5744">SDL_CDClose</a> (IntPtr cdrom)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes a SDL_CD handle.  <a href="#a4414db092d107b121633e8b3863e5744"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ac2415fc258a833a1ae094bd2ff72afcc">SDL_HasRDTSC</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function returns true if the CPU has the RDTSC instruction.  <a href="#ac2415fc258a833a1ae094bd2ff72afcc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#abd8f8d256dec76719b32e239455da7d9">SDL_HasMMX</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function returns true if the CPU has MMX features.  <a href="#abd8f8d256dec76719b32e239455da7d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ab5311886cda67ed72d52e66497d6c90b">SDL_HasMMXExt</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function returns true if the CPU has MMX Ext. features.  <a href="#ab5311886cda67ed72d52e66497d6c90b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a0fa370c3c28b406d12c3350d3259e8a6">SDL_Has3DNow</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function returns true if the CPU has 3DNow features.  <a href="#a0fa370c3c28b406d12c3350d3259e8a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#aa4a172e7fe8167eb7bc366195c3c9434">SDL_HasSSE</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function returns true if the CPU has SSE features.  <a href="#aa4a172e7fe8167eb7bc366195c3c9434"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a64ad1b3756d3d35977975a16e1900941">SDL_HasSSE2</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function returns true if the CPU has SSE2 features.  <a href="#a64ad1b3756d3d35977975a16e1900941"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#acd1a0fc77a6322d50e92dc2cb562b8f2">SDL_HasAltiVec</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function returns true if the CPU has AltiVec features.  <a href="#acd1a0fc77a6322d50e92dc2cb562b8f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a9b33a09f6189c19b70c91f4d19ac03be">SDL_SetError</a> (string message)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets an SDL error string.  <a href="#a9b33a09f6189c19b70c91f4d19ac03be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a2e98ede54e638a0e99ccf66af20882a8">SDL_ClearError</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the SDL error.  <a href="#a2e98ede54e638a0e99ccf66af20882a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#aa58333f760b728cd8f56bbdbc8a6104e">SDL_PumpEvents</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pumps the event loop, gathering events from the input devices.  <a href="#aa58333f760b728cd8f56bbdbc8a6104e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a85b2190359149f45ab4ef3ab7b4d6887">SDL_PeepEvents</a> ([In, Out]SDL_Event[] events, int numevents, int action, int mask)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks the event queue for messages and optionally returns them.  <a href="#a85b2190359149f45ab4ef3ab7b4d6887"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ac37ad33a4754eb016a62bf60e6401ca3">SDL_PeepEvents</a> ([In, Out]SDL_Event[] events, int numevents, int action, uint mask)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks the event queue for messages and optionally returns them.  <a href="#ac37ad33a4754eb016a62bf60e6401ca3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a85f90a4d8d6ae6e2ab13c9e286a9afd2">SDL_PollEvent</a> (out SDL_Event sdlEvent)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Polls for currently pending events.  <a href="#a85f90a4d8d6ae6e2ab13c9e286a9afd2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a6cf955d55444b337d368ea677e99b6f9">SDL_WaitEvent</a> (out SDL_Event evt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Waits indefinitely for the next available event.  <a href="#a6cf955d55444b337d368ea677e99b6f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a521bf458cc5cfc65b822c2b5b8226646">SDL_PushEvent</a> (out SDL_Event evt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pushes an event onto the event queue.  <a href="#a521bf458cc5cfc65b822c2b5b8226646"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#afd1ab8f1891d71ad6544323050271d2d">SDL_SetEventFilter</a> (SDL_EventFilter filter)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets up a filter to process all events before they are posted to the event queue.  <a href="#afd1ab8f1891d71ad6544323050271d2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static SDL_EventFilter&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#aba4dab0b2d671d9f083744794ba77f2d">SDL_GetEventFilter</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a pointer to the event filter.  <a href="#aba4dab0b2d671d9f083744794ba77f2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a33f65e0690703749dc213ed95b406dd2">SDL_EventState</a> (byte type, int state)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function allows you to set the state of processing certain events.  <a href="#a33f65e0690703749dc213ed95b406dd2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a4b02c05e1ac0903e32c86f0702140a78">SDL_NumJoysticks</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Count the number of joysticks attached to the system.  <a href="#a4b02c05e1ac0903e32c86f0702140a78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a1884e3601e7aa306d7b2e27884c16504">SDL_JoystickOpen</a> (int device_index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a joystick for use.  <a href="#a1884e3601e7aa306d7b2e27884c16504"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a94f97c445e859cd7dd799f103cdf3eaa">SDL_JoystickOpened</a> (int device_index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if a joystick has been opened.  <a href="#a94f97c445e859cd7dd799f103cdf3eaa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a71323f226d822778a13e1a91448e185c">SDL_JoystickIndex</a> (IntPtr joystick)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the index of an SDL_Joystick.  <a href="#a71323f226d822778a13e1a91448e185c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a80e04d0de1e40862a97c1851329bf360">SDL_JoystickNumAxes</a> (IntPtr joystick)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of joystick axes.  <a href="#a80e04d0de1e40862a97c1851329bf360"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ac3a30f56273e3f2919bb2db0e9770929">SDL_JoystickNumBalls</a> (IntPtr joystick)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of joystick trackballs.  <a href="#ac3a30f56273e3f2919bb2db0e9770929"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a41286db94e72dd658f4e394843ccd994">SDL_JoystickNumHats</a> (IntPtr joystick)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of joystick hats.  <a href="#a41286db94e72dd658f4e394843ccd994"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a059acbc1523b7994d3882d4fbb8e20ff">SDL_JoystickNumButtons</a> (IntPtr joystick)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of joystick buttons.  <a href="#a059acbc1523b7994d3882d4fbb8e20ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a37f3184ae17e4de28a75b8f2fdda592b">SDL_JoystickUpdate</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Updates the state of all joysticks.  <a href="#a37f3184ae17e4de28a75b8f2fdda592b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a4b5786d792bade406949c738f0290eca">SDL_JoystickEventState</a> (int state)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable/disable joystick event polling.  <a href="#a4b5786d792bade406949c738f0290eca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ab6c4b492ca0368f81c3aef8c49ebf21d">SDL_JoystickGetAxis</a> (IntPtr joystick, int axis)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current state of an axis.  <a href="#ab6c4b492ca0368f81c3aef8c49ebf21d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static byte&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#aa92ba2b7e2f685e0fe7587b73cbd8f22">SDL_JoystickGetHat</a> (IntPtr joystick, int hat)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current state of a joystick hat.  <a href="#aa92ba2b7e2f685e0fe7587b73cbd8f22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ac507b201a80334bc2e9a62ba44d8534b">SDL_JoystickGetBall</a> (IntPtr joystick, int ball, out int dx, out int dy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get relative trackball motion.  <a href="#ac507b201a80334bc2e9a62ba44d8534b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static byte&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ab46ed3af900d20b62a7aa26570ecdff8">SDL_JoystickGetButton</a> (IntPtr joystick, int button)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current state of a given button on a given joystick.  <a href="#ab46ed3af900d20b62a7aa26570ecdff8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a57539dd46dc1b92fd1d1128b23e0b217">SDL_JoystickClose</a> (IntPtr joystick)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes a previously opened joystick.  <a href="#a57539dd46dc1b92fd1d1128b23e0b217"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a84ff6db83e36f31aa5b5643cc18b1364">SDL_EnableUNICODE</a> (int enable)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable UNICODE translation.  <a href="#a84ff6db83e36f31aa5b5643cc18b1364"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#af31ec1fa8ac9f58ec682d0ae0b363cc8">SDL_EnableKeyRepeat</a> (int rate, int delay)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set keyboard repeat rate.  <a href="#af31ec1fa8ac9f58ec682d0ae0b363cc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a8159db05cf68eb62d668e7c4bb8536b1">SDL_GetKeyRepeat</a> (out int rate, out int delay)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get keyboard repeat rate.  <a href="#a8159db05cf68eb62d668e7c4bb8536b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#acf4ace37b9b7f9383221e52a5b2113c3">SDL_GetModState</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the state of modifier keys.  <a href="#acf4ace37b9b7f9383221e52a5b2113c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a5d90d7264d596d72c47e57870d2c05fa">SDL_SetModState</a> (int modstate)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the current key modifier state.  <a href="#a5d90d7264d596d72c47e57870d2c05fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#adf86ae9120ae0ea0fb602dfa34401edc">SDL_LoadObject</a> (string sofile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function dynamically loads a shared object and returns a pointer to the object handle (or NULL if there was an error).  <a href="#adf86ae9120ae0ea0fb602dfa34401edc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#aea95d437c48a63fc2b057278ab0b9c69">SDL_LoadFunction</a> (IntPtr handle, string name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an object handle, this function looks up the address of the named function in the shared object and returns it. This address is no longer valid after calling <a class="el" href="_sdl_8cs.html#a39ec0a82df272b96dec07e31b7da403a" title="Unload a shared object from memory.">SDL_UnloadObject()</a>.  <a href="#aea95d437c48a63fc2b057278ab0b9c69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a39ec0a82df272b96dec07e31b7da403a">SDL_UnloadObject</a> (IntPtr handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unload a shared object from memory.  <a href="#a39ec0a82df272b96dec07e31b7da403a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static byte&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a5f331fd789dbcc61437a6fe406b4454f">SDL_GetMouseState</a> (out int x, out int y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the current state of the mouse.  <a href="#a5f331fd789dbcc61437a6fe406b4454f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static byte&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a33fff3abfc66a4ed0344cb16d47bc92f">SDL_GetRelativeMouseState</a> (out int x, out int y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the current state of the mouse.  <a href="#a33fff3abfc66a4ed0344cb16d47bc92f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a1f870df2b13fdb36e3ea8a10aab057ca">SDL_WarpMouse</a> (short x, short y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the position of the mouse cursor.  <a href="#a1f870df2b13fdb36e3ea8a10aab057ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ac89483738346b9445fd60502f9f93e71">SDL_WarpMouse</a> (ushort x, ushort y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the position of the mouse cursor.  <a href="#ac89483738346b9445fd60502f9f93e71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#aab5253287140e2324b65aa03519ea6d8">SDL_CreateCursor</a> (ref byte data, ref byte mask, int w, int <a class="el" href="_sdl_8cs.html#ae53b59602879361d91ef9a2bdd5ae091">h</a>, int hot_x, int hot_y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new mouse cursor.  <a href="#aab5253287140e2324b65aa03519ea6d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a6b58417a3cfb7d43adae3e661991ec1f">SDL_SetCursor</a> (ref <a class="el" href="struct_s_d_l___cursor.html">SDL_Cursor</a> cursor)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the currently active cursor to the specified one.  <a href="#a6b58417a3cfb7d43adae3e661991ec1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a0a560b30afc5f63ddb75ea60a9ab8a2f">SDL_GetCursor</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the currently active cursor.  <a href="#a0a560b30afc5f63ddb75ea60a9ab8a2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a9649cb004abe3f8d89f6763387ca3bc4">SDL_FreeCursor</a> (ref <a class="el" href="struct_s_d_l___cursor.html">SDL_Cursor</a> cursor)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees a cursor created with SDL_CreateCursor.  <a href="#a9649cb004abe3f8d89f6763387ca3bc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a4e85211428ccac72ba71d06b2391ab06">SDL_ShowCursor</a> (int toggle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Toggle whether or not the cursor is shown on the screen.  <a href="#a4e85211428ccac72ba71d06b2391ab06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#add77a85ba39c31e44f86060ceea1d891">SDL_CreateMutex</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a mutex, initialized unlocked.  <a href="#add77a85ba39c31e44f86060ceea1d891"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ac1f1e28042806cf6563ecc9da8b43cff">SDL_mutexP</a> (IntPtr mutex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock the mutex (Returns 0, or -1 on error).  <a href="#ac1f1e28042806cf6563ecc9da8b43cff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ab31b43efd85be6ef6987deec813d582b">SDL_mutexV</a> (IntPtr mutex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock the mutex (Returns 0, or -1 on error).  <a href="#ab31b43efd85be6ef6987deec813d582b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a75da38ee7599743465b8622c68596a39">SDL_DestroyMutex</a> (IntPtr mutex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a mutex.  <a href="#a75da38ee7599743465b8622c68596a39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a17908a0f03b8e22466f71bfb177e233a">SDL_CreateSemaphore</a> (int initial_value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a semaphore, initialized with value, returns NULL on failure.  <a href="#a17908a0f03b8e22466f71bfb177e233a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ae1a363ea92381eeb2b198e4431fbc2d0">SDL_CreateSemaphore</a> (uint initial_value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a semaphore, initialized with value, returns NULL on failure.  <a href="#ae1a363ea92381eeb2b198e4431fbc2d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a27b779d0e42b6b2a47556c89a8956050">SDL_DestroySemaphore</a> (IntPtr sem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a semaphore.  <a href="#a27b779d0e42b6b2a47556c89a8956050"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a47831bed0a285a3d765b401347eb09cc">SDL_SemWait</a> (IntPtr sem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function suspends the calling thread until the semaphore pointed to by sem has a positive count. It then atomically decreases the semaphore count.  <a href="#a47831bed0a285a3d765b401347eb09cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a89e09512b0fd719d679aa5c4b1468fcc">SDL_SemtryWait</a> (IntPtr sem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Non-blocking variant of <a class="el" href="_sdl_8cs.html#a47831bed0a285a3d765b401347eb09cc" title="This function suspends the calling thread until the semaphore pointed to by sem has a positive count...">SDL_SemWait()</a>, returns 0 if the wait succeeds, SDL_MUTEX_TIMEDOUT if the wait would block, and -1 on error.  <a href="#a89e09512b0fd719d679aa5c4b1468fcc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a2ceabbfbfd3f7953a3d8588ddc7f2dd1">SDL_SemWaitTimeout</a> (IntPtr sem, int ms)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Variant of <a class="el" href="_sdl_8cs.html#a47831bed0a285a3d765b401347eb09cc" title="This function suspends the calling thread until the semaphore pointed to by sem has a positive count...">SDL_SemWait()</a> with a timeout in milliseconds, returns 0 if the wait succeeds, SDL_MUTEX_TIMEDOUT if the wait does not succeed in the allotted time, and -1 on error. On some platforms this function is implemented by looping with a delay of 1 ms, and so should be avoided if possible.  <a href="#a2ceabbfbfd3f7953a3d8588ddc7f2dd1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a790d70652c06bb2c6ed8a550f4306eb9">SDL_SemWaitTimeout</a> (IntPtr sem, uint ms)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Variant of <a class="el" href="_sdl_8cs.html#a47831bed0a285a3d765b401347eb09cc" title="This function suspends the calling thread until the semaphore pointed to by sem has a positive count...">SDL_SemWait()</a> with a timeout in milliseconds, returns 0 if the wait succeeds, SDL_MUTEX_TIMEDOUT if the wait does not succeed in the allotted time, and -1 on error. On some platforms this function is implemented by looping with a delay of 1 ms, and so should be avoided if possible.  <a href="#a790d70652c06bb2c6ed8a550f4306eb9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a335e67ad56be81afeb4f714d82176f7b">SDL_SemPost</a> (IntPtr sem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically increases the semaphore's count (not blocking), returns 0, or -1 on error.  <a href="#a335e67ad56be81afeb4f714d82176f7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#aa815d7907553c24ac8225e5f9b3bae47">SDL_SemValue</a> (IntPtr sem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current count of the semaphore.  <a href="#aa815d7907553c24ac8225e5f9b3bae47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a2bb559daf2f04feb28fab505f4f934cf">SDL_CreateCond</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a condition variable.  <a href="#a2bb559daf2f04feb28fab505f4f934cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a5a60e09c4685b2db2e55312008da0275">SDL_DestroyCond</a> (IntPtr cond)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a condition variable.  <a href="#a5a60e09c4685b2db2e55312008da0275"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a88bd2bdcf0833d744ec48eb5a20b553e">SDL_CondSignal</a> (IntPtr cond)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restart one of the threads that are waiting on the condition variable, returns 0 or -1 on error.  <a href="#a88bd2bdcf0833d744ec48eb5a20b553e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ac70948782dbee69b01b3e386e20081f1">SDL_CondBroadcast</a> (IntPtr cond)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restart all threads that are waiting on the condition variable, returns 0 or -1 on error.  <a href="#ac70948782dbee69b01b3e386e20081f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ab19e817dc5ae396cca2d5d1646e5f496">SDL_CondWait</a> (IntPtr cond, IntPtr mut)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait on the condition variable, unlocking the provided mutex. The mutex must be locked before entering this function! Returns 0 when it is signaled, or -1 on error.  <a href="#ab19e817dc5ae396cca2d5d1646e5f496"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ad8bd3796951f0de8777c732b629e974b">SDL_CondWaitTimeout</a> (IntPtr cond, IntPtr mutex, int ms)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Waits for at most 'ms' milliseconds, and returns 0 if the condition variable is signaled, SDL_MUTEX_TIMEDOUT if the condition is not signaled in the allotted time, and -1 on error. On some platforms this function is implemented by looping with a delay of 1 ms, and so should be avoided if possible.  <a href="#ad8bd3796951f0de8777c732b629e974b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a3ec22d858b5df88c8a6c83d4cbe71bae">SDL_CondWaitTimeout</a> (IntPtr cond, IntPtr mutex, uint ms)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Waits for at most 'ms' milliseconds, and returns 0 if the condition variable is signaled, SDL_MUTEX_TIMEDOUT if the condition is not signaled in the allotted time, and -1 on error. On some platforms this function is implemented by looping with a delay of 1 ms, and so should be avoided if possible.  <a href="#a3ec22d858b5df88c8a6c83d4cbe71bae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a5c5d2e26df99930f33d8b57c2a95874b">SDL_RWFromFile</a> (string file, string mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create SDL_RWops structures from file.  <a href="#a5c5d2e26df99930f33d8b57c2a95874b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a5b1012f5444376abc443d022a9d8c547">SDL_RWFromMem</a> (IntPtr mem, int size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create SDL_RWops structures from memory.  <a href="#a5b1012f5444376abc443d022a9d8c547"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a3c6da7942616b307b7fdf86e6402daf4">SDL_RWFromFP</a> (IntPtr fp, int autoclose)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SDL_RWFromFP creates a new SDL_RWops structure from a file pointer, opened with stdio. If autoclose is nonzero, the file will be automatically closed when the RWops structure is closed.  <a href="#a3c6da7942616b307b7fdf86e6402daf4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ab5bf8b28e005615987c706138b89ff26">SDL_RWFromConstMem</a> (IntPtr mem, int size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepares a constant memory area for use with RWops.  <a href="#ab5bf8b28e005615987c706138b89ff26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#aa1fe24060926a8679b4a16201728a1e9">SDL_AllocRW</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates an empty, unpopulated SDL_RWops structure.  <a href="#aa1fe24060926a8679b4a16201728a1e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a13c12ec9d6bfe668b50e13cb71ebd8ee">SDL_FreeRW</a> (IntPtr context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees an SDL_RWops structure allocated by <a class="el" href="_sdl_8cs.html#aa1fe24060926a8679b4a16201728a1e9" title="Allocates an empty, unpopulated SDL_RWops structure.">SDL_AllocRW</a>.  <a href="#a13c12ec9d6bfe668b50e13cb71ebd8ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a206f12b60270e78917d75bda7e5acd1d">SDL_ReadLE16</a> (IntPtr src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read an item of the specified endianness and return in native format.  <a href="#a206f12b60270e78917d75bda7e5acd1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a3820fcdf32f5c14454dfca107f5fd5c3">SDL_ReadBE16</a> (IntPtr src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read an item of the specified endianness and return in native format.  <a href="#a3820fcdf32f5c14454dfca107f5fd5c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a0cfac7e23f6953f72d60dc5c04cf39e6">SDL_ReadLE32</a> (IntPtr src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read an item of the specified endianness and return in native format.  <a href="#a0cfac7e23f6953f72d60dc5c04cf39e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#aa8d7489565807f2a237912cacf5fac42">SDL_ReadBE32</a> (IntPtr src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read an item of the specified endianness and return in native format.  <a href="#aa8d7489565807f2a237912cacf5fac42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a64bbc037c191d11d49b4bf080f5fd0f8">SDL_ReadLE64</a> (IntPtr src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read an item of the specified endianness and return in native format.  <a href="#a64bbc037c191d11d49b4bf080f5fd0f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a3bb1c79f8a17c889dd6bab03b6545306">SDL_ReadBE64</a> (IntPtr src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read an item of the specified endianness and return in native format.  <a href="#a3bb1c79f8a17c889dd6bab03b6545306"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a2fdae0bf28d3722f3e906047d7ec0182">SDL_WriteLE16</a> (IntPtr dst, short val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write an item of native format to the specified endianness.  <a href="#a2fdae0bf28d3722f3e906047d7ec0182"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ae1e40cd1122e71b42e882eb93fa00c7a">SDL_WriteLE16</a> (IntPtr dst, ushort val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write an item of native format to the specified endianness.  <a href="#ae1e40cd1122e71b42e882eb93fa00c7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#aa002784fe0bca405d0fc88e4267afa4f">SDL_WriteBE16</a> (IntPtr dst, short val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write an item of native format to the specified endianness.  <a href="#aa002784fe0bca405d0fc88e4267afa4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a1e57ed59769589d70850e456a28960bb">SDL_WriteBE16</a> (IntPtr dst, ushort val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write an item of native format to the specified endianness.  <a href="#a1e57ed59769589d70850e456a28960bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a70425bf77cfada9c4fb991b42ad46393">SDL_WriteLE32</a> (IntPtr dst, int val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write an item of native format to the specified endianness.  <a href="#a70425bf77cfada9c4fb991b42ad46393"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a697d3ebce5c06bf8e4a6532b67153dee">SDL_WriteLE32</a> (IntPtr dst, uint val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write an item of native format to the specified endianness.  <a href="#a697d3ebce5c06bf8e4a6532b67153dee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a13cef4fa79dc88cf3cfe6313e757baa7">SDL_WriteBE32</a> (IntPtr dst, int val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write an item of native format to the specified endianness.  <a href="#a13cef4fa79dc88cf3cfe6313e757baa7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a4724532d8936f6d147a3c575eaa22fef">SDL_WriteBE32</a> (IntPtr dst, uint val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write an item of native format to the specified endianness.  <a href="#a4724532d8936f6d147a3c575eaa22fef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a5e4064a0aa42a4400d879508d187ab11">SDL_WriteLE64</a> (IntPtr dst, long val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write an item of native format to the specified endianness.  <a href="#a5e4064a0aa42a4400d879508d187ab11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a7602949d82e0891d7b80089e86d3ae5c">SDL_WriteBE64</a> (IntPtr dst, long val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write an item of native format to the specified endianness.  <a href="#a7602949d82e0891d7b80089e86d3ae5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a6c1f0715d41310329e65705f5d54e83f">SDL_putenv</a> (string variable)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Puts a variable of the form "name=value" into the environment.  <a href="#a6c1f0715d41310329e65705f5d54e83f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a148bbf4aaf00821ca48734e33384a391">SDL_GetWMInfo</a> (out Sdl.SDL_SysWMinfo_Unix info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gives you custom hooks into the window manager information.  <a href="#a148bbf4aaf00821ca48734e33384a391"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#abcb8c598d4a92a68e5f7e0239b1a4535">SDL_GetWMInfo</a> (out Sdl.SDL_SysWMinfo_Windows info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gives you custom hooks into the window manager information.  <a href="#abcb8c598d4a92a68e5f7e0239b1a4535"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a5ae99456dd9bdad465541ed1550fcd20">SDL_GetWMInfo</a> (out Sdl.SDL_SysWMinfo_RiscOS info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gives you custom hooks into the window manager information.  <a href="#a5ae99456dd9bdad465541ed1550fcd20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#add287c559391038667a6f48f36c9b4c1">SDL_GetWMInfo</a> (out Sdl.SDL_SysWMinfo info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gives you custom hooks into the window manager information.  <a href="#add287c559391038667a6f48f36c9b4c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a341bd10695a15949d264155ff880c866">SDL_CreateThread</a> (ThreadDelegate fn, object data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create thread.  <a href="#a341bd10695a15949d264155ff880c866"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a4b5bdffdeb7867e252b6272b4aee0964">SDL_ThreadID</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the 32-bit thread identifier for the current thread.  <a href="#a4b5bdffdeb7867e252b6272b4aee0964"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a3f22e9f294be574d51c6397cec5cfbc3">SDL_GetThreadID</a> (IntPtr thread)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the 32-bit thread identifier for the specified thread, equivalent to <a class="el" href="_sdl_8cs.html#a4b5bdffdeb7867e252b6272b4aee0964" title="Get the 32-bit thread identifier for the current thread.">SDL_ThreadID()</a> if the specified thread is NULL.  <a href="#a3f22e9f294be574d51c6397cec5cfbc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#aa3d063882199499f0ce29c84ac2a1ddb">SDL_WaitThread</a> (IntPtr thread, out int status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a thread to finish. The return code for the thread function is placed in the area pointed to by 'status', if 'status' is not NULL.  <a href="#aa3d063882199499f0ce29c84ac2a1ddb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a3c935d9acb1768be97c494edaa628bab">SDL_KillThread</a> (IntPtr thread)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forcefully kill a thread without worrying about its state.  <a href="#a3c935d9acb1768be97c494edaa628bab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#acafb269385363a2029e9765e6bdffe79">SDL_GetTicks</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of milliseconds since the SDL library initialization.  <a href="#acafb269385363a2029e9765e6bdffe79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a71ab491dce88b1d92c008dca21b47c13">SDL_Delay</a> (int ms)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait a specified number of milliseconds before returning.  <a href="#a71ab491dce88b1d92c008dca21b47c13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#afd1e96591abd437068e6e375dff9649f">SDL_Delay</a> (uint ms)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait a specified number of milliseconds before returning.  <a href="#afd1e96591abd437068e6e375dff9649f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a43f6e27a3a67800dd7c252305fe79839">SDL_SetTimer</a> (int interval, SDL_TimerCallback callback)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a callback to run after the specified number of milliseconds has elapsed.  <a href="#a43f6e27a3a67800dd7c252305fe79839"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a7e9d2d16dfb1cdd312f1d0b45f989dcc">SDL_SetTimer</a> (uint interval, SDL_TimerCallback callback)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a callback to run after the specified number of milliseconds has elapsed.  <a href="#a7e9d2d16dfb1cdd312f1d0b45f989dcc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_s_d_l___timer_i_d.html">SDL_TimerID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a0847fd552fc17aa314f866ac16db60df">SDL_AddTimer</a> (int interval, SDL_NewTimerCallback callback)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a timer which will call a callback after the specified number of milliseconds has elapsed.  <a href="#a0847fd552fc17aa314f866ac16db60df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_s_d_l___timer_i_d.html">SDL_TimerID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a0084f0508a98488790b16db0ec6324f5">SDL_AddTimer</a> (uint interval, SDL_NewTimerCallback callback)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a timer which will call a callback after the specified number of milliseconds has elapsed.  <a href="#a0084f0508a98488790b16db0ec6324f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a135aaf0e0425b1dcf1904b966509c3c0">SDL_RemoveTimer</a> (<a class="el" href="struct_s_d_l___timer_i_d.html">SDL_TimerID</a> t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a timer which was added with <a class="el" href="_sdl_8cs.html#a0847fd552fc17aa314f866ac16db60df" title="Add a timer which will call a callback after the specified number of milliseconds has elapsed...">SDL_AddTimer(int, SDL_NewTimerCallback)</a>.  <a href="#a135aaf0e0425b1dcf1904b966509c3c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a997bdaa5371cb303155a6195dfc5ec4b">SDL_GetVideoSurface</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function returns a pointer to the current display surface.  <a href="#a997bdaa5371cb303155a6195dfc5ec4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a016732fde2f5c8a5bf71953cc8cba10f">SDL_GetVideoInfo</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function returns a read-only pointer to information about the video hardware.  <a href="#a016732fde2f5c8a5bf71953cc8cba10f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ac022f5f4d029ec3d89f6257b8f716951">SDL_VideoModeOK</a> (int width, int height, int bpp, int flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check to see if a particular video mode is supported.  <a href="#ac022f5f4d029ec3d89f6257b8f716951"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a7af0f2e30f654a9e5f260d561fe09ef8">SDL_VideoModeOK</a> (int width, int height, int bpp, uint flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check to see if a particular video mode is supported.  <a href="#a7af0f2e30f654a9e5f260d561fe09ef8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a961f7efdc2a7ec3860e93140853092f7">SDL_SetVideoMode</a> (int width, int height, int bpp, int flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up a video mode with the specified width, height and bits-per-pixel.  <a href="#a961f7efdc2a7ec3860e93140853092f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a9f7878de4f7e109ea2485a4865d81afd">SDL_SetVideoMode</a> (int width, int height, int bpp, uint flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up a video mode with the specified width, height and bits-per-pixel.  <a href="#a9f7878de4f7e109ea2485a4865d81afd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a7a553064b9c7c9be654714fa618d67db">SDL_UpdateRects</a> (IntPtr <a class="el" href="_sdl_8cs.html#a968bba55c7ad32b326939fefd1bbb017">screen</a>, int numrects,[In, Out] <a class="el" href="struct_s_d_l___rect.html">SDL_Rect</a>[] rects)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes sure the given list of rectangles is updated on the given screen.  <a href="#a7a553064b9c7c9be654714fa618d67db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a332672dbfad4d5a62f042f8039203de1">SDL_UpdateRect</a> (IntPtr <a class="el" href="_sdl_8cs.html#a968bba55c7ad32b326939fefd1bbb017">screen</a>, int x, int y, int w, int <a class="el" href="_sdl_8cs.html#ae53b59602879361d91ef9a2bdd5ae091">h</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes sure the given area is updated on the given screen.  <a href="#a332672dbfad4d5a62f042f8039203de1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a918ef68b4ae9d6cb43373143d05e187d">SDL_UpdateRect</a> (IntPtr <a class="el" href="_sdl_8cs.html#a968bba55c7ad32b326939fefd1bbb017">screen</a>, int x, int y, uint w, uint <a class="el" href="_sdl_8cs.html#ae53b59602879361d91ef9a2bdd5ae091">h</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes sure the given area is updated on the given screen.  <a href="#a918ef68b4ae9d6cb43373143d05e187d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#acc195af71a1137f48f929bf559d72bc0">SDL_Flip</a> (IntPtr <a class="el" href="_sdl_8cs.html#a968bba55c7ad32b326939fefd1bbb017">screen</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps screen buffers.  <a href="#acc195af71a1137f48f929bf559d72bc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#aec2c6c149b3567ffb29ff86bc202b43f">SDL_SetGamma</a> (float <a class="el" href="_sdl_8cs.html#a42c3a4a0281e61ee592e36a3eda020f2">red</a>, float <a class="el" href="_sdl_8cs.html#ad83fb941855ba7c4aa2bb65245437777">green</a>, float <a class="el" href="_sdl_8cs.html#aa6074166cc77c18081343a82d3af99bf">blue</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the gamma correction for each of the color channels.  <a href="#aec2c6c149b3567ffb29ff86bc202b43f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#add53fba5948db676ea3988e8d8b040cf">SDL_SetGammaRamp</a> ([In, Out] short[] <a class="el" href="_sdl_8cs.html#a42c3a4a0281e61ee592e36a3eda020f2">red</a>,[In, Out] short[] <a class="el" href="_sdl_8cs.html#ad83fb941855ba7c4aa2bb65245437777">green</a>,[In, Out] short[] <a class="el" href="_sdl_8cs.html#aa6074166cc77c18081343a82d3af99bf">blue</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the gamma translation table for the red, green, and blue channels of the video hardware.  <a href="#add53fba5948db676ea3988e8d8b040cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ae357d10a1961d2760a67332622c788ac">SDL_GetGammaRamp</a> ([In, Out] short[] <a class="el" href="_sdl_8cs.html#a42c3a4a0281e61ee592e36a3eda020f2">red</a>,[In, Out] short[] <a class="el" href="_sdl_8cs.html#ad83fb941855ba7c4aa2bb65245437777">green</a>,[In, Out] short[] <a class="el" href="_sdl_8cs.html#aa6074166cc77c18081343a82d3af99bf">blue</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the color gamma lookup tables for the display.  <a href="#ae357d10a1961d2760a67332622c788ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a50624f7a015f51e780d18ad711168f39">SDL_GetGammaRamp</a> ([In, Out] ushort[] <a class="el" href="_sdl_8cs.html#a42c3a4a0281e61ee592e36a3eda020f2">red</a>,[In, Out] ushort[] <a class="el" href="_sdl_8cs.html#ad83fb941855ba7c4aa2bb65245437777">green</a>,[In, Out] ushort[] <a class="el" href="_sdl_8cs.html#aa6074166cc77c18081343a82d3af99bf">blue</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the color gamma lookup tables for the display.  <a href="#a50624f7a015f51e780d18ad711168f39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">...&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a9fc8cc284d2644ba059682359ad77f78">for</a> (<a class="el" href="_sdl_8cs.html#acb559820d9ca11295b4500f179ef6392">i</a>=0;<a class="el" href="_sdl_8cs.html#acb559820d9ca11295b4500f179ef6392">i</a> &amp;<a class="el" href="_sdl_8cs.html#a857c8c8ca640fb2283d751a715bd1ee9">lt</a>;256;<a class="el" href="_sdl_8cs.html#acb559820d9ca11295b4500f179ef6392">i</a>++)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a17895976c498bf8a1352ea240f80c8dc">if</a> (!<a class="el" href="_sdl_8cs.html#a968bba55c7ad32b326939fefd1bbb017">screen</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ad3dd27ac574c77908bc25298e847f77a">SDL_SetColors</a> (<a class="el" href="_sdl_8cs.html#a968bba55c7ad32b326939fefd1bbb017">screen</a>, <a class="el" href="_sdl_8cs.html#aece5a7af4770c985f1b8cc20246f5b28">colors</a>, 0, 256)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">....&lt;/example &gt;&lt; paramname=&quot;surface&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;firstcolor&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;ncolors&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;colors&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; returns &gt; If <br class="typebreak"/>
<a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a> is not a palettized <br class="typebreak"/>
this function does <br class="typebreak"/>
returning.If all of the <a class="el" href="_sdl_8cs.html#aece5a7af4770c985f1b8cc20246f5b28">colors</a> <br class="typebreak"/>
were set as passed to&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ace1bdb02bdad276fcbce4b46012ba4b0">SDL_SetColors</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">....&lt;/example &gt;&lt; paramname=&quot;surface&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;firstcolor&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;ncolors&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;colors&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; returns &gt; If <br class="typebreak"/>
<a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a> is not a palettized <br class="typebreak"/>
this function does <br class="typebreak"/>
returning.If all of the <a class="el" href="_sdl_8cs.html#aece5a7af4770c985f1b8cc20246f5b28">colors</a> <br class="typebreak"/>
were set as passed to it will <br class="typebreak"/>
return.If not all the color <br class="typebreak"/>
entries were set exactly as it <br class="typebreak"/>
will and you should look at <br class="typebreak"/>
the <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a> palette to <br class="typebreak"/>
determine the actual color <br class="typebreak"/>
palette.&lt;/returns &gt;<br class="typebreak"/>
&lt; seealsocref=&quot;SDL_Color&quot;&gt;<br class="typebreak"/>
 SDL_Color&lt;/seealso &gt;<br class="typebreak"/>
&lt; seealsocref=&quot;SDL_Surface&quot;&gt;<br class="typebreak"/>
 SDL_Surface&lt;/seealso &gt;<br class="typebreak"/>
&lt; seealsocref=&quot;SDL_SetPalette&quot;&gt;<br class="typebreak"/>
 SDL_SetPalette&lt;/seealso &gt;<br class="typebreak"/>
&lt; seealsocref=&quot;SDL_SetVideoMode(int,int,int,int)&quot;&gt;<br class="typebreak"/>
 SDL_SetVideoMode&lt;/seealso &gt;<br class="typebreak"/>
 *static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a7d863c2bb7590dba1b9eb040d44449e7">SDL_SetColors</a> (IntPtr <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a>,[In, Out] <a class="el" href="struct_s_d_l___color.html">SDL_Color</a>[] <a class="el" href="_sdl_8cs.html#aece5a7af4770c985f1b8cc20246f5b28">colors</a>, int firstcolor, int ncolors)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a1f330365593a084550a4845aebe80441">SDL_SetPalette</a> (<a class="el" href="_sdl_8cs.html#a968bba55c7ad32b326939fefd1bbb017">screen</a>, SDL_LOGPAL|SDL_PHYSPAL, <a class="el" href="_sdl_8cs.html#aece5a7af4770c985f1b8cc20246f5b28">colors</a>, 0, 256)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">....&lt;/code &gt;&lt;/example &gt;<br class="typebreak"/>
&lt; paramname=&quot;surface&quot;&gt;&lt;/param &gt;<br class="typebreak"/>
&lt; paramname=&quot;colors&quot;&gt;&lt;/param &gt;<br class="typebreak"/>
&lt; paramname=&quot;firstcolor&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;flags&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;ncolors&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; returns &gt; If <br class="typebreak"/>
<a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a> is not a palettized <br class="typebreak"/>
this function does <br class="typebreak"/>
returning.If all of the <a class="el" href="_sdl_8cs.html#aece5a7af4770c985f1b8cc20246f5b28">colors</a> <br class="typebreak"/>
were set as passed to it will <br class="typebreak"/>
return.If not all the color <br class="typebreak"/>
entries were set exactly as it <br class="typebreak"/>
will and you should look at <br class="typebreak"/>
the <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a> palette to <br class="typebreak"/>
determine the actual color <br class="typebreak"/>
palette.&lt;/returns &gt; *static <br class="typebreak"/>
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#afe8acab3b160f7859c903cec5fbb4f86">SDL_SetPalette</a> (IntPtr <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a>, int flags,[In, Out] <a class="el" href="struct_s_d_l___color.html">SDL_Color</a>[] <a class="el" href="_sdl_8cs.html#aece5a7af4770c985f1b8cc20246f5b28">colors</a>, int firstcolor, int ncolors)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a8c6c5785c9010c08364e8abcd34648a0">SDL_MapRGB</a> (IntPtr format, byte r, byte g, byte b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Map a RGB color value to a pixel format.  <a href="#a8c6c5785c9010c08364e8abcd34648a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#aadad00b884d9cab5dcfc16b887963bb3">SDL_MapRGBA</a> (IntPtr format, byte r, byte g, byte b, byte a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Map a RGBA color value to a pixel format.  <a href="#aadad00b884d9cab5dcfc16b887963bb3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#afff8f7111c4869f62dae87b04400b54d">SDL_GetRGB</a> (int <a class="el" href="_sdl_8cs.html#a36392890a1aba4cacbe1cad263a699f0">pixel</a>, IntPtr <a class="el" href="_sdl_8cs.html#a36910ddc19d1bf237b12507db74f71a2">fmt</a>, out byte r, out byte g, out byte b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get RGB values from a pixel in the specified pixel format.  <a href="#afff8f7111c4869f62dae87b04400b54d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a62adb9364b5184962677f5231652c59c">SDL_GetRGB</a> (uint <a class="el" href="_sdl_8cs.html#a36392890a1aba4cacbe1cad263a699f0">pixel</a>, IntPtr <a class="el" href="_sdl_8cs.html#a36910ddc19d1bf237b12507db74f71a2">fmt</a>, out byte r, out byte g, out byte b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get RGB values from a pixel in the specified pixel format.  <a href="#a62adb9364b5184962677f5231652c59c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a283f1dfcfccd35773f6f236a7c021033">SDL_GetRGBA</a> (int <a class="el" href="_sdl_8cs.html#a36392890a1aba4cacbe1cad263a699f0">pixel</a>, IntPtr <a class="el" href="_sdl_8cs.html#a36910ddc19d1bf237b12507db74f71a2">fmt</a>, out byte r, out byte g, out byte b, out byte a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get RGBA values from a pixel in the specified pixel format.  <a href="#a283f1dfcfccd35773f6f236a7c021033"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a68eb18902e9b6f413dbd6ea7afbea5a2">if</a> (<a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a>==NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&lt;/example &gt;&lt; paramname=&quot;flags&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;width&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;height&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;depth&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;Rmask&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;Gmask&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;Bmask&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;Amask&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; returns &gt; IntPtr or <br class="typebreak"/>
NULL upon error.&lt;/returns &gt;<br class="typebreak"/>
&lt; seealsocref=&quot;SDL_CreateRGBSurfaceFrom(System.IntPtr,int,int,int,int,int,int,int,int)&quot;&gt;<br class="typebreak"/>
 SDL_CreateRGBSurfaceFrom<br class="typebreak"/>
&lt;/seealso &gt;&lt; seealsocref=&quot;SDL_FreeSurface&quot;&gt;<br class="typebreak"/>
 SDL_FreeSurface&lt;/seealso &gt;<br class="typebreak"/>
&lt; seealsocref=&quot;SDL_SetVideoMode(int,int,int,int)&quot;&gt;<br class="typebreak"/>
 SDL_SetVideoMode&lt;/seealso &gt;<br class="typebreak"/>
&lt; seealsocref=&quot;SDL_LockSurface&quot;&gt;<br class="typebreak"/>
 SDL_LockSurface&lt;/seealso &gt;<br class="typebreak"/>
&lt; seealsocref=&quot;SDL_PixelFormat&quot;&gt;<br class="typebreak"/>
 SDL_PixelFormat&lt;/seealso &gt;<br class="typebreak"/>
&lt; seealsocref=&quot;SDL_Surface&quot;&gt;<br class="typebreak"/>
 SDL_Surface&lt;/seealso &gt;<br class="typebreak"/>
&lt; seealsocref=&quot;SDL_SetAlpha(IntPtr,int,byte)&quot;&gt;<br class="typebreak"/>
 SDL_SetAlpha&lt;/seealso &gt;<br class="typebreak"/>
&lt; seealsocref=&quot;SDL_SetColorKey(IntPtr,int,int)&quot;&gt;<br class="typebreak"/>
 SDL_SetColorKey&lt;/seealso &gt;<br class="typebreak"/>
 *static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#aa732dd717414124c4710c0d25f8e07ce">SDL_CreateRGBSurface</a> (int flags, int width, int height, int depth, int <a class="el" href="_sdl_8cs.html#a6a9df771fdb653ae2056012af21af56f">Rmask</a>, int <a class="el" href="_sdl_8cs.html#a8ee5a0cd4f45561ba2ec1768f71b4824">Gmask</a>, int <a class="el" href="_sdl_8cs.html#a0c79dd52bfbbf1f797424c029b601a4d">Bmask</a>, int <a class="el" href="_sdl_8cs.html#ac854fb38bb0ed1c2af25170f901ee015">Amask</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&lt;/example &gt;&lt; paramname=&quot;flags&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;width&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;height&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;depth&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;Rmask&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;Gmask&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;Bmask&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;Amask&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; returns &gt; IntPtr or <br class="typebreak"/>
NULL upon error.&lt;/returns &gt;<br class="typebreak"/>
&lt; seealsocref=&quot;SDL_CreateRGBSurfaceFrom(System.IntPtr,int,int,int,int,int,int,int,int)&quot;&gt;<br class="typebreak"/>
 SDL_CreateRGBSurfaceFrom<br class="typebreak"/>
&lt;/seealso &gt;&lt; seealsocref=&quot;SDL_FreeSurface&quot;&gt;<br class="typebreak"/>
 SDL_FreeSurface&lt;/seealso &gt;<br class="typebreak"/>
&lt; seealsocref=&quot;SDL_SetVideoMode(int,int,int,int)&quot;&gt;<br class="typebreak"/>
 SDL_SetVideoMode&lt;/seealso &gt;<br class="typebreak"/>
&lt; seealsocref=&quot;SDL_LockSurface&quot;&gt;<br class="typebreak"/>
 SDL_LockSurface&lt;/seealso &gt;<br class="typebreak"/>
&lt; seealsocref=&quot;SDL_PixelFormat&quot;&gt;<br class="typebreak"/>
 SDL_PixelFormat&lt;/seealso &gt;<br class="typebreak"/>
&lt; seealsocref=&quot;SDL_Surface&quot;&gt;<br class="typebreak"/>
 SDL_Surface&lt;/seealso &gt;<br class="typebreak"/>
&lt; seealsocref=&quot;SDL_SetAlpha(IntPtr,int,byte)&quot;&gt;<br class="typebreak"/>
 SDL_SetAlpha&lt;/seealso &gt;<br class="typebreak"/>
&lt; seealsocref=&quot;SDL_SetColorKey(IntPtr,int,int)&quot;&gt;<br class="typebreak"/>
 SDL_SetColorKey&lt;/seealso &gt;<br class="typebreak"/>
 *static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a8676d7148bd6a15ced4b3071c3dcd7aa">SDL_CreateRGBSurface</a> (uint flags, int width, int height, int depth, uint <a class="el" href="_sdl_8cs.html#a6a9df771fdb653ae2056012af21af56f">Rmask</a>, uint <a class="el" href="_sdl_8cs.html#a8ee5a0cd4f45561ba2ec1768f71b4824">Gmask</a>, uint <a class="el" href="_sdl_8cs.html#a0c79dd52bfbbf1f797424c029b601a4d">Bmask</a>, uint <a class="el" href="_sdl_8cs.html#ac854fb38bb0ed1c2af25170f901ee015">Amask</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a3200b95b4afc490010c5a1de969b98b0">SDL_AllocSurface</a> (int flags, int width, int height, int depth, int <a class="el" href="_sdl_8cs.html#a6a9df771fdb653ae2056012af21af56f">Rmask</a>, int <a class="el" href="_sdl_8cs.html#a8ee5a0cd4f45561ba2ec1768f71b4824">Gmask</a>, int <a class="el" href="_sdl_8cs.html#a0c79dd52bfbbf1f797424c029b601a4d">Bmask</a>, int <a class="el" href="_sdl_8cs.html#ac854fb38bb0ed1c2af25170f901ee015">Amask</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as <a class="el" href="_sdl_8cs.html#aa732dd717414124c4710c0d25f8e07ce">SDL_CreateRGBSurface(int, int, int, int, int, int, int, int)</a>  <a href="#a3200b95b4afc490010c5a1de969b98b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#aa2016a25314cfe96b9e1bcc679753756">SDL_AllocSurface</a> (uint flags, int width, int height, int depth, uint <a class="el" href="_sdl_8cs.html#a6a9df771fdb653ae2056012af21af56f">Rmask</a>, uint <a class="el" href="_sdl_8cs.html#a8ee5a0cd4f45561ba2ec1768f71b4824">Gmask</a>, uint <a class="el" href="_sdl_8cs.html#a0c79dd52bfbbf1f797424c029b601a4d">Bmask</a>, uint <a class="el" href="_sdl_8cs.html#ac854fb38bb0ed1c2af25170f901ee015">Amask</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as <a class="el" href="_sdl_8cs.html#aa732dd717414124c4710c0d25f8e07ce">SDL_CreateRGBSurface(int, int, int, int, int, int, int, int)</a>  <a href="#aa2016a25314cfe96b9e1bcc679753756"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a09e1892c9d6a02ce0c8b1ff92e032666">SDL_CreateRGBSurfaceFrom</a> (IntPtr pixels, int width, int height, int depth, int pitch, int <a class="el" href="_sdl_8cs.html#a6a9df771fdb653ae2056012af21af56f">Rmask</a>, int <a class="el" href="_sdl_8cs.html#a8ee5a0cd4f45561ba2ec1768f71b4824">Gmask</a>, int <a class="el" href="_sdl_8cs.html#a0c79dd52bfbbf1f797424c029b601a4d">Bmask</a>, int <a class="el" href="_sdl_8cs.html#ac854fb38bb0ed1c2af25170f901ee015">Amask</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> from pixel data.  <a href="#a09e1892c9d6a02ce0c8b1ff92e032666"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a08011f62ba5e056681ce751a9278dece">SDL_CreateRGBSurfaceFrom</a> (IntPtr pixels, int width, int height, int depth, int pitch, uint <a class="el" href="_sdl_8cs.html#a6a9df771fdb653ae2056012af21af56f">Rmask</a>, uint <a class="el" href="_sdl_8cs.html#a8ee5a0cd4f45561ba2ec1768f71b4824">Gmask</a>, uint <a class="el" href="_sdl_8cs.html#a0c79dd52bfbbf1f797424c029b601a4d">Bmask</a>, uint <a class="el" href="_sdl_8cs.html#ac854fb38bb0ed1c2af25170f901ee015">Amask</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> from pixel data.  <a href="#a08011f62ba5e056681ce751a9278dece"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a3062b061d8f75b52d1c4887209a92c10">SDL_FreeSurface</a> (IntPtr <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees (deletes) a <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a>.  <a href="#a3062b061d8f75b52d1c4887209a92c10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">.&lt;/code &gt;&lt; p &gt; Binds to C <br class="typebreak"/>
function call in SDL_video.or <br class="typebreak"/>
if the <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a> couldn t be <br class="typebreak"/>
locked.&lt;/returns &gt;<br class="typebreak"/>
&lt; seealsocref=&quot;SDL_UnlockSurface&quot;&gt;<br class="typebreak"/>
 SDL_UnlockSurface&lt;/seealso &gt;<br class="typebreak"/>
 *static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#afae9570bf3fb2b26f7403cb1fc4f1353">SDL_LockSurface</a> (IntPtr <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a7a8e68d1721140930c21ac9e793a0a1a">SDL_UnlockSurface</a> (IntPtr <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlocks a previously locked surface.  <a href="#a7a8e68d1721140930c21ac9e793a0a1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a380d06edefbb8abcc0f14859fd25108c">SDL_LoadBMP_RW</a> (IntPtr src, int freesrc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a surface from a seekable SDL data source (memory or file.).  <a href="#a380d06edefbb8abcc0f14859fd25108c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a06454ef83d9e843c1c3f4f47da8435f7">SDL_SaveBMP_RW</a> (IntPtr <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a>, IntPtr dst, int freedst)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a surface to a seekable SDL data source (memory or file.).  <a href="#a06454ef83d9e843c1c3f4f47da8435f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a6143709fbf5b39f734e9de78cfa1d6c8">SDL_SetColorKey</a> (IntPtr <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a>, int flag, int key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the color key (transparent pixel) in a blittable surface and RLE acceleration.  <a href="#a6143709fbf5b39f734e9de78cfa1d6c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a163c4948f939354528b9734d816beeb7">SDL_SetColorKey</a> (IntPtr <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a>, uint flag, uint key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the color key (transparent pixel) in a blittable surface and RLE acceleration.  <a href="#a163c4948f939354528b9734d816beeb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a77f6839de15f85b6c5afd9174894a41a">SDL_SetAlpha</a> (IntPtr <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a>, int flag, byte <a class="el" href="_sdl_8cs.html#a62197192f0fbf4e0675eb37be1c4c175">alpha</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adjust the alpha properties of a surface.  <a href="#a77f6839de15f85b6c5afd9174894a41a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a00c013823736cccea1529c8431beaf5c">SDL_SetAlpha</a> (IntPtr <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a>, uint flag, byte <a class="el" href="_sdl_8cs.html#a62197192f0fbf4e0675eb37be1c4c175">alpha</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adjust the alpha properties of a surface.  <a href="#a00c013823736cccea1529c8431beaf5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a201a7363fdcfe07651a1298a3e4e1778">SDL_SetClipRect</a> (IntPtr <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a>, ref <a class="el" href="struct_s_d_l___rect.html">SDL_Rect</a> rect)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the clipping rectangle for a surface.  <a href="#a201a7363fdcfe07651a1298a3e4e1778"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ac51bb2502786730c93fd5c3cddf029f9">SDL_GetClipRect</a> (IntPtr <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a>, ref <a class="el" href="struct_s_d_l___rect.html">SDL_Rect</a> rect)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the clipping rectangle for a surface.  <a href="#ac51bb2502786730c93fd5c3cddf029f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a120ecaa205cb5d317d43f02e765a963b">SDL_ConvertSurface</a> (IntPtr src, IntPtr <a class="el" href="_sdl_8cs.html#a36910ddc19d1bf237b12507db74f71a2">fmt</a>, int flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a surface to the same format as another surface.  <a href="#a120ecaa205cb5d317d43f02e765a963b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#abe17ebde3616fdbfbe81d9f60c8abdf4">SDL_ConvertSurface</a> (IntPtr src, IntPtr <a class="el" href="_sdl_8cs.html#a36910ddc19d1bf237b12507db74f71a2">fmt</a>, uint flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a surface to the same format as another surface.  <a href="#abe17ebde3616fdbfbe81d9f60c8abdf4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#aec41f77b04d717457433acbecd7a257b">SDL_BlitSurface</a> (IntPtr src, ref <a class="el" href="struct_s_d_l___rect.html">SDL_Rect</a> srcrect, IntPtr dst, ref <a class="el" href="struct_s_d_l___rect.html">SDL_Rect</a> dstrect)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This performs a fast blit from the source surface to the destination surface.  <a href="#aec41f77b04d717457433acbecd7a257b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ac5e42937782d41622cec743f145b4f81">SDL_FillRect</a> (IntPtr <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a>, ref <a class="el" href="struct_s_d_l___rect.html">SDL_Rect</a> rect, int color)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function performs a fast fill of the given rectangle with some color.  <a href="#ac5e42937782d41622cec743f145b4f81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a2be96435f87ccf4bf46776e6b0d30721">SDL_FillRect</a> (IntPtr <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a>, ref <a class="el" href="struct_s_d_l___rect.html">SDL_Rect</a> rect, uint color)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function performs a fast fill of the given rectangle with some color.  <a href="#a2be96435f87ccf4bf46776e6b0d30721"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a557565508a6c32f7bb4703f040a622c1">SDL_DisplayFormat</a> (IntPtr <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a surface to the display format.  <a href="#a557565508a6c32f7bb4703f040a622c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ad76ca477f17f31fd3aaccf8c19f643c1">SDL_DisplayFormatAlpha</a> (IntPtr <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a surface to the display format.  <a href="#ad76ca477f17f31fd3aaccf8c19f643c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a433c9c002d6c6a4a3077fc12ff790372">SDL_CreateYUVOverlay</a> (int width, int height, int format, IntPtr display)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a YUV video overlay.  <a href="#a433c9c002d6c6a4a3077fc12ff790372"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ad409aa089348d881dfa080fef6fd41d0">SDL_CreateYUVOverlay</a> (int width, int height, uint format, IntPtr display)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a YUV video overlay.  <a href="#ad409aa089348d881dfa080fef6fd41d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#aef75e3a4590a542c940f024fa387031d">SDL_LockYUVOverlay</a> (IntPtr overlay)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock an overlay.  <a href="#aef75e3a4590a542c940f024fa387031d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a593554f2e6f34c6fed0c39295884b85d">SDL_UnlockYUVOverlay</a> (IntPtr overlay)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock an overlay.  <a href="#a593554f2e6f34c6fed0c39295884b85d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a2dd4ac9e3a2f29ca1b24098361d8b50f">SDL_DisplayYUVOverlay</a> (IntPtr overlay, ref <a class="el" href="struct_s_d_l___rect.html">SDL_Rect</a> dstrect)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Blit the overlay to the display.  <a href="#a2dd4ac9e3a2f29ca1b24098361d8b50f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a5152023ef4588c85f5190e5a067527bc">SDL_FreeYUVOverlay</a> (IntPtr overlay)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a YUV video overlay.  <a href="#a5152023ef4588c85f5190e5a067527bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#abb5cc574ccf8709efaf0ad4ddff8a717">SDL_GL_LoadLibrary</a> (string path)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify an OpenGL library.  <a href="#abb5cc574ccf8709efaf0ad4ddff8a717"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#af0c1ea0385d89fbb9decae290815f665">SDL_GL_GetProcAddress</a> (string proc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the address of a GL function.  <a href="#af0c1ea0385d89fbb9decae290815f665"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ab8ae049692ea8e12af57ab01980dc71f">SDL_GL_SwapBuffers</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap OpenGL framebuffers/Update Display.  <a href="#ab8ae049692ea8e12af57ab01980dc71f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a9d12980991f938865faa9cc236d88825">SDL_GL_SetAttribute</a> (int attr, int val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a special SDL/OpenGL attribute.  <a href="#a9d12980991f938865faa9cc236d88825"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a9374dd6ba66cae1acd81cdb04fdb62db">SDL_GL_GetAttribute</a> (int attr, out int val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the value of a special SDL/OpenGL attribute.  <a href="#a9374dd6ba66cae1acd81cdb04fdb62db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a166b37121b66298e3f76a4fd8a4890fc">SDL_WM_SetCaption</a> (string title, string icon)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the title and icon text of the display window.  <a href="#a166b37121b66298e3f76a4fd8a4890fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a5de3159d742c3e4c81a54a341702700c">SDL_WM_GetCaption</a> (out string title, out string icon)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the title and icon text of the display window.  <a href="#a5de3159d742c3e4c81a54a341702700c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a4812354ffe2ef55699b0190e6a41ebf3">SDL_WM_SetIcon</a> (IntPtr icon, byte[] mask)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the icon for the display window.  <a href="#a4812354ffe2ef55699b0190e6a41ebf3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#aacb3f37a88ecea9a6fe7bd7257ceee7a">SDL_WM_IconifyWindow</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iconify/Minimise the window.  <a href="#aacb3f37a88ecea9a6fe7bd7257ceee7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ab0e1ad78990e0c3ec5522d9ba29aca74">SDL_WM_ToggleFullScreen</a> (IntPtr <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Toggle fullscreen mode without changing the contents of the screen.  <a href="#ab0e1ad78990e0c3ec5522d9ba29aca74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ad70ae8fd84dc3156a6d670ae8532da28">SDL_WM_GrabInput</a> (int mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Grabs mouse and keyboard input.  <a href="#ad70ae8fd84dc3156a6d670ae8532da28"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tao_1_1_sdl.html#a316da039bbc7edf809d85badeaab6f23">Tao::Sdl.SDL_SysWMEvent</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a36910ddc19d1bf237b12507db74f71a2">fmt</a> = surface.format</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores surface format information.  <a href="#a36910ddc19d1bf237b12507db74f71a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_d_l___surface.html">SDL_Surface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an empty <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a>.  <a href="#a63bb1d55c833f19b63071bbacc7bb5e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a905c521e05ec8042631a912b71d0454e">temp</a> = <a class="el" href="_sdl_8cs.html#a36392890a1aba4cacbe1cad263a699f0">pixel</a>&amp;amp</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a36392890a1aba4cacbe1cad263a699f0">pixel</a> = *((Uint32*)surface.pixels)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Uint8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a42c3a4a0281e61ee592e36a3eda020f2">red</a> = (Uint8)<a class="el" href="_sdl_8cs.html#a905c521e05ec8042631a912b71d0454e">temp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Uint8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ad83fb941855ba7c4aa2bb65245437777">green</a> = (Uint8)<a class="el" href="_sdl_8cs.html#a905c521e05ec8042631a912b71d0454e">temp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Uint8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#aa6074166cc77c18081343a82d3af99bf">blue</a> = (Uint8)<a class="el" href="_sdl_8cs.html#a905c521e05ec8042631a912b71d0454e">temp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Uint8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a62197192f0fbf4e0675eb37be1c4c175">alpha</a> = (Uint8)<a class="el" href="_sdl_8cs.html#a905c521e05ec8042631a912b71d0454e">temp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fmt.&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a6a9df771fdb653ae2056012af21af56f">Rmask</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#aed7a7f1f82df5fd3dd11622b2e8a0351">gt</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fmt.&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a2809d746eb2856c5a293ad74282e7cdd">Rshift</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a857c8c8ca640fb2283d751a715bd1ee9">lt</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fmt.&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a3870e0709fa0202243f20d4af0406d5f">Rloss</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fmt.&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a8ee5a0cd4f45561ba2ec1768f71b4824">Gmask</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fmt.&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ab7727e8f2b2c186d78fa81914102e219">Gshift</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fmt.&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ab9cc005962591e6805dd39a2fda8a836">Gloss</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fmt.&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a0c79dd52bfbbf1f797424c029b601a4d">Bmask</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fmt.&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ad276a57f3d53469698db846f870ff8d2">Bshift</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fmt.&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a5bec03af803d707fc82c2315cda02f3e">Bloss</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fmt.&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ac854fb38bb0ed1c2af25170f901ee015">Amask</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fmt.&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#aba94dde19bff2e8b25432d8435e63b8f">Ashift</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fmt.&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a8ecae7ddf44d437aea0eeac375b14a87">Aloss</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_d_l___surface.html">SDL_Surface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a968bba55c7ad32b326939fefd1bbb017">screen</a> = SDL_SetVideoMode(640, 480, 8, SDL_HWPALETTE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a portion of the colormap for the given 8-bit surface.  <a href="#a968bba55c7ad32b326939fefd1bbb017"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_d_l___color.html">SDL_Color</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#aece5a7af4770c985f1b8cc20246f5b28">colors</a> [256]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#acb559820d9ca11295b4500f179ef6392">i</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">....&lt;/example &gt;&lt; paramname=&quot;surface&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;firstcolor&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;ncolors&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;colors&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; returns &gt; If <br class="typebreak"/>
<a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a> is not a palettized <br class="typebreak"/>
this function does&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a46376027f1df32e5005ec65e91495448">nothing</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">....&lt;/example &gt;&lt; paramname=&quot;surface&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;firstcolor&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;ncolors&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;colors&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; returns &gt; If <br class="typebreak"/>
<a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a> is not a palettized <br class="typebreak"/>
this function does <br class="typebreak"/>
returning.If all of the <a class="el" href="_sdl_8cs.html#aece5a7af4770c985f1b8cc20246f5b28">colors</a> <br class="typebreak"/>
were set as passed to it will <br class="typebreak"/>
return.If not all the color <br class="typebreak"/>
entries were set exactly as&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#aed8345802a260785e5cc4fead969a627">given</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">....&lt;/example &gt;&lt; paramname=&quot;surface&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;firstcolor&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;ncolors&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;colors&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; returns &gt; If <br class="typebreak"/>
<a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a> is not a palettized <br class="typebreak"/>
this function does <br class="typebreak"/>
returning.If all of the <a class="el" href="_sdl_8cs.html#aece5a7af4770c985f1b8cc20246f5b28">colors</a> <br class="typebreak"/>
were set as passed to it will <br class="typebreak"/>
return.If not all the color <br class="typebreak"/>
entries were set exactly as it <br class="typebreak"/>
will&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a1691110f5eb29093dc96488738dc6b1c">return</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">....&lt;/code &gt;&lt;/example &gt;<br class="typebreak"/>
&lt; paramname=&quot;surface&quot;&gt;&lt;/param &gt;<br class="typebreak"/>
&lt; paramname=&quot;colors&quot;&gt;&lt;/param &gt;<br class="typebreak"/>
&lt; paramname=&quot;firstcolor&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;flags&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;ncolors&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; returns &gt; If <br class="typebreak"/>
<a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a> is not a palettized <br class="typebreak"/>
this function does <br class="typebreak"/>
returning.If all of the <a class="el" href="_sdl_8cs.html#aece5a7af4770c985f1b8cc20246f5b28">colors</a> <br class="typebreak"/>
were set as passed to&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a1e7f5af13949fa7719cf5c4e3b19b059">SDL_SetPalette</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a94cbfe2c2213491558b156027ec63238">rmask</a> = 0x000000ff</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a43613889bd9d644775e8da9db3a32375">gmask</a> = 0x00ff0000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a14b0866344628e753ba7670a11b780b4">bmask</a> = 0x0000ff00</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ab8c1e3f1165d8eaaef52fe2bcbb06726">amask</a> = 0x000000ff</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&lt;/example &gt;&lt; paramname=&quot;flags&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;width&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;height&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;depth&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;Rmask&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;Gmask&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;Bmask&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; paramname=&quot;Amask&quot;&gt;<br class="typebreak"/>
&lt;/param &gt;&lt; returns &gt; IntPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#a599562a2f2f1687da586208c2c326ada">to&lt; see cref=&quot;SDL_Surface&quot;/&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">.&lt;/code &gt;&lt; p &gt; Binds to C <br class="typebreak"/>
function call in SDL_video.&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_sdl_8cs.html#ae53b59602879361d91ef9a2bdd5ae091">h</a></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a663d1d3a216c06e59bc607a84058f913"></a><!-- doxytag: member="Sdl.cs::AudioSpecCallbackDelegate" ref="a663d1d3a216c06e59bc607a84058f913" args="(IntPtr userdata, IntPtr stream, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">delegate void AudioSpecCallbackDelegate </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>userdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used in the SDL_AudioSpec struct. </p>

</div>
</div>
<a class="anchor" id="a9fc8cc284d2644ba059682359ad77f78"></a><!-- doxytag: member="Sdl.cs::for" ref="a9fc8cc284d2644ba059682359ad77f78" args="(i=0;i &amp;lt;256;i++)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_sdl_8cs.html#acb559820d9ca11295b4500f179ef6392">i</a>&nbsp;</td>
          <td class="paramname"> = <code>0;<a class="el" href="_sdl_8cs.html#acb559820d9ca11295b4500f179ef6392">i</a>&amp;<a class="el" href="_sdl_8cs.html#a857c8c8ca640fb2283d751a715bd1ee9">lt</a>;256;<a class="el" href="_sdl_8cs.html#acb559820d9ca11295b4500f179ef6392">i</a>++</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a17895976c498bf8a1352ea240f80c8dc"></a><!-- doxytag: member="Sdl.cs::if" ref="a17895976c498bf8a1352ea240f80c8dc" args="(!screen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">if </td>
          <td>(</td>
          <td class="paramtype">!&nbsp;</td>
          <td class="paramname"> <em>screen</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a68eb18902e9b6f413dbd6ea7afbea5a2"></a><!-- doxytag: member="Sdl.cs::if" ref="a68eb18902e9b6f413dbd6ea7afbea5a2" args="(surface==NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a>&nbsp;</td>
          <td class="paramname"> = <code>=&nbsp;NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acf16cb12f21e38e5544fbe0f6a0869d6"></a><!-- doxytag: member="Sdl.cs::printf" ref="acf16cb12f21e38e5544fbe0f6a0869d6" args="(&quot;Pixel Color &#45; R: %d,  G: %d,  B: %d,  A: %d\n&quot;, red, green, blue, alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">printf </td>
          <td>(</td>
          <td class="paramtype">&quot;Pixel Color - R: %&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">G:%&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B:%&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A:%d\n&quot;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sdl_8cs.html#a42c3a4a0281e61ee592e36a3eda020f2">red</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sdl_8cs.html#ad83fb941855ba7c4aa2bb65245437777">green</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sdl_8cs.html#aa6074166cc77c18081343a82d3af99bf">blue</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sdl_8cs.html#a62197192f0fbf4e0675eb37be1c4c175">alpha</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0847fd552fc17aa314f866ac16db60df"></a><!-- doxytag: member="Sdl.cs::SDL_AddTimer" ref="a0847fd552fc17aa314f866ac16db60df" args="(int interval, SDL_NewTimerCallback callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_s_d_l___timer_i_d.html">SDL_TimerID</a> SDL_AddTimer </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_NewTimerCallback&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a timer which will call a callback after the specified number of milliseconds has elapsed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>The callback to run. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interval</em>&nbsp;</td><td>The timer interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns an ID value for the added timer or NULL if there was an error. </dd></dl>
<p>Adds a callback function to be run after the specified number of milliseconds has elapsed. The callback function is passed the current timer interval and the user supplied parameter from the SDL_AddTimer call and returns the next timer interval. If the returned value from the callback is the same as the one passed in, the periodic alarm continues, otherwise a new alarm is scheduled. </p>
<p>To cancel a currently running timer call <a class="el" href="_sdl_8cs.html#a135aaf0e0425b1dcf1904b966509c3c0" title="Remove a timer which was added with SDL_AddTimer(int, SDL_NewTimerCallback).">SDL_RemoveTimer</a> with the timer ID returned from SDL_AddTimer. </p>
<p>The timer callback function may run in a different thread than your main program, and so shouldn't call any functions from within itself. You may always call SDL_PushEvent, however. </p>
<p>The granularity of the timer is platform-dependent, but you should count on it being at least 10 ms as this is the most common number. This means that if you request a 16 ms timer, your callback will run approximately 20 ms later on an unloaded system. If you wanted to set a flag signaling a frame update at 30 frames per second (every 33 ms), you might set a timer for 30 ms (see example below). If you use this function, you need to pass SDL_INIT_TIMER to SDL_Init(int). </p>
<p>Binds to C-function call in SDL_timer.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <a class="code" href="struct_s_d_l___timer_i_d.html">SDL_TimerID</a> SDLCALL 
                <a class="code" href="_sdl_8cs.html#a0847fd552fc17aa314f866ac16db60df" title="Add a timer which will call a callback after the specified number of milliseconds has elapsed...">SDL_AddTimer</a>(Uint32 interval, 
                <a class="code" href="_sdl_8cs.html#a643398553379a3feb14d264cbaf343d3" title="Prototype for the new timer callback.">SDL_NewTimerCallback</a> callback, <span class="keywordtype">void</span> *param)
</pre></div>  
</div>
</div>
<a class="anchor" id="a0084f0508a98488790b16db0ec6324f5"></a><!-- doxytag: member="Sdl.cs::SDL_AddTimer" ref="a0084f0508a98488790b16db0ec6324f5" args="(uint interval, SDL_NewTimerCallback callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_s_d_l___timer_i_d.html">SDL_TimerID</a> SDL_AddTimer </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_NewTimerCallback&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a timer which will call a callback after the specified number of milliseconds has elapsed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>The callback to run. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interval</em>&nbsp;</td><td>The timer interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns an ID value for the added timer or NULL if there was an error. </dd></dl>
<p>Adds a callback function to be run after the specified number of milliseconds has elapsed. The callback function is passed the current timer interval and the user supplied parameter from the SDL_AddTimer call and returns the next timer interval. If the returned value from the callback is the same as the one passed in, the periodic alarm continues, otherwise a new alarm is scheduled. </p>
<p>To cancel a currently running timer call <a class="el" href="_sdl_8cs.html#a135aaf0e0425b1dcf1904b966509c3c0" title="Remove a timer which was added with SDL_AddTimer(int, SDL_NewTimerCallback).">SDL_RemoveTimer</a> with the timer ID returned from SDL_AddTimer. </p>
<p>The timer callback function may run in a different thread than your main program, and so shouldn't call any functions from within itself. You may always call SDL_PushEvent, however. </p>
<p>The granularity of the timer is platform-dependent, but you should count on it being at least 10 ms as this is the most common number. This means that if you request a 16 ms timer, your callback will run approximately 20 ms later on an unloaded system. If you wanted to set a flag signaling a frame update at 30 frames per second (every 33 ms), you might set a timer for 30 ms (see example below). If you use this function, you need to pass SDL_INIT_TIMER to SDL_Init(int). </p>
<p>Binds to C-function call in SDL_timer.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <a class="code" href="struct_s_d_l___timer_i_d.html">SDL_TimerID</a> SDLCALL 
                <a class="code" href="_sdl_8cs.html#a0847fd552fc17aa314f866ac16db60df" title="Add a timer which will call a callback after the specified number of milliseconds has elapsed...">SDL_AddTimer</a>(Uint32 interval, 
                <a class="code" href="_sdl_8cs.html#a643398553379a3feb14d264cbaf343d3" title="Prototype for the new timer callback.">SDL_NewTimerCallback</a> callback, <span class="keywordtype">void</span> *param)
</pre></div>  
</div>
</div>
<a class="anchor" id="aa1fe24060926a8679b4a16201728a1e9"></a><!-- doxytag: member="Sdl.cs::SDL_AllocRW" ref="aa1fe24060926a8679b4a16201728a1e9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_AllocRW </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates an empty, unpopulated SDL_RWops structure. </p>
<p>SDL_AllocRW allocates an empty, unpopulated SDL_RWops structure. You must fill out the fields yourself. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><p class="startdd">Returns a pointer to the allocated memory on success, or NULL on error. </p>
<p class="enddd">You must free any memory allocated with <a class="el" href="_sdl_8cs.html#aa1fe24060926a8679b4a16201728a1e9" title="Allocates an empty, unpopulated SDL_RWops structure.">SDL_AllocRW</a> with <a class="el" href="_sdl_8cs.html#a13c12ec9d6bfe668b50e13cb71ebd8ee" title="Frees an SDL_RWops structure allocated by SDL_AllocRW.">SDL_FreeRW</a>. Depending on your operating system and compiler, there may be a difference between the malloc() and free() your program uses and the versions SDL calls internally. Trying to mix the two can cause crashing such as segmentation faults.</p>
</dd></dl>

</div>
</div>
<a class="anchor" id="a3200b95b4afc490010c5a1de969b98b0"></a><!-- doxytag: member="Sdl.cs::SDL_AllocSurface" ref="a3200b95b4afc490010c5a1de969b98b0" args="(int flags, int width, int height, int depth, int Rmask, int Gmask, int Bmask, int Amask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_AllocSurface </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Rmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Gmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Bmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Amask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Same as <a class="el" href="_sdl_8cs.html#aa732dd717414124c4710c0d25f8e07ce">SDL_CreateRGBSurface(int, int, int, int, int, int, int, int)</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Rmask</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Gmask</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Bmask</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Amask</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aa2016a25314cfe96b9e1bcc679753756"></a><!-- doxytag: member="Sdl.cs::SDL_AllocSurface" ref="aa2016a25314cfe96b9e1bcc679753756" args="(uint flags, int width, int height, int depth, uint Rmask, uint Gmask, uint Bmask, uint Amask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_AllocSurface </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>Rmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>Gmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>Bmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>Amask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Same as <a class="el" href="_sdl_8cs.html#aa732dd717414124c4710c0d25f8e07ce">SDL_CreateRGBSurface(int, int, int, int, int, int, int, int)</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Rmask</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Gmask</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Bmask</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Amask</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a647e403f5077884be644cc50c8374278"></a><!-- doxytag: member="Sdl.cs::SDL_AudioInit" ref="a647e403f5077884be644cc50c8374278" args="(string driver_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_AudioInit </td>
          <td>(</td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>driver_name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function is used internally, and should not be used unless you have a specific need to specify the audio driver you want to use. You should normally use SDL_Init(int) or SDL_InitSubSystem(int). </p>
<p>Binds to C-function call in SDL_audio.h: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#a647e403f5077884be644cc50c8374278" title="This function is used internally, and should not be used unless you have a specific need to specify t...">SDL_AudioInit</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *driver_name)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>driver_name</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a788bfa14eb012dad53e2e300d508db01"></a><!-- doxytag: member="Sdl.cs::SDL_AudioQuit" ref="a788bfa14eb012dad53e2e300d508db01" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_AudioQuit </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function is used internally, and should not be used unless you have a specific need to specify the audio driver you want to use. You should normally use SDL_Init() or SDL_InitSubSystem(). </p>
<p>Binds to C-function call in SDL_audio.h: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="_sdl_8cs.html#a788bfa14eb012dad53e2e300d508db01" title="This function is used internally, and should not be used unless you have a specific need to specify t...">SDL_AudioQuit</a>()
</pre></div> 
</div>
</div>
<a class="anchor" id="aec41f77b04d717457433acbecd7a257b"></a><!-- doxytag: member="Sdl.cs::SDL_BlitSurface" ref="aec41f77b04d717457433acbecd7a257b" args="(IntPtr src, ref SDL_Rect srcrect, IntPtr dst, ref SDL_Rect dstrect)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_BlitSurface </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref <a class="el" href="struct_s_d_l___rect.html">SDL_Rect</a>&nbsp;</td>
          <td class="paramname"> <em>srcrect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref <a class="el" href="struct_s_d_l___rect.html">SDL_Rect</a>&nbsp;</td>
          <td class="paramname"> <em>dstrect</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This performs a fast blit from the source surface to the destination surface. </p>
<p>This performs a fast blit from the source surface to the destination surface. </p>
<p>The width and height in srcrect determine the size of the copied rectangle. Only the position is used in the dstrect (the width and height are ignored). </p>
<p>If srcrect is NULL, the entire surface is copied. If dstrect is NULL, then the destination position (upper left corner) is (0, 0). </p>
<p>The final blit rectangle is saved in dstrect after all clipping is performed (srcrect is not modified). </p>
<p>The blit function should not be called on a locked surface. </p>
<p>The results of blitting operations vary greatly depending on whether SDL_SRCAPLHA is set or not. See SDL_SetAlpha for an explaination of how this affects your results. Colorkeying and alpha attributes also interact with surface blitting, as the following pseudo-code should hopefully explain.  </p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> (source <a class="code" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1" title="Create an empty SDL_Surface.">surface</a> has SDL_SRCALPHA <span class="keyword">set</span>) 
                {
                        <span class="keywordflow">if</span> (source <a class="code" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1" title="Create an empty SDL_Surface.">surface</a> has <a class="code" href="_sdl_8cs.html#a62197192f0fbf4e0675eb37be1c4c175">alpha</a> channel (that is, format-&gt;Amask != 0))
                        blit <span class="keyword">using</span> per-<a class="code" href="_sdl_8cs.html#a36392890a1aba4cacbe1cad263a699f0">pixel</a> <a class="code" href="_sdl_8cs.html#a62197192f0fbf4e0675eb37be1c4c175">alpha</a>, ignoring any colour key
                        <span class="keywordflow">else</span> {
                        <span class="keywordflow">if</span> (source <a class="code" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1" title="Create an empty SDL_Surface.">surface</a> has SDL_SRCCOLORKEY <span class="keyword">set</span>)
                                blit <span class="keyword">using</span> the colour key AND the per-<a class="code" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1" title="Create an empty SDL_Surface.">surface</a> alpha value
                        <span class="keywordflow">else</span>
                                blit <span class="keyword">using</span> the per-<a class="code" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1" title="Create an empty SDL_Surface.">surface</a> alpha value
                        }
           } 
           <span class="keywordflow">else</span> 
           {
           <span class="keywordflow">if</span> (source <a class="code" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1" title="Create an empty SDL_Surface.">surface</a> has SDL_SRCCOLORKEY <span class="keyword">set</span>)
           blit <span class="keyword">using</span> the colour key
           <span class="keywordflow">else</span>
           ordinary opaque rectangular blit
           }
</pre></div><p> p&gt;Binds to C-function call in SDL_video.h: code&gt;int SDL_BlitSurface(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst, SDL_Rect *dstrect); /code&gt;</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>IntPtr to <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcrect</em>&nbsp;</td><td>IntPtr to <a class="el" href="struct_s_d_l___rect.html" title="Defines a rectangular area.">SDL_Rect</a></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>IntPtr to <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dstrect</em>&nbsp;</td><td>IntPtr to <a class="el" href="struct_s_d_l___rect.html" title="Defines a rectangular area.">SDL_Rect</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><p class="startdd">If the blit is successful, it returns 0, otherwise it returns -1. </p>
<p>If either of the surfaces were in video memory, and the blit returns -2, the video memory was lost, so it should be reloaded with artwork and re-blitted: </p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">while</span> ( <a class="code" href="_sdl_8cs.html#aec41f77b04d717457433acbecd7a257b" title="This performs a fast blit from the source surface to the destination surface.">SDL_BlitSurface</a>(image, imgrect, <a class="code" href="_sdl_8cs.html#a968bba55c7ad32b326939fefd1bbb017" title="Sets a portion of the colormap for the given 8-bit surface.">screen</a>, dstrect) == -2 ) 
                {
                        <span class="keywordflow">while</span> ( <a class="code" href="_sdl_8cs.html#ad1c3562c62aaf55f95641f0bafab9e8f" title="Lock a surface for directly access.">SDL_LockSurface</a>(image)) &amp;<a class="code" href="_sdl_8cs.html#a857c8c8ca640fb2283d751a715bd1ee9">lt</a>; 0 )
                        <a class="code" href="_sdl_8cs.html#a71ab491dce88b1d92c008dca21b47c13" title="Wait a specified number of milliseconds before returning.">SDL_Delay</a>(10);
                        -- Write image pixels to image-&amp;<a class="code" href="_sdl_8cs.html#aed7a7f1f82df5fd3dd11622b2e8a0351">gt</a>;pixels --
                        <a class="code" href="_sdl_8cs.html#a575d113e5463394a260668c1eb9a7390">SDL_UnlockSurface</a>(image);
                }
</pre></div> <p class="enddd">This happens under DirectX 5.0 when the system switches away from your fullscreen application. Locking the surface will also fail until you have access to the video memory again. </p>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#afae9570bf3fb2b26f7403cb1fc4f1353">SDL_LockSurface</a>, <a class="el" href="_sdl_8cs.html#ac5e42937782d41622cec743f145b4f81" title="This function performs a fast fill of the given rectangle with some color.">SDL_FillRect(IntPtr, ref SDL_Rect, int)</a>, <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a>, <a class="el" href="struct_s_d_l___rect.html" title="Defines a rectangular area.">SDL_Rect</a></dd></dl>

</div>
</div>
<a class="anchor" id="ab290a18bf5bf8a161042ceb8c43c5654"></a><!-- doxytag: member="Sdl.cs::SDL_BuildAudioCVT" ref="ab290a18bf5bf8a161042ceb8c43c5654" args="(IntPtr cvt, short src_format, byte src_channels, int src_rate, short dst_format, byte dst_channels, int dst_rate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_BuildAudioCVT </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>cvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>src_format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&nbsp;</td>
          <td class="paramname"> <em>src_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>src_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>dst_format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&nbsp;</td>
          <td class="paramname"> <em>dst_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dst_rate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes a SDL_AudioCVT structure for conversion. </p>
<p>Before an SDL_AudioCVT structure can be used to convert audio data it must be initialized with source and destination information. </p>
<p>src_format and dst_format are the source and destination format of the conversion. (For information on audio formats see SDL_AudioSpec). src_channels and dst_channels are the number of channels in the source and destination formats. Finally, src_rate and dst_rate are the frequency or samples-per-second of the source and destination formats. Once again, see SDL_AudioSpec. </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#ab290a18bf5bf8a161042ceb8c43c5654" title="Initializes a SDL_AudioCVT structure for conversion.">SDL_BuildAudioCVT</a>(SDL_AudioCVT *cvt, Uint16 src_format, Uint8 src_channels, <span class="keywordtype">int</span> src_rate, Uint16 dst_format, Uint8 dst_channels, <span class="keywordtype">int</span> dst_rate)
</pre></div><p>See <a class="el" href="_sdl_8cs.html#a7ed641a1e339dc97cfd58c08dd9af2e2" title="Convert audio data to a desired audio format.">SDL_ConvertAudio</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cvt</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_format</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_channels</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_rate</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst_format</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst_channels</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst_rate</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns -1 if the filter could not be built or 1 if it could. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a7ed641a1e339dc97cfd58c08dd9af2e2" title="Convert audio data to a desired audio format.">SDL_ConvertAudio</a>, SDL_AudioCVT</dd></dl>

</div>
</div>
<a class="anchor" id="a739fd042edf0170fb6f4ec390763ff3c"></a><!-- doxytag: member="Sdl.cs::SDL_BuildAudioCVT" ref="a739fd042edf0170fb6f4ec390763ff3c" args="(IntPtr cvt, ushort src_format, byte src_channels, int src_rate, ushort dst_format, byte dst_channels, int dst_rate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_BuildAudioCVT </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>cvt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort&nbsp;</td>
          <td class="paramname"> <em>src_format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&nbsp;</td>
          <td class="paramname"> <em>src_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>src_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort&nbsp;</td>
          <td class="paramname"> <em>dst_format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&nbsp;</td>
          <td class="paramname"> <em>dst_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dst_rate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes a SDL_AudioCVT structure for conversion. </p>
<p>Before an SDL_AudioCVT structure can be used to convert audio data it must be initialized with source and destination information. </p>
<p>src_format and dst_format are the source and destination format of the conversion. (For information on audio formats see SDL_AudioSpec). src_channels and dst_channels are the number of channels in the source and destination formats. Finally, src_rate and dst_rate are the frequency or samples-per-second of the source and destination formats. Once again, see SDL_AudioSpec. </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#ab290a18bf5bf8a161042ceb8c43c5654" title="Initializes a SDL_AudioCVT structure for conversion.">SDL_BuildAudioCVT</a>(SDL_AudioCVT *cvt, Uint16 src_format, Uint8 src_channels, <span class="keywordtype">int</span> src_rate, Uint16 dst_format, Uint8 dst_channels, <span class="keywordtype">int</span> dst_rate)
</pre></div><p>See <a class="el" href="_sdl_8cs.html#a7ed641a1e339dc97cfd58c08dd9af2e2" title="Convert audio data to a desired audio format.">SDL_ConvertAudio</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cvt</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_format</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_channels</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_rate</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst_format</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst_channels</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst_rate</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns -1 if the filter could not be built or 1 if it could. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a7ed641a1e339dc97cfd58c08dd9af2e2" title="Convert audio data to a desired audio format.">SDL_ConvertAudio</a>, SDL_AudioCVT</dd></dl>

</div>
</div>
<a class="anchor" id="a4414db092d107b121633e8b3863e5744"></a><!-- doxytag: member="Sdl.cs::SDL_CDClose" ref="a4414db092d107b121633e8b3863e5744" args="(IntPtr cdrom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_CDClose </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>cdrom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes a SDL_CD handle. </p>
<p>Closes the given cdrom handle. </p>
<p>Binds to C-function in SDL_cdrom.h </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="_sdl_8cs.html#a4414db092d107b121633e8b3863e5744" title="Closes a SDL_CD handle.">SDL_CDClose</a>(SDL_CD *cdrom);
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cdrom</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>SDL_CDOpen, SDL_CD</dd></dl>

</div>
</div>
<a class="anchor" id="aca5ade1a8680f4cf001bee830373b14f"></a><!-- doxytag: member="Sdl.cs::SDL_CDEject" ref="aca5ade1a8680f4cf001bee830373b14f" args="(IntPtr cdrom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_CDEject </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>cdrom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ejects a CDROM. </p>
<p>Ejects the given cdrom. </p>
<p>Binds to C-function in SDL_cdrom.h </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#aca5ade1a8680f4cf001bee830373b14f" title="Ejects a CDROM.">SDL_CDEject</a>(SDL_CD *cdrom)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cdrom</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0, or -1 on error.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>SDL_CD</dd></dl>

</div>
</div>
<a class="anchor" id="a66f1e7b4fe4df8529b3afd7c3600d7bc"></a><!-- doxytag: member="Sdl.cs::SDL_CDName" ref="a66f1e7b4fe4df8529b3afd7c3600d7bc" args="(int drive)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static string SDL_CDName </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>drive</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a human-readable, system-dependent identifier for the CD-ROM. </p>
<p>Drive is the index of the drive. Drive indices start to 0 and end at <a class="el" href="_sdl_8cs.html#a4610e2722bd3b4c4951ab3c18f4f9a6f" title="Returns the number of CD-ROM drives on the system.">SDL_CDNumDrives()</a>-1. </p>
<p>Binds to C-function in SDL_cdrom.h </p>
<div class="fragment"><pre class="fragment"><span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="_sdl_8cs.html#a66f1e7b4fe4df8529b3afd7c3600d7bc" title="Returns a human-readable, system-dependent identifier for the CD-ROM.">SDL_CDName</a>(<span class="keywordtype">int</span> drive);
</pre></div><p>Example: "/dev/cdrom" "E:" "/dev/disk/ide/1/master" </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>drive</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a human-readable, system-dependent identifier for the CD-ROM. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a4610e2722bd3b4c4951ab3c18f4f9a6f" title="Returns the number of CD-ROM drives on the system.">SDL_CDNumDrives</a></dd></dl>

</div>
</div>
<a class="anchor" id="a4610e2722bd3b4c4951ab3c18f4f9a6f"></a><!-- doxytag: member="Sdl.cs::SDL_CDNumDrives" ref="a4610e2722bd3b4c4951ab3c18f4f9a6f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_CDNumDrives </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of CD-ROM drives on the system. </p>
<p>Returns the number of CD-ROM drives on the system, or -1 if SDL_Init() has not been called with the SDL_INIT_CDROM flag. </p>
<p>Binds to C-function call in SDL_cdrom.h: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#a4610e2722bd3b4c4951ab3c18f4f9a6f" title="Returns the number of CD-ROM drives on the system.">SDL_CDNumDrives</a>(<span class="keywordtype">void</span>)
</pre></div><dl class="return"><dt><b>Returns:</b></dt><dd>Returns the number of CD-ROM drives on the system, or -1 if SDL_Init() has not been called with the SDL_INIT_CDROM flag. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>SDL_CDOpen</dd></dl>

</div>
</div>
<a class="anchor" id="adbd88a5c674464c86f076180aef2fec6"></a><!-- doxytag: member="Sdl.cs::SDL_CDPause" ref="adbd88a5c674464c86f076180aef2fec6" args="(IntPtr cdrom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_CDPause </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>cdrom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pauses a CDROM. </p>
<p>Pauses play on the given cdrom. </p>
<p>Binds to C-function in SDL_cdrom.h </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#adbd88a5c674464c86f076180aef2fec6" title="Pauses a CDROM.">SDL_CDPause</a>(SDL_CD *cdrom)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cdrom</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0, or -1 on error.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a8ce19531378969ac823e35d181c1079d" title="Opens a CD-ROM drive for access.">SDL_CDPlay</a>, <a class="el" href="_sdl_8cs.html#a12336ccd2439a851f6c616ab5f7bf148" title="Resumes a CDROM.">SDL_CDResume</a></dd></dl>

</div>
</div>
<a class="anchor" id="a8ce19531378969ac823e35d181c1079d"></a><!-- doxytag: member="Sdl.cs::SDL_CDPlay" ref="a8ce19531378969ac823e35d181c1079d" args="(IntPtr cdrom, int start, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_CDPlay </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>cdrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opens a CD-ROM drive for access. </p>
<p>Opens a CD-ROM drive for access. It returns a SDL_CD structure on success, or NULL if the drive was invalid or busy. This newly opened CD-ROM becomes the default CD used when other CD functions are passed a NULL CD-ROM handle. </p>
<p>Drives are numbered starting with 0. Drive 0 is the system default CD-ROM. </p>
<p>Binds to C-function in SDL_cdrom.h </p>
<div class="fragment"><pre class="fragment">SDL_CD *SDL_CDOpen(<span class="keywordtype">int</span> drive)
</pre></div><div class="fragment"><pre class="fragment">            SDL_CD *cdrom;
                        <span class="keywordtype">int</span> cur_track;
                        <span class="keywordtype">int</span> min, sec, frame;
                        SDL_Init(SDL_INIT_CDROM);
                        atexit(<a class="code" href="_sdl_8cs.html#a3acfba2794297d8a0a6d5b047dbaa53c" title="Shuts down SDL.">SDL_Quit</a>);

                        <span class="comment">/* Check for CD drives */</span>
                        <span class="keywordflow">if</span>(!<a class="code" href="_sdl_8cs.html#a4610e2722bd3b4c4951ab3c18f4f9a6f" title="Returns the number of CD-ROM drives on the system.">SDL_CDNumDrives</a>())
                                {
                        <span class="comment">/* None found */</span>
                        fprintf(stderr, <span class="stringliteral">&quot;No CDROM devices available\n&quot;</span>);
                        exit(-1);
                }

                <span class="comment">/* Open the default drive */</span>
                cdrom=SDL_CDOpen(0);

                <span class="comment">/* Did if open? Check if cdrom is NULL */</span>
                <span class="keywordflow">if</span>(!cdrom)
           {
                fprintf(stderr, <span class="stringliteral">&quot;Couldn&#39;t open drive: %s\n&quot;</span>, SDL_GetError());
                exit(-1);
           }

                <span class="comment">/* Print Volume info */</span>
                <a class="code" href="_sdl_8cs.html#acf16cb12f21e38e5544fbe0f6a0869d6">printf</a>(<span class="stringliteral">&quot;Name: %s\n&quot;</span>, <a class="code" href="_sdl_8cs.html#a66f1e7b4fe4df8529b3afd7c3600d7bc" title="Returns a human-readable, system-dependent identifier for the CD-ROM.">SDL_CDName</a>(0));
                <a class="code" href="_sdl_8cs.html#acf16cb12f21e38e5544fbe0f6a0869d6">printf</a>(<span class="stringliteral">&quot;Tracks: %d\n&quot;</span>, cdrom-&gt;numtracks);
                <span class="keywordflow">for</span>(cur_track=0;cur_track &amp;<a class="code" href="_sdl_8cs.html#a857c8c8ca640fb2283d751a715bd1ee9">lt</a>; cdrom-&amp;<a class="code" href="_sdl_8cs.html#aed7a7f1f82df5fd3dd11622b2e8a0351">gt</a>;numtracks; cur_track++)
           {
                FRAMES_TO_MSF(cdrom-&gt;track[cur_track].length, &amp;amp;min, &amp;amp;sec, &amp;amp;frame);
                <a class="code" href="_sdl_8cs.html#acf16cb12f21e38e5544fbe0f6a0869d6">printf</a>(<span class="stringliteral">&quot;\tTrack %d: Length %d:%d\n&quot;</span>, cur_track, min, sec);
           }

           <a class="code" href="_sdl_8cs.html#a4414db092d107b121633e8b3863e5744" title="Closes a SDL_CD handle.">SDL_CDClose</a>(cdrom);
            /code&gt;
            &lt;/example&gt;
            &lt;param name=<span class="stringliteral">&quot;drive&quot;</span>&gt;&lt;/param&gt;
            &lt;returns&gt;It returns a SDL_CD structure
             on success, or NULL <span class="keywordflow">if</span> the drive was invalid or busy.
             &lt;/returns&gt;
             &lt;seealso cref=<span class="stringliteral">&quot;SDL_CD&quot;</span>/&gt;
             &lt;seealso cref=<span class="stringliteral">&quot;SDL_CDtrack&quot;</span>/&gt;
             &lt;seealso cref=<span class="stringliteral">&quot;SDL_CDClose&quot;</span>/&gt; */
        [DllImport(SDL_NATIVE_LIBRARY, CallingConvention = CALLING_CONVENTION),
        SuppressUnmanagedCodeSecurity]
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> IntPtr SDL_CDOpen(<span class="keywordtype">int</span> drive);

</pre></div><div class="fragment"><pre class="fragment">            <span class="keywordtype">int</span> playTrack(<span class="keywordtype">int</span> track)
                {
                        <span class="keywordtype">int</span> playing = 0;

                        <span class="keywordflow">if</span> ( CD_INDRIVE(SDL_CDStatus(cdrom)) ) 
                {
                        <span class="comment">/* clamp to the actual number of tracks on the CD */</span>
                        <span class="keywordflow">if</span> (track &gt;= cdrom-&gt;numtracks) 
                {
                        track = cdrom-&gt;numtracks-1;
                }

                <span class="keywordflow">if</span> ( <a class="code" href="_sdl_8cs.html#aee7740538b0cf769097abc2b21b4945e" title="Play the given CD track(s).">SDL_CDPlayTracks</a>(cdrom, track, 0, 1, 0) == 0 ) 
           {
                playing = 1;
           }
           }
           <span class="keywordflow">return</span> playing;
           }
            /code&gt;
            &lt;/example&gt;
            &lt;param name=<span class="stringliteral">&quot;cdrom&quot;</span>&gt;&lt;/param&gt;
            &lt;returns&gt;CDstatus <span class="keyword">enum</span>&lt;/returns&gt;
            &lt;seealso cref=<span class="stringliteral">&quot;SDL_CD&quot;</span>/&gt; */
        [DllImport(SDL_NATIVE_LIBRARY, CallingConvention = CALLING_CONVENTION),
        SuppressUnmanagedCodeSecurity]
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keywordtype">int</span> SDL_CDStatus(IntPtr cdrom);

</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cdrom</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>It returns 0, or -1 if there was an error.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aee7740538b0cf769097abc2b21b4945e" title="Play the given CD track(s).">SDL_CDPlayTracks</a>, <a class="el" href="_sdl_8cs.html#a26572955a5bba8a2c73b4458554c900d" title="Stops a CDROM.">SDL_CDStop</a></dd></dl>

</div>
</div>
<a class="anchor" id="aee7740538b0cf769097abc2b21b4945e"></a><!-- doxytag: member="Sdl.cs::SDL_CDPlayTracks" ref="aee7740538b0cf769097abc2b21b4945e" args="(IntPtr cdrom, int start_track, int start_frame, int ntracks, int nframes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_CDPlayTracks </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>cdrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>start_track</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>start_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ntracks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nframes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Play the given CD track(s). </p>
<p>SDL_CDPlayTracks plays the given CD starting at track start_track, for ntracks tracks. </p>
<p>start_frame is the frame offset, from the beginning of the start_track, at which to start. nframes is the frame offset, from the beginning of the last track (start_track+ntracks), at which to end playing. </p>
<p>SDL_CDPlayTracks should only be called after calling SDL_CDStatus to get track information about the CD. </p>
<p>Note: Data tracks are ignored. </p>
<p>Binds to C-function in SDL_cdrom.h </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#aee7740538b0cf769097abc2b21b4945e" title="Play the given CD track(s).">SDL_CDPlayTracks</a>(SDL_CD *cdrom, <span class="keywordtype">int</span> start_track, <span class="keywordtype">int</span> start_frame, <span class="keywordtype">int</span> ntracks, <span class="keywordtype">int</span> nframes))
</pre></div><div class="fragment"><pre class="fragment">                        <span class="comment">/* assuming cdrom is a previously opened device */</span>
                        <span class="comment">/* Play the entire CD */</span>
                        <span class="keywordflow">if</span>(CD_INDRIVE(SDL_CDStatus(cdrom)))
                        <a class="code" href="_sdl_8cs.html#aee7740538b0cf769097abc2b21b4945e" title="Play the given CD track(s).">SDL_CDPlayTracks</a>(cdrom, 0, 0, 0, 0);

                        <span class="comment">/* Play the first track */</span>
                        <span class="keywordflow">if</span>(CD_INDRIVE(SDL_CDStatus(cdrom)))
                        <a class="code" href="_sdl_8cs.html#aee7740538b0cf769097abc2b21b4945e" title="Play the given CD track(s).">SDL_CDPlayTracks</a>(cdrom, 0, 0, 1, 0);

                        <span class="comment">/* Play first 15 seconds of the 2nd track */</span>
                        <span class="keywordflow">if</span>(CD_INDRIVE(SDL_CDStatus(cdrom)))
                        <a class="code" href="_sdl_8cs.html#aee7740538b0cf769097abc2b21b4945e" title="Play the given CD track(s).">SDL_CDPlayTracks</a>(cdrom, 1, 0, 0, CD_FPS*15);
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cdrom</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_track</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_frame</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ntracks</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nframes</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0, or -1 if there was an error.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a8ce19531378969ac823e35d181c1079d" title="Opens a CD-ROM drive for access.">SDL_CDPlay</a>, SDL_CDStatus, SDL_CD</dd></dl>

</div>
</div>
<a class="anchor" id="a12336ccd2439a851f6c616ab5f7bf148"></a><!-- doxytag: member="Sdl.cs::SDL_CDResume" ref="a12336ccd2439a851f6c616ab5f7bf148" args="(IntPtr cdrom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_CDResume </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>cdrom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resumes a CDROM. </p>
<p>Resumes play on the given cdrom. </p>
<p>Binds to C-function in SDL_cdrom.h </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#a12336ccd2439a851f6c616ab5f7bf148" title="Resumes a CDROM.">SDL_CDResume</a>(SDL_CD *cdrom)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cdrom</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a8ce19531378969ac823e35d181c1079d" title="Opens a CD-ROM drive for access.">SDL_CDPlay</a>, <a class="el" href="_sdl_8cs.html#adbd88a5c674464c86f076180aef2fec6" title="Pauses a CDROM.">SDL_CDPause</a></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0, or -1 on error.</dd></dl>

</div>
</div>
<a class="anchor" id="a26572955a5bba8a2c73b4458554c900d"></a><!-- doxytag: member="Sdl.cs::SDL_CDStop" ref="a26572955a5bba8a2c73b4458554c900d" args="(IntPtr cdrom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_CDStop </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>cdrom</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stops a CDROM. </p>
<p>Stops play on the given cdrom. </p>
<p>Binds to C-function in SDL_cdrom.h </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#a26572955a5bba8a2c73b4458554c900d" title="Stops a CDROM.">SDL_CDStop</a>(SDL_CD *cdrom)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cdrom</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0, or -1 on error.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a8ce19531378969ac823e35d181c1079d" title="Opens a CD-ROM drive for access.">SDL_CDPlay</a></dd></dl>

</div>
</div>
<a class="anchor" id="a2e98ede54e638a0e99ccf66af20882a8"></a><!-- doxytag: member="Sdl.cs::SDL_ClearError" ref="a2e98ede54e638a0e99ccf66af20882a8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_ClearError </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clears the SDL error. </p>
<p>Binds to C-function call in SDL_error.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">void</span> SDLCALL <a class="code" href="_sdl_8cs.html#a2e98ede54e638a0e99ccf66af20882a8" title="Clears the SDL error.">SDL_ClearError</a>(<span class="keywordtype">void</span>)
</pre></div>  
</div>
</div>
<a class="anchor" id="a5382731aad3887b1285712f976de3843"></a><!-- doxytag: member="Sdl.cs::SDL_CloseAudio" ref="a5382731aad3887b1285712f976de3843" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_CloseAudio </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shuts down audio processing and closes the audio device. </p>
<p>This function shuts down audio processing and closes the audio device. </p>
<p>Binds to C-function call in SDL_audio.h: </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">void</span> <a class="code" href="_sdl_8cs.html#a5382731aad3887b1285712f976de3843" title="Shuts down audio processing and closes the audio device.">SDL_CloseAudio</a>(<span class="keywordtype">void</span>)
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#ad374c9d61753113b30c8c4b96295ff3b" title="Opens the audio device with the desired parameters.">SDL_OpenAudio</a></dd></dl>

</div>
</div>
<a class="anchor" id="ac70948782dbee69b01b3e386e20081f1"></a><!-- doxytag: member="Sdl.cs::SDL_CondBroadcast" ref="ac70948782dbee69b01b3e386e20081f1" args="(IntPtr cond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_CondBroadcast </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>cond</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Restart all threads that are waiting on the condition variable, returns 0 or -1 on error. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Restart all threads that are waiting on the condition variable, returns 0 or -1 on error. </dd></dl>
<p>Binds to C-function call in SDL_mutex.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#ac70948782dbee69b01b3e386e20081f1" title="Restart all threads that are waiting on the condition variable, returns 0 or -1 on error...">SDL_CondBroadcast</a>(SDL_cond *cond)
</pre></div>  
</div>
</div>
<a class="anchor" id="a88bd2bdcf0833d744ec48eb5a20b553e"></a><!-- doxytag: member="Sdl.cs::SDL_CondSignal" ref="a88bd2bdcf0833d744ec48eb5a20b553e" args="(IntPtr cond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_CondSignal </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>cond</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Restart one of the threads that are waiting on the condition variable, returns 0 or -1 on error. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Restart one of the threads that are waiting on the condition variable, returns 0 or -1 on error. </dd></dl>
<p>Binds to C-function call in SDL_mutex.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#a88bd2bdcf0833d744ec48eb5a20b553e" title="Restart one of the threads that are waiting on the condition variable, returns 0 or -1 on error...">SDL_CondSignal</a>(SDL_cond *cond)
</pre></div>  
</div>
</div>
<a class="anchor" id="ab19e817dc5ae396cca2d5d1646e5f496"></a><!-- doxytag: member="Sdl.cs::SDL_CondWait" ref="ab19e817dc5ae396cca2d5d1646e5f496" args="(IntPtr cond, IntPtr mut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_CondWait </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>mut</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait on the condition variable, unlocking the provided mutex. The mutex must be locked before entering this function! Returns 0 when it is signaled, or -1 on error. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Wait on the condition variable, unlocking the provided mutex. The mutex must be locked before entering this function! Returns 0 when it is signaled, or -1 on error. </dd></dl>
<p>Binds to C-function call in SDL_mutex.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#ab19e817dc5ae396cca2d5d1646e5f496" title="Wait on the condition variable, unlocking the provided mutex. The mutex must be locked before enterin...">SDL_CondWait</a>(SDL_cond *cond, SDL_mutex *mut)
</pre></div>  
</div>
</div>
<a class="anchor" id="ad8bd3796951f0de8777c732b629e974b"></a><!-- doxytag: member="Sdl.cs::SDL_CondWaitTimeout" ref="ad8bd3796951f0de8777c732b629e974b" args="(IntPtr cond, IntPtr mutex, int ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_CondWaitTimeout </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Waits for at most 'ms' milliseconds, and returns 0 if the condition variable is signaled, SDL_MUTEX_TIMEDOUT if the condition is not signaled in the allotted time, and -1 on error. On some platforms this function is implemented by looping with a delay of 1 ms, and so should be avoided if possible. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>returns 0 if the condition variable is signaled, SDL_MUTEX_TIMEDOUT if the condition is not signaled in the allotted time, and -1 on error </dd></dl>
<p>Binds to C-function call in SDL_mutex.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#ad8bd3796951f0de8777c732b629e974b" title="Waits for at most &amp;#39;ms&amp;#39; milliseconds, and returns 0 if the condition variable is signaled...">SDL_CondWaitTimeout</a>(SDL_cond *cond, SDL_mutex *mutex, Uint32 ms)
</pre></div>  
</div>
</div>
<a class="anchor" id="a3ec22d858b5df88c8a6c83d4cbe71bae"></a><!-- doxytag: member="Sdl.cs::SDL_CondWaitTimeout" ref="a3ec22d858b5df88c8a6c83d4cbe71bae" args="(IntPtr cond, IntPtr mutex, uint ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_CondWaitTimeout </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Waits for at most 'ms' milliseconds, and returns 0 if the condition variable is signaled, SDL_MUTEX_TIMEDOUT if the condition is not signaled in the allotted time, and -1 on error. On some platforms this function is implemented by looping with a delay of 1 ms, and so should be avoided if possible. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>returns 0 if the condition variable is signaled, SDL_MUTEX_TIMEDOUT if the condition is not signaled in the allotted time, and -1 on error </dd></dl>
<p>Binds to C-function call in SDL_mutex.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#ad8bd3796951f0de8777c732b629e974b" title="Waits for at most &amp;#39;ms&amp;#39; milliseconds, and returns 0 if the condition variable is signaled...">SDL_CondWaitTimeout</a>(SDL_cond *cond, SDL_mutex *mutex, Uint32 ms)
</pre></div>  
</div>
</div>
<a class="anchor" id="a7ed641a1e339dc97cfd58c08dd9af2e2"></a><!-- doxytag: member="Sdl.cs::SDL_ConvertAudio" ref="a7ed641a1e339dc97cfd58c08dd9af2e2" args="(IntPtr cvt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_ConvertAudio </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>cvt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert audio data to a desired audio format. </p>
<p>SDL_ConvertAudio takes one parameter, cvt, which was previously initialized. Initilizing a SDL_AudioCVT is a two step process. First of all, the structure must be passed to <a class="el" href="_sdl_8cs.html#ab290a18bf5bf8a161042ceb8c43c5654" title="Initializes a SDL_AudioCVT structure for conversion.">SDL_BuildAudioCVT(IntPtr, short, byte, int, short, byte, int)</a> along with source and destination format parameters. Secondly, the cvt-&gt;buf and cvt-&gt;len fields must be setup. cvt-&gt;buf should point to the audio data and cvt-&gt;len should be set to the length of the audio data in bytes. Remember, the length of the buffer pointed to by buf show be len*len_mult bytes in length. </p>
<p>Once the SDL_AudioCVTstructure is initilized then we can pass it to SDL_ConvertAudio, which will convert the audio data pointer to by cvt-&gt;buf. If SDL_ConvertAudio returned 0 then the conversion was completed successfully, otherwise -1 is returned. </p>
<p>If the conversion completed successfully then the converted audio data can be read from cvt-&gt;buf. The amount of valid, converted, audio data in the buffer is equal to cvt-&gt;len*cvt-&gt;len_ratio. </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#a7ed641a1e339dc97cfd58c08dd9af2e2" title="Convert audio data to a desired audio format.">SDL_ConvertAudio</a>(SDL_AudioCVT *cvt)
</pre></div><div class="fragment"><pre class="fragment">            <span class="comment">/* Converting some WAV data to hardware format */</span>
                        <span class="keywordtype">void</span> my_audio_callback(<span class="keywordtype">void</span> *userdata, Uint8 *stream, <span class="keywordtype">int</span> len);

                        SDL_AudioSpec *desired, *obtained;
                        SDL_AudioSpec wav_spec;
                        SDL_AudioCVT  wav_cvt;
                        Uint32 wav_len;
                        Uint8 *wav_buf;
                        <span class="keywordtype">int</span> ret;

                        <span class="comment">/* Allocated audio specs */</span>
                        desired = malloc(<span class="keyword">sizeof</span>(SDL_AudioSpec));
                        obtained = malloc(<span class="keyword">sizeof</span>(SDL_AudioSpec));

                        <span class="comment">/* Set desired format */</span>
                        desired-&amp;gt;freq=22050;
                        desired-&amp;gt;format=AUDIO_S16LSB;
                        desired-&amp;gt;samples=8192;
                        desired-&amp;gt;callback=my_audio_callback;
                        desired-&amp;gt;userdata=NULL;

                        <span class="comment">/* Open the audio device */</span>
                        <span class="keywordflow">if</span> ( <a class="code" href="_sdl_8cs.html#ad374c9d61753113b30c8c4b96295ff3b" title="Opens the audio device with the desired parameters.">SDL_OpenAudio</a>(desired, obtained) &amp;lt; 0 )
                {
                        fprintf(stderr, <span class="stringliteral">&quot;Couldn&#39;t open audio: %s\n&quot;</span>, SDL_GetError());
                        exit(-1);
                }

                free(desired);

                <span class="comment">/* Load the test.wav */</span>
                <span class="keywordflow">if</span>( SDL_LoadWAV(<span class="stringliteral">&quot;test.wav&quot;</span>, &amp;amp;wav_spec, &amp;amp;wav_buf, &amp;amp;wav_len) == NULL )
           {
                fprintf(stderr, <span class="stringliteral">&quot;Could not open test.wav: %s\n&quot;</span>, SDL_GetError());
                <a class="code" href="_sdl_8cs.html#a5382731aad3887b1285712f976de3843" title="Shuts down audio processing and closes the audio device.">SDL_CloseAudio</a>();
                free(obtained);
                exit(-1);

                <span class="comment">/* Build AudioCVT */</span>
                ret = <a class="code" href="_sdl_8cs.html#ab290a18bf5bf8a161042ceb8c43c5654" title="Initializes a SDL_AudioCVT structure for conversion.">SDL_BuildAudioCVT</a>(&amp;amp;wav_cvt,
                wav_spec.format, wav_spec.channels, wav_spec.freq,
                obtained-&amp;gt;format, obtained-&amp;gt;channels, obtained-&amp;gt;freq);

                <span class="comment">/* Check that the convert was built */</span>
                <span class="keywordflow">if</span>(ret==-1)
           {
                fprintf(stderr, <span class="stringliteral">&quot;Couldn&#39;t build converter!\n&quot;</span>);
                <a class="code" href="_sdl_8cs.html#a5382731aad3887b1285712f976de3843" title="Shuts down audio processing and closes the audio device.">SDL_CloseAudio</a>();
                free(obtained);
                <a class="code" href="_sdl_8cs.html#aa59c06f2223e64f2b5f74b82625dd43f" title="Frees previously opened WAV data.">SDL_FreeWAV</a>(wav_buf);
           }

                <span class="comment">/* Setup for conversion */</span>
                wav_cvt.buf = malloc(wav_len * wav_cvt.len_mult);
                wav_cvt.len = wav_len;
                memcpy(wav_cvt.buf, wav_buf, wav_len);

                <span class="comment">/* We can delete to original WAV data now */</span>
                <a class="code" href="_sdl_8cs.html#aa59c06f2223e64f2b5f74b82625dd43f" title="Frees previously opened WAV data.">SDL_FreeWAV</a>(wav_buf);

                <span class="comment">/* And now we&#39;re ready to convert */</span>
                <a class="code" href="_sdl_8cs.html#a7ed641a1e339dc97cfd58c08dd9af2e2" title="Convert audio data to a desired audio format.">SDL_ConvertAudio</a>(&amp;amp;wav_cvt);

                <span class="comment">/* do whatever */</span>
                .
                .
                .
                .
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cvt</em>&nbsp;</td><td>IntPtr to SDL_AudioCVT struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If SDL_ConvertAudio returned 0 then the conversion was completed successfully, otherwise -1 is returned. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>SDL_AudioCVT, <a class="el" href="_sdl_8cs.html#ab290a18bf5bf8a161042ceb8c43c5654" title="Initializes a SDL_AudioCVT structure for conversion.">SDL_BuildAudioCVT(IntPtr, short, byte, int, short, byte, int)</a></dd></dl>

</div>
</div>
<a class="anchor" id="a120ecaa205cb5d317d43f02e765a963b"></a><!-- doxytag: member="Sdl.cs::SDL_ConvertSurface" ref="a120ecaa205cb5d317d43f02e765a963b" args="(IntPtr src, IntPtr fmt, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_ConvertSurface </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a surface to the same format as another surface. </p>
<p>Creates a new surface of the specified format, and then copies and maps the given surface to it. If this function fails, it returns NULL. </p>
<p>The flags parameter is passed to <a class="el" href="_sdl_8cs.html#aa732dd717414124c4710c0d25f8e07ce">SDL_CreateRGBSurface(int, int, int, int, int, int, int, int)</a> and has those semantics. </p>
<p>This function is used internally by <a class="el" href="_sdl_8cs.html#a557565508a6c32f7bb4703f040a622c1" title="Convert a surface to the display format.">SDL_DisplayFormat</a>. </p>
<p>This function can only be called after SDL_Init. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment">            <a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *<a class="code" href="_sdl_8cs.html#a120ecaa205cb5d317d43f02e765a963b" title="Converts a surface to the same format as another surface.">SDL_ConvertSurface</a>(<a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *src, <a class="code" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a> *<a class="code" href="_sdl_8cs.html#a36910ddc19d1bf237b12507db74f71a2" title="Stores surface format information.">fmt</a>, Uint32 flags)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>IntPtr to <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fmt</em>&nbsp;</td><td>IntPTr to <a class="el" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns either a pointer to the new surface, or NULL on error. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aa732dd717414124c4710c0d25f8e07ce">SDL_CreateRGBSurface(int, int, int, int, int, int, int, int)</a></dd></dl>
<p>SDL_CreateRGBSurface</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a557565508a6c32f7bb4703f040a622c1" title="Convert a surface to the display format.">SDL_DisplayFormat</a></dd></dl>
<p>SDL_DisplayFormat</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a></dd></dl>
<p><a class="el" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a></p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></dd></dl>
<p><a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></p>

</div>
</div>
<a class="anchor" id="abe17ebde3616fdbfbe81d9f60c8abdf4"></a><!-- doxytag: member="Sdl.cs::SDL_ConvertSurface" ref="abe17ebde3616fdbfbe81d9f60c8abdf4" args="(IntPtr src, IntPtr fmt, uint flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_ConvertSurface </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a surface to the same format as another surface. </p>
<p>Creates a new surface of the specified format, and then copies and maps the given surface to it. If this function fails, it returns NULL. </p>
<p>The flags parameter is passed to <a class="el" href="_sdl_8cs.html#aa732dd717414124c4710c0d25f8e07ce">SDL_CreateRGBSurface(int, int, int, int, int, int, int, int)</a> and has those semantics. </p>
<p>This function is used internally by <a class="el" href="_sdl_8cs.html#a557565508a6c32f7bb4703f040a622c1" title="Convert a surface to the display format.">SDL_DisplayFormat</a>. </p>
<p>This function can only be called after SDL_Init. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment">            <a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *<a class="code" href="_sdl_8cs.html#a120ecaa205cb5d317d43f02e765a963b" title="Converts a surface to the same format as another surface.">SDL_ConvertSurface</a>(<a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *src, <a class="code" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a> *fmt, Uint32 flags)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>IntPtr to <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fmt</em>&nbsp;</td><td>IntPTr to <a class="el" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns either a pointer to the new surface, or NULL on error. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aa732dd717414124c4710c0d25f8e07ce">SDL_CreateRGBSurface(int, int, int, int, int, int, int, int)</a></dd></dl>
<p>SDL_CreateRGBSurface</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a557565508a6c32f7bb4703f040a622c1" title="Convert a surface to the display format.">SDL_DisplayFormat</a></dd></dl>
<p>SDL_DisplayFormat</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a></dd></dl>
<p><a class="el" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a></p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></dd></dl>
<p><a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></p>

</div>
</div>
<a class="anchor" id="a2bb559daf2f04feb28fab505f4f934cf"></a><!-- doxytag: member="Sdl.cs::SDL_CreateCond" ref="a2bb559daf2f04feb28fab505f4f934cf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_CreateCond </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a condition variable. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>intPtr to variable </dd></dl>
<p>Binds to C-function call in SDL_mutex.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC SDL_cond * SDLCALL <a class="code" href="_sdl_8cs.html#a2bb559daf2f04feb28fab505f4f934cf" title="Create a condition variable.">SDL_CreateCond</a>(<span class="keywordtype">void</span>)
</pre></div>  
</div>
</div>
<a class="anchor" id="aab5253287140e2324b65aa03519ea6d8"></a><!-- doxytag: member="Sdl.cs::SDL_CreateCursor" ref="aab5253287140e2324b65aa03519ea6d8" args="(ref byte data, ref byte mask, int w, int h, int hot_x, int hot_y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_CreateCursor </td>
          <td>(</td>
          <td class="paramtype">ref byte&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref byte&nbsp;</td>
          <td class="paramname"> <em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>hot_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>hot_y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new mouse cursor. </p>
<p>Create a cursor using the specified data and mask (in MSB format). The cursor width must be a multiple of 8 bits. </p>
<p>The cursor is created in black and white according to the following: </p>
<div class="fragment"><pre class="fragment">            data  mask    resulting <a class="code" href="_sdl_8cs.html#a36392890a1aba4cacbe1cad263a699f0">pixel</a> on <a class="code" href="_sdl_8cs.html#a968bba55c7ad32b326939fefd1bbb017" title="Sets a portion of the colormap for the given 8-bit surface.">screen</a>
             0     1       White
             1     1       Black
             0     0       Transparent
             1     0       Inverted color <span class="keywordflow">if</span> possible, black <span class="keywordflow">if</span> not.
</pre></div><p> Cursors created with this function must be freed with <a class="el" href="_sdl_8cs.html#a9649cb004abe3f8d89f6763387ca3bc4" title="Frees a cursor created with SDL_CreateCursor.">SDL_FreeCursor</a>. </p>
<p>Binds to C-function call in SDL_mouse.h: </p>
<div class="fragment"><pre class="fragment">            <a class="code" href="struct_s_d_l___cursor.html">SDL_Cursor</a> *<a class="code" href="_sdl_8cs.html#aab5253287140e2324b65aa03519ea6d8" title="Creates a new mouse cursor.">SDL_CreateCursor</a>(Uint8 *data, Uint8 *mask, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#ae53b59602879361d91ef9a2bdd5ae091">h</a>, <span class="keywordtype">int</span> hot_x, <span class="keywordtype">int</span> hot_y);
</pre></div> <div class="fragment"><pre class="fragment">            <span class="comment">/* Stolen from the mailing list */</span>
 Creates a <span class="keyword">new</span> mouse cursor from an XPM */

            <span class="comment">/* XPM */</span>
           <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *arrow[] = {
             <span class="comment">/* width height num_colors chars_per_pixel */</span>
             <span class="stringliteral">&quot;    32    32        3            1&quot;</span>,
             <span class="comment">/* colors */</span>
            <span class="stringliteral">&quot;X c #000000&quot;</span>,
             <span class="stringliteral">&quot;. c #ffffff&quot;</span>,
             <span class="stringliteral">&quot;  c None&quot;</span>,
             <span class="comment">/* pixels */</span>
             <span class="stringliteral">&quot;X                               &quot;</span>,
             <span class="stringliteral">&quot;XX                              &quot;</span>,
             <span class="stringliteral">&quot;X.X                             &quot;</span>,
             <span class="stringliteral">&quot;X..X                            &quot;</span>,
             <span class="stringliteral">&quot;X...X                           &quot;</span>,
             <span class="stringliteral">&quot;X....X                          &quot;</span>,
             <span class="stringliteral">&quot;X.....X                         &quot;</span>,
             <span class="stringliteral">&quot;X......X                        &quot;</span>,
             <span class="stringliteral">&quot;X.......X                       &quot;</span>,
             <span class="stringliteral">&quot;X........X                      &quot;</span>,
             <span class="stringliteral">&quot;X.....XXXXX                     &quot;</span>,
             <span class="stringliteral">&quot;X..X..X                         &quot;</span>,
             <span class="stringliteral">&quot;X.X X..X                        &quot;</span>,
             <span class="stringliteral">&quot;XX  X..X                        &quot;</span>,
             <span class="stringliteral">&quot;X    X..X                       &quot;</span>,
             <span class="stringliteral">&quot;     X..X                       &quot;</span>,
             <span class="stringliteral">&quot;      X..X                      &quot;</span>,
             <span class="stringliteral">&quot;      X..X                      &quot;</span>,
             <span class="stringliteral">&quot;       XX                       &quot;</span>,
             <span class="stringliteral">&quot;                                &quot;</span>,
             <span class="stringliteral">&quot;                                &quot;</span>,
             <span class="stringliteral">&quot;                                &quot;</span>,
             <span class="stringliteral">&quot;                                &quot;</span>,
             <span class="stringliteral">&quot;                                &quot;</span>,
             <span class="stringliteral">&quot;                                &quot;</span>,
             <span class="stringliteral">&quot;                                &quot;</span>,
             <span class="stringliteral">&quot;                                &quot;</span>,
             <span class="stringliteral">&quot;                                &quot;</span>,
             <span class="stringliteral">&quot;                                &quot;</span>,
             <span class="stringliteral">&quot;                                &quot;</span>,
             <span class="stringliteral">&quot;                                &quot;</span>,
             <span class="stringliteral">&quot;                                &quot;</span>,
             <span class="stringliteral">&quot;0,0&quot;</span>
           };

           <span class="keyword">static</span> <a class="code" href="struct_s_d_l___cursor.html">SDL_Cursor</a> *init_system_cursor(<span class="keyword">const</span> <span class="keywordtype">char</span> *image[])
           {
             <span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#acb559820d9ca11295b4500f179ef6392">i</a>, row, col;
             Uint8 data[4*32];
             Uint8 mask[4*32];
             <span class="keywordtype">int</span> hot_x, hot_y;

             i = -1;
             <span class="keywordflow">for</span> ( row=0; row&amp;lt;32; ++row ) {
               <span class="keywordflow">for</span> ( col=0; col&amp;lt;32; ++col ) {
                 <span class="keywordflow">if</span> ( col % 8 ) {
                   data[i] &amp;lt;&amp;lt;= 1;
                   mask[i] &amp;lt;&amp;lt;= 1;
                 } <span class="keywordflow">else</span> {
                   ++i;
                   data[i] = mask[i] = 0;
                 }
                 <span class="keywordflow">switch</span> (image[4+row][col]) {
                   <span class="keywordflow">case</span> <span class="charliteral">&#39;X&#39;</span>:
                     data[i] |= 0x01;
                     mask[i] |= 0x01;
                     <span class="keywordflow">break</span>;
                   <span class="keywordflow">case</span> <span class="charliteral">&#39;.&#39;</span>:
                     mask[i] |= 0x01;
                     <span class="keywordflow">break</span>;
                   <span class="keywordflow">case</span> <span class="charliteral">&#39; &#39;</span>:
                     <span class="keywordflow">break</span>;
                 }
               }
             }
             sscanf(image[4+row], <span class="stringliteral">&quot;%d,%d&quot;</span>, &amp;amp;hot_x, &amp;amp;hot_y);
             <span class="keywordflow">return</span> <a class="code" href="_sdl_8cs.html#aab5253287140e2324b65aa03519ea6d8" title="Creates a new mouse cursor.">SDL_CreateCursor</a>(data, mask, 32, 32, hot_x, hot_y);
           }
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hot_x</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hot_y</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a9649cb004abe3f8d89f6763387ca3bc4" title="Frees a cursor created with SDL_CreateCursor.">SDL_FreeCursor</a>, <a class="el" href="_sdl_8cs.html#a6b58417a3cfb7d43adae3e661991ec1f" title="Set the currently active cursor to the specified one.">SDL_SetCursor</a>, <a class="el" href="_sdl_8cs.html#a4e85211428ccac72ba71d06b2391ab06" title="Toggle whether or not the cursor is shown on the screen.">SDL_ShowCursor</a></dd></dl>

</div>
</div>
<a class="anchor" id="add77a85ba39c31e44f86060ceea1d891"></a><!-- doxytag: member="Sdl.cs::SDL_CreateMutex" ref="add77a85ba39c31e44f86060ceea1d891" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_CreateMutex </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a mutex, initialized unlocked. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>IntPtr to mutex </dd></dl>
<p>Binds to C-function call in SDL_mutex.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC SDL_mutex * SDLCALL <a class="code" href="_sdl_8cs.html#add77a85ba39c31e44f86060ceea1d891" title="Create a mutex, initialized unlocked.">SDL_CreateMutex</a>(<span class="keywordtype">void</span>)
</pre></div>  
</div>
</div>
<a class="anchor" id="a8676d7148bd6a15ced4b3071c3dcd7aa"></a><!-- doxytag: member="Sdl.cs::SDL_CreateRGBSurface" ref="a8676d7148bd6a15ced4b3071c3dcd7aa" args="(uint flags, int width, int height, int depth, uint Rmask, uint Gmask, uint Bmask, uint Amask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">&lt;/example&gt;&lt;paramname=&quot;flags&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;width&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;height&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;depth&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;Rmask&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;Gmask&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;Bmask&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;Amask&quot;&gt;&lt;/param&gt;&lt;returns&gt; IntPtr or NULL upon error.&lt;/returns&gt;&lt;seealsocref=&quot;SDL_CreateRGBSurfaceFrom(System.IntPtr,int,int,int,int,int,int,int,int)&quot;&gt; SDL_CreateRGBSurfaceFrom&lt;/seealso&gt;&lt;seealsocref=&quot;SDL_FreeSurface&quot;&gt; SDL_FreeSurface&lt;/seealso&gt;&lt;seealsocref=&quot;SDL_SetVideoMode(int,int,int,int)&quot;&gt; SDL_SetVideoMode&lt;/seealso&gt;&lt;seealsocref=&quot;SDL_LockSurface&quot;&gt; SDL_LockSurface&lt;/seealso&gt;&lt;seealsocref=&quot;SDL_PixelFormat&quot;&gt; SDL_PixelFormat&lt;/seealso&gt;&lt;seealsocref=&quot;SDL_Surface&quot;&gt; SDL_Surface&lt;/seealso&gt;&lt;seealsocref=&quot;SDL_SetAlpha(IntPtr,int,byte)&quot;&gt; SDL_SetAlpha&lt;/seealso&gt;&lt;seealsocref=&quot;SDL_SetColorKey(IntPtr,int,int)&quot;&gt; SDL_SetColorKey&lt;/seealso&gt;* static IntPtr SDL_CreateRGBSurface </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>Rmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>Gmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>Bmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>Amask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa732dd717414124c4710c0d25f8e07ce"></a><!-- doxytag: member="Sdl.cs::SDL_CreateRGBSurface" ref="aa732dd717414124c4710c0d25f8e07ce" args="(int flags, int width, int height, int depth, int Rmask, int Gmask, int Bmask, int Amask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">&lt;/example&gt;&lt;paramname=&quot;flags&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;width&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;height&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;depth&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;Rmask&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;Gmask&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;Bmask&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;Amask&quot;&gt;&lt;/param&gt;&lt;returns&gt; IntPtr or NULL upon error.&lt;/returns&gt;&lt;seealsocref=&quot;SDL_CreateRGBSurfaceFrom(System.IntPtr,int,int,int,int,int,int,int,int)&quot;&gt; SDL_CreateRGBSurfaceFrom&lt;/seealso&gt;&lt;seealsocref=&quot;SDL_FreeSurface&quot;&gt; SDL_FreeSurface&lt;/seealso&gt;&lt;seealsocref=&quot;SDL_SetVideoMode(int,int,int,int)&quot;&gt; SDL_SetVideoMode&lt;/seealso&gt;&lt;seealsocref=&quot;SDL_LockSurface&quot;&gt; SDL_LockSurface&lt;/seealso&gt;&lt;seealsocref=&quot;SDL_PixelFormat&quot;&gt; SDL_PixelFormat&lt;/seealso&gt;&lt;seealsocref=&quot;SDL_Surface&quot;&gt; SDL_Surface&lt;/seealso&gt;&lt;seealsocref=&quot;SDL_SetAlpha(IntPtr,int,byte)&quot;&gt; SDL_SetAlpha&lt;/seealso&gt;&lt;seealsocref=&quot;SDL_SetColorKey(IntPtr,int,int)&quot;&gt; SDL_SetColorKey&lt;/seealso&gt;* static IntPtr SDL_CreateRGBSurface </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Rmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Gmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Bmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Amask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a09e1892c9d6a02ce0c8b1ff92e032666"></a><!-- doxytag: member="Sdl.cs::SDL_CreateRGBSurfaceFrom" ref="a09e1892c9d6a02ce0c8b1ff92e032666" args="(IntPtr pixels, int width, int height, int depth, int pitch, int Rmask, int Gmask, int Bmask, int Amask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_CreateRGBSurfaceFrom </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>pixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Rmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Gmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Bmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Amask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> from pixel data. </p>
<p>Creates an <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> from the provided pixel data. </p>
<p>The data stored in pixels is assumed to be of the depth specified in the parameter list. The pixel data is not copied into the <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> structure so it should not be freed until the surface has been freed with a called to <a class="el" href="_sdl_8cs.html#a3062b061d8f75b52d1c4887209a92c10" title="Frees (deletes) a SDL_Surface.">SDL_FreeSurface</a>. pitch is the length of each scanline in bytes.  </p>
<p>See <a class="el" href="_sdl_8cs.html#aa732dd717414124c4710c0d25f8e07ce">SDL_CreateRGBSurface(int, int, int, int, int, int, int, int)</a> for a more detailed description of the other parameters. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *<a class="code" href="_sdl_8cs.html#a09e1892c9d6a02ce0c8b1ff92e032666" title="Create an SDL_Surface from pixel data.">SDL_CreateRGBSurfaceFrom</a>(<span class="keywordtype">void</span> *pixels, <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height, <span class="keywordtype">int</span> depth, <span class="keywordtype">int</span> pitch, Uint32 <a class="code" href="_sdl_8cs.html#a6a9df771fdb653ae2056012af21af56f">Rmask</a>, Uint32 <a class="code" href="_sdl_8cs.html#a8ee5a0cd4f45561ba2ec1768f71b4824">Gmask</a>, Uint32 <a class="code" href="_sdl_8cs.html#a0c79dd52bfbbf1f797424c029b601a4d">Bmask</a>, Uint32 <a class="code" href="_sdl_8cs.html#ac854fb38bb0ed1c2af25170f901ee015">Amask</a>)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pixels</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pitch</em>&nbsp;</td><td>length of each scanline in bytes.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Rmask</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Gmask</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Bmask</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Amask</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the created surface, or NULL upon error. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aa732dd717414124c4710c0d25f8e07ce">SDL_CreateRGBSurface(int, int, int, int, int, int, int, int)</a>, <a class="el" href="_sdl_8cs.html#a3062b061d8f75b52d1c4887209a92c10" title="Frees (deletes) a SDL_Surface.">SDL_FreeSurface</a></dd></dl>

</div>
</div>
<a class="anchor" id="a08011f62ba5e056681ce751a9278dece"></a><!-- doxytag: member="Sdl.cs::SDL_CreateRGBSurfaceFrom" ref="a08011f62ba5e056681ce751a9278dece" args="(IntPtr pixels, int width, int height, int depth, int pitch, uint Rmask, uint Gmask, uint Bmask, uint Amask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_CreateRGBSurfaceFrom </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>pixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>Rmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>Gmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>Bmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>Amask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> from pixel data. </p>
<p>Creates an <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> from the provided pixel data. </p>
<p>The data stored in pixels is assumed to be of the depth specified in the parameter list. The pixel data is not copied into the <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> structure so it should not be freed until the surface has been freed with a called to <a class="el" href="_sdl_8cs.html#a3062b061d8f75b52d1c4887209a92c10" title="Frees (deletes) a SDL_Surface.">SDL_FreeSurface</a>. pitch is the length of each scanline in bytes.  </p>
<p>See <a class="el" href="_sdl_8cs.html#aa732dd717414124c4710c0d25f8e07ce">SDL_CreateRGBSurface(int, int, int, int, int, int, int, int)</a> for a more detailed description of the other parameters. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *<a class="code" href="_sdl_8cs.html#a09e1892c9d6a02ce0c8b1ff92e032666" title="Create an SDL_Surface from pixel data.">SDL_CreateRGBSurfaceFrom</a>(<span class="keywordtype">void</span> *pixels, <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height, <span class="keywordtype">int</span> depth, <span class="keywordtype">int</span> pitch, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pixels</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pitch</em>&nbsp;</td><td>length of each scanline in bytes.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Rmask</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Gmask</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Bmask</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Amask</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the created surface, or NULL upon error. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aa732dd717414124c4710c0d25f8e07ce">SDL_CreateRGBSurface(int, int, int, int, int, int, int, int)</a>, <a class="el" href="_sdl_8cs.html#a3062b061d8f75b52d1c4887209a92c10" title="Frees (deletes) a SDL_Surface.">SDL_FreeSurface</a></dd></dl>

</div>
</div>
<a class="anchor" id="a17908a0f03b8e22466f71bfb177e233a"></a><!-- doxytag: member="Sdl.cs::SDL_CreateSemaphore" ref="a17908a0f03b8e22466f71bfb177e233a" args="(int initial_value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_CreateSemaphore </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>initial_value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a semaphore, initialized with value, returns NULL on failure. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Create a semaphore, initialized with value, returns NULL on failure. </dd></dl>
<p>Binds to C-function call in SDL_mutex.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC SDL_sem * SDLCALL <a class="code" href="_sdl_8cs.html#a17908a0f03b8e22466f71bfb177e233a" title="Create a semaphore, initialized with value, returns NULL on failure.">SDL_CreateSemaphore</a>(Uint32 initial_value)
</pre></div>  
</div>
</div>
<a class="anchor" id="ae1a363ea92381eeb2b198e4431fbc2d0"></a><!-- doxytag: member="Sdl.cs::SDL_CreateSemaphore" ref="ae1a363ea92381eeb2b198e4431fbc2d0" args="(uint initial_value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_CreateSemaphore </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>initial_value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a semaphore, initialized with value, returns NULL on failure. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Create a semaphore, initialized with value, returns NULL on failure. </dd></dl>
<p>Binds to C-function call in SDL_mutex.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC SDL_sem * SDLCALL <a class="code" href="_sdl_8cs.html#a17908a0f03b8e22466f71bfb177e233a" title="Create a semaphore, initialized with value, returns NULL on failure.">SDL_CreateSemaphore</a>(Uint32 initial_value)
</pre></div>  
</div>
</div>
<a class="anchor" id="a341bd10695a15949d264155ff880c866"></a><!-- doxytag: member="Sdl.cs::SDL_CreateThread" ref="a341bd10695a15949d264155ff880c866" args="(ThreadDelegate fn, object data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_CreateThread </td>
          <td>(</td>
          <td class="paramtype">ThreadDelegate&nbsp;</td>
          <td class="paramname"> <em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create thread. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>IntPtr to SDL_Thread struct </dd></dl>
<p>Binds to C-function call in SDL_thread.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC SDL_Thread * SDLCALL <a class="code" href="_sdl_8cs.html#a341bd10695a15949d264155ff880c866" title="Create thread.">SDL_CreateThread</a>(<span class="keywordtype">int</span> (SDLCALL *fn)(<span class="keywordtype">void</span> *), <span class="keywordtype">void</span> *data)
</pre></div>  
</div>
</div>
<a class="anchor" id="a433c9c002d6c6a4a3077fc12ff790372"></a><!-- doxytag: member="Sdl.cs::SDL_CreateYUVOverlay" ref="a433c9c002d6c6a4a3077fc12ff790372" args="(int width, int height, int format, IntPtr display)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_CreateYUVOverlay </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>display</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a YUV video overlay. </p>
<p>SDL_CreateYUVOverlay creates a YUV overlay of the specified width, height and format (see <a class="el" href="struct_s_d_l___overlay.html" title="The YUV hardware video overlay.">SDL_Overlay</a> for a list of available formats), for the provided display. A <a class="el" href="struct_s_d_l___overlay.html" title="The YUV hardware video overlay.">SDL_Overlay</a> structure is returned. </p>
<p>The term 'overlay' is a misnomer since, unless the overlay is created in hardware, the contents for the display surface underneath the area where the overlay is shown will be overwritten when the overlay is displayed. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="struct_s_d_l___overlay.html" title="The YUV hardware video overlay.">SDL_Overlay</a> *<a class="code" href="_sdl_8cs.html#a433c9c002d6c6a4a3077fc12ff790372" title="Create a YUV video overlay.">SDL_CreateYUVOverlay</a>(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height, Uint32 format, <a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *display)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>display</em>&nbsp;</td><td>IntPtr to <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>IntPtr to <a class="el" href="struct_s_d_l___overlay.html" title="The YUV hardware video overlay.">SDL_Overlay</a></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_s_d_l___overlay.html" title="The YUV hardware video overlay.">SDL_Overlay</a>, <a class="el" href="_sdl_8cs.html#a2dd4ac9e3a2f29ca1b24098361d8b50f" title="Blit the overlay to the display.">SDL_DisplayYUVOverlay</a>, <a class="el" href="_sdl_8cs.html#a5152023ef4588c85f5190e5a067527bc" title="Free a YUV video overlay.">SDL_FreeYUVOverlay</a></dd></dl>

</div>
</div>
<a class="anchor" id="ad409aa089348d881dfa080fef6fd41d0"></a><!-- doxytag: member="Sdl.cs::SDL_CreateYUVOverlay" ref="ad409aa089348d881dfa080fef6fd41d0" args="(int width, int height, uint format, IntPtr display)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_CreateYUVOverlay </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>display</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a YUV video overlay. </p>
<p>SDL_CreateYUVOverlay creates a YUV overlay of the specified width, height and format (see <a class="el" href="struct_s_d_l___overlay.html" title="The YUV hardware video overlay.">SDL_Overlay</a> for a list of available formats), for the provided display. A <a class="el" href="struct_s_d_l___overlay.html" title="The YUV hardware video overlay.">SDL_Overlay</a> structure is returned. </p>
<p>The term 'overlay' is a misnomer since, unless the overlay is created in hardware, the contents for the display surface underneath the area where the overlay is shown will be overwritten when the overlay is displayed. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="struct_s_d_l___overlay.html" title="The YUV hardware video overlay.">SDL_Overlay</a> *<a class="code" href="_sdl_8cs.html#a433c9c002d6c6a4a3077fc12ff790372" title="Create a YUV video overlay.">SDL_CreateYUVOverlay</a>(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height, Uint32 format, <a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *display)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>display</em>&nbsp;</td><td>IntPtr to <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>IntPtr to <a class="el" href="struct_s_d_l___overlay.html" title="The YUV hardware video overlay.">SDL_Overlay</a></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_s_d_l___overlay.html" title="The YUV hardware video overlay.">SDL_Overlay</a>, <a class="el" href="_sdl_8cs.html#a2dd4ac9e3a2f29ca1b24098361d8b50f" title="Blit the overlay to the display.">SDL_DisplayYUVOverlay</a>, <a class="el" href="_sdl_8cs.html#a5152023ef4588c85f5190e5a067527bc" title="Free a YUV video overlay.">SDL_FreeYUVOverlay</a></dd></dl>

</div>
</div>
<a class="anchor" id="a71ab491dce88b1d92c008dca21b47c13"></a><!-- doxytag: member="Sdl.cs::SDL_Delay" ref="a71ab491dce88b1d92c008dca21b47c13" args="(int ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_Delay </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ms</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait a specified number of milliseconds before returning. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ms</em>&nbsp;</td><td>The number of milliseconds to wait. </td></tr>
  </table>
  </dd>
</dl>
<p><b>SDL_Delay</b> will wait at least the specified time, but possible longer due to OS scheduling. Count on a delay granularity of at least 10 ms. Some platforms have shorter clock ticks but this is the most common. </p>
<p>Binds to C-function call in SDL_timer.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">void</span> SDLCALL <a class="code" href="_sdl_8cs.html#a71ab491dce88b1d92c008dca21b47c13" title="Wait a specified number of milliseconds before returning.">SDL_Delay</a>(Uint32 ms)
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a0847fd552fc17aa314f866ac16db60df" title="Add a timer which will call a callback after the specified number of milliseconds has elapsed...">SDL_AddTimer(int, SDL_NewTimerCallback)</a></dd></dl>

</div>
</div>
<a class="anchor" id="afd1e96591abd437068e6e375dff9649f"></a><!-- doxytag: member="Sdl.cs::SDL_Delay" ref="afd1e96591abd437068e6e375dff9649f" args="(uint ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_Delay </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>ms</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait a specified number of milliseconds before returning. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ms</em>&nbsp;</td><td>The number of milliseconds to wait. </td></tr>
  </table>
  </dd>
</dl>
<p><b>SDL_Delay</b> will wait at least the specified time, but possible longer due to OS scheduling. Count on a delay granularity of at least 10 ms. Some platforms have shorter clock ticks but this is the most common. </p>
<p>Binds to C-function call in SDL_timer.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">void</span> SDLCALL <a class="code" href="_sdl_8cs.html#a71ab491dce88b1d92c008dca21b47c13" title="Wait a specified number of milliseconds before returning.">SDL_Delay</a>(Uint32 ms)
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a0847fd552fc17aa314f866ac16db60df" title="Add a timer which will call a callback after the specified number of milliseconds has elapsed...">SDL_AddTimer(int, SDL_NewTimerCallback)</a></dd></dl>

</div>
</div>
<a class="anchor" id="a5a60e09c4685b2db2e55312008da0275"></a><!-- doxytag: member="Sdl.cs::SDL_DestroyCond" ref="a5a60e09c4685b2db2e55312008da0275" args="(IntPtr cond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_DestroyCond </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>cond</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy a condition variable. </p>
<p>Binds to C-function call in SDL_mutex.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">void</span> SDLCALL <a class="code" href="_sdl_8cs.html#a5a60e09c4685b2db2e55312008da0275" title="Destroy a condition variable.">SDL_DestroyCond</a>(SDL_cond *cond)
</pre></div>  
</div>
</div>
<a class="anchor" id="a75da38ee7599743465b8622c68596a39"></a><!-- doxytag: member="Sdl.cs::SDL_DestroyMutex" ref="a75da38ee7599743465b8622c68596a39" args="(IntPtr mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_DestroyMutex </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>mutex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy a mutex. </p>
<p>Binds to C-function call in SDL_mutex.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">void</span> SDLCALL <a class="code" href="_sdl_8cs.html#a75da38ee7599743465b8622c68596a39" title="Destroy a mutex.">SDL_DestroyMutex</a>(SDL_mutex *mutex)
</pre></div>  
</div>
</div>
<a class="anchor" id="a27b779d0e42b6b2a47556c89a8956050"></a><!-- doxytag: member="Sdl.cs::SDL_DestroySemaphore" ref="a27b779d0e42b6b2a47556c89a8956050" args="(IntPtr sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_DestroySemaphore </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>sem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy a semaphore. </p>
<p>Binds to C-function call in SDL_mutex.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">void</span> SDLCALL <a class="code" href="_sdl_8cs.html#a27b779d0e42b6b2a47556c89a8956050" title="Destroy a semaphore.">SDL_DestroySemaphore</a>(SDL_sem *sem)
</pre></div>  
</div>
</div>
<a class="anchor" id="a557565508a6c32f7bb4703f040a622c1"></a><!-- doxytag: member="Sdl.cs::SDL_DisplayFormat" ref="a557565508a6c32f7bb4703f040a622c1" args="(IntPtr surface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_DisplayFormat </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>surface</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a surface to the display format. </p>
<p>This function takes a surface and copies it to a new surface of the pixel format and colors of the video framebuffer, suitable for fast blitting onto the display surface. It calls <a class="el" href="_sdl_8cs.html#a120ecaa205cb5d317d43f02e765a963b" title="Converts a surface to the same format as another surface.">SDL_ConvertSurface(IntPtr, IntPtr, int)</a>. </p>
<p>If you want to take advantage of hardware colorkey or alpha blit acceleration, you should set the colorkey and alpha value before calling this function. </p>
<p>If you want an alpha channel, see <a class="el" href="_sdl_8cs.html#ad76ca477f17f31fd3aaccf8c19f643c1" title="Convert a surface to the display format.">SDL_DisplayFormatAlpha</a>. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *<a class="code" href="_sdl_8cs.html#a557565508a6c32f7bb4703f040a622c1" title="Convert a surface to the display format.">SDL_DisplayFormat</a>(<a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *<a class="code" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1" title="Create an empty SDL_Surface.">surface</a>)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>surface</em>&nbsp;</td><td>IntPtr to <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>IntPtr to <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a>. If the conversion fails or runs out of memory, it returns NULL</dd></dl>

</div>
</div>
<a class="anchor" id="ad76ca477f17f31fd3aaccf8c19f643c1"></a><!-- doxytag: member="Sdl.cs::SDL_DisplayFormatAlpha" ref="ad76ca477f17f31fd3aaccf8c19f643c1" args="(IntPtr surface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_DisplayFormatAlpha </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>surface</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a surface to the display format. </p>
<p>This function takes a surface and copies it to a new surface of the pixel format and colors of the video framebuffer plus an alpha channel, suitable for fast blitting onto the display surface. It calls <a class="el" href="_sdl_8cs.html#a120ecaa205cb5d317d43f02e765a963b" title="Converts a surface to the same format as another surface.">SDL_ConvertSurface(IntPtr, IntPtr, int)</a>. </p>
<p>If you want to take advantage of hardware colorkey or alpha blit acceleration, you should set the colorkey and alpha value before calling this function. </p>
<p>This function can be used to convert a colourkey to an alpha channel, if the SDL_SRCCOLORKEY flag is set on the surface. The generated surface will then be transparent (alpha=0) where the pixels match the colourkey, and opaque (alpha=255) elsewhere. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *<a class="code" href="_sdl_8cs.html#ad76ca477f17f31fd3aaccf8c19f643c1" title="Convert a surface to the display format.">SDL_DisplayFormatAlpha</a>(<a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *surface)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>surface</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>IntPtr to <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a>. If the conversion fails or runs out of memory, it returns NULL</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a120ecaa205cb5d317d43f02e765a963b" title="Converts a surface to the same format as another surface.">SDL_ConvertSurface(IntPtr, IntPtr, int)</a>, <a class="el" href="_sdl_8cs.html#a77f6839de15f85b6c5afd9174894a41a" title="Adjust the alpha properties of a surface.">SDL_SetAlpha(IntPtr, int, byte)</a>, <a class="el" href="_sdl_8cs.html#a6143709fbf5b39f734e9de78cfa1d6c8" title="Sets the color key (transparent pixel) in a blittable surface and RLE acceleration.">SDL_SetColorKey(IntPtr, int, int)</a>, <a class="el" href="_sdl_8cs.html#a557565508a6c32f7bb4703f040a622c1" title="Convert a surface to the display format.">SDL_DisplayFormat</a>, <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></dd></dl>

</div>
</div>
<a class="anchor" id="a2dd4ac9e3a2f29ca1b24098361d8b50f"></a><!-- doxytag: member="Sdl.cs::SDL_DisplayYUVOverlay" ref="a2dd4ac9e3a2f29ca1b24098361d8b50f" args="(IntPtr overlay, ref SDL_Rect dstrect)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_DisplayYUVOverlay </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>overlay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref <a class="el" href="struct_s_d_l___rect.html">SDL_Rect</a>&nbsp;</td>
          <td class="paramname"> <em>dstrect</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Blit the overlay to the display. </p>
<p>Blit the overlay to the surface specified when it was <a class="el" href="_sdl_8cs.html#a433c9c002d6c6a4a3077fc12ff790372">created</a>. The <a class="el" href="struct_s_d_l___rect.html" title="Defines a rectangular area.">SDL_Rect</a> structure, dstrect, specifies the position and size of the destination. If the dstrect is a larger or smaller than the overlay then the overlay will be scaled, this is optimized for 2x scaling. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="_sdl_8cs.html#a2dd4ac9e3a2f29ca1b24098361d8b50f" title="Blit the overlay to the display.">SDL_DisplayYUVOverlay</a>(<a class="code" href="struct_s_d_l___overlay.html" title="The YUV hardware video overlay.">SDL_Overlay</a> *overlay, <a class="code" href="struct_s_d_l___rect.html" title="Defines a rectangular area.">SDL_Rect</a> *dstrect)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>overlay</em>&nbsp;</td><td>IntPtr to <a class="el" href="struct_s_d_l___overlay.html" title="The YUV hardware video overlay.">SDL_Overlay</a></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dstrect</em>&nbsp;</td><td><a class="el" href="struct_s_d_l___rect.html" title="Defines a rectangular area.">SDL_Rect</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 on success.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_s_d_l___overlay.html" title="The YUV hardware video overlay.">SDL_Overlay</a>, <a class="el" href="_sdl_8cs.html#a433c9c002d6c6a4a3077fc12ff790372" title="Create a YUV video overlay.">SDL_CreateYUVOverlay(int, int, int, IntPtr)</a></dd></dl>

</div>
</div>
<a class="anchor" id="af31ec1fa8ac9f58ec682d0ae0b363cc8"></a><!-- doxytag: member="Sdl.cs::SDL_EnableKeyRepeat" ref="af31ec1fa8ac9f58ec682d0ae0b363cc8" args="(int rate, int delay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_EnableKeyRepeat </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>delay</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set keyboard repeat rate. </p>
<p>Enables or disables the keyboard repeat rate. delay specifies how long the key must be pressed before it begins repeating, it then repeats at the speed specified by interval. Both delay and interval are expressed in milliseconds. </p>
<p>Setting delay to 0 disables key repeating completely. Good default values are SDL_DEFAULT_REPEAT_DELAY and SDL_DEFAULT_REPEAT_INTERVAL. p&gt;Binds to C-function in SDL_keyboard.h code&gt;int <a class="el" href="_sdl_8cs.html#af31ec1fa8ac9f58ec682d0ae0b363cc8" title="Set keyboard repeat rate.">SDL_EnableKeyRepeat(int delay, int interval)</a>; /code&gt;</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rate</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delay</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 on success and -1 on failure.</dd></dl>

</div>
</div>
<a class="anchor" id="a84ff6db83e36f31aa5b5643cc18b1364"></a><!-- doxytag: member="Sdl.cs::SDL_EnableUNICODE" ref="a84ff6db83e36f31aa5b5643cc18b1364" args="(int enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_EnableUNICODE </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>enable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable UNICODE translation. </p>
<p>Enables/Disables Unicode keyboard translation. </p>
<p>To obtain the character codes corresponding to received keyboard events, Unicode translation must first be turned on using this function. The translation incurs a slight overhead for each keyboard event and is therefore disabled by default. For each subsequently received key down event, the unicode member of the SDL_keysym structure will then contain the corresponding character code, or zero for keysyms that do not correspond to any character code. </p>
<p>A value of 1 for enable enables Unicode translation; 0 disables it, and -1 leaves it unchanged (useful for querying the current translation mode). </p>
<p>Note that only key press events will be translated, not release events. </p>
<p>Binds to C-function in SDL_keyboard.h </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#a84ff6db83e36f31aa5b5643cc18b1364" title="Enable UNICODE translation.">SDL_EnableUNICODE</a>(<span class="keywordtype">int</span> enable);
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>enable</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the previous translation mode (0 or 1). </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>SDL_keysym</dd></dl>

</div>
</div>
<a class="anchor" id="a4c40631c6aad689b8c805e443823aa42"></a><!-- doxytag: member="Sdl.cs::SDL_EventFilter" ref="a4c40631c6aad689b8c805e443823aa42" args="([Out] SDL_Event evt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">delegate int SDL_EventFilter </td>
          <td>(</td>
          <td class="paramtype">[Out] SDL_Event&nbsp;</td>
          <td class="paramname"> <em>evt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function sets up a filter to process all events before they change internal state and are posted to the internal event queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>evt</em>&nbsp;</td><td>Event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If the filter returns 1, then the event will be added to the internal queue. If it returns 0, then the event will be dropped from the queue. This allows selective filtering of dynamically. </dd></dl>
<p>Binds to C callback in SDL_events.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> Uint32 (SDLCALL *<a class="code" href="_sdl_8cs.html#a4c40631c6aad689b8c805e443823aa42" title="This function sets up a filter to process all events before they change internal state and are posted...">SDL_EventFilter</a>)(<span class="keyword">const</span> SDL_Event *event)
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#afd1ab8f1891d71ad6544323050271d2d" title="Sets up a filter to process all events before they are posted to the event queue.">SDL_SetEventFilter</a>, <a class="el" href="_sdl_8cs.html#aba4dab0b2d671d9f083744794ba77f2d" title="Retrieves a pointer to the event filter.">SDL_GetEventFilter</a></dd></dl>

</div>
</div>
<a class="anchor" id="a33f65e0690703749dc213ed95b406dd2"></a><!-- doxytag: member="Sdl.cs::SDL_EventState" ref="a33f65e0690703749dc213ed95b406dd2" args="(byte type, int state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_EventState </td>
          <td>(</td>
          <td class="paramtype">byte&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>state</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function allows you to set the state of processing certain events. </p>
<p>This function allows you to set the state of processing certain event type's. </p>
<p>If 'state' is set to SDL_IGNORE, that event will be automatically dropped from the event queue and will not be filtered. </p>
<p>If 'state' is set to SDL_ENABLE, that event will be processed normally. </p>
<p>If 'state' is set to SDL_QUERY, SDL_EventState will return the current processing state of the specified event type. </p>
<p>A list of event type's can be found in the SDL_Event section.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 on success or -1 if the event couldn't be pushed. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>SDL_Event</dd></dl>

</div>
</div>
<a class="anchor" id="a2be96435f87ccf4bf46776e6b0d30721"></a><!-- doxytag: member="Sdl.cs::SDL_FillRect" ref="a2be96435f87ccf4bf46776e6b0d30721" args="(IntPtr surface, ref SDL_Rect rect, uint color)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_FillRect </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref <a class="el" href="struct_s_d_l___rect.html">SDL_Rect</a>&nbsp;</td>
          <td class="paramname"> <em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>color</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function performs a fast fill of the given rectangle with some color. </p>
<p>This function performs a fast fill of the given rectangle with color. If dstrect is NULL, the whole surface will be filled with color. </p>
<p>The color should be a pixel of the format used by the surface, and can be generated by the <a class="el" href="_sdl_8cs.html#a8c6c5785c9010c08364e8abcd34648a0" title="Map a RGB color value to a pixel format.">SDL_MapRGB</a> or <a class="el" href="_sdl_8cs.html#aadad00b884d9cab5dcfc16b887963bb3" title="Map a RGBA color value to a pixel format.">SDL_MapRGBA</a> functions. If the color value contains an alpha value then the destination is simply "filled" with that alpha information, no blending takes place. </p>
<p>If there is a clip rectangle set on the destination (set via <a class="el" href="_sdl_8cs.html#a201a7363fdcfe07651a1298a3e4e1778" title="Sets the clipping rectangle for a surface.">SDL_SetClipRect</a>) then this function will clip based on the intersection of the clip rectangle and the dstrect rectangle and the dstrect rectangle will be modified to represent the area actually filled. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#ac5e42937782d41622cec743f145b4f81" title="This function performs a fast fill of the given rectangle with some color.">SDL_FillRect</a>(<a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *dst, <a class="code" href="struct_s_d_l___rect.html" title="Defines a rectangular area.">SDL_Rect</a> *dstrect, Uint32 color);
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>surface</em>&nbsp;</td><td>IntPtr to <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rect</em>&nbsp;</td><td>IntPtr to <a class="el" href="struct_s_d_l___rect.html" title="Defines a rectangular area.">SDL_Rect</a></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This function returns 0 on success, or -1 on error. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a8c6c5785c9010c08364e8abcd34648a0" title="Map a RGB color value to a pixel format.">SDL_MapRGB</a>, <a class="el" href="_sdl_8cs.html#aadad00b884d9cab5dcfc16b887963bb3" title="Map a RGBA color value to a pixel format.">SDL_MapRGBA</a>, <a class="el" href="_sdl_8cs.html#aec41f77b04d717457433acbecd7a257b" title="This performs a fast blit from the source surface to the destination surface.">SDL_BlitSurface</a>, <a class="el" href="struct_s_d_l___rect.html" title="Defines a rectangular area.">SDL_Rect</a></dd></dl>

</div>
</div>
<a class="anchor" id="ac5e42937782d41622cec743f145b4f81"></a><!-- doxytag: member="Sdl.cs::SDL_FillRect" ref="ac5e42937782d41622cec743f145b4f81" args="(IntPtr surface, ref SDL_Rect rect, int color)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_FillRect </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref <a class="el" href="struct_s_d_l___rect.html">SDL_Rect</a>&nbsp;</td>
          <td class="paramname"> <em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>color</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function performs a fast fill of the given rectangle with some color. </p>
<p>This function performs a fast fill of the given rectangle with color. If dstrect is NULL, the whole surface will be filled with color. </p>
<p>The color should be a pixel of the format used by the surface, and can be generated by the <a class="el" href="_sdl_8cs.html#a8c6c5785c9010c08364e8abcd34648a0" title="Map a RGB color value to a pixel format.">SDL_MapRGB</a> or <a class="el" href="_sdl_8cs.html#aadad00b884d9cab5dcfc16b887963bb3" title="Map a RGBA color value to a pixel format.">SDL_MapRGBA</a> functions. If the color value contains an alpha value then the destination is simply "filled" with that alpha information, no blending takes place. </p>
<p>If there is a clip rectangle set on the destination (set via <a class="el" href="_sdl_8cs.html#a201a7363fdcfe07651a1298a3e4e1778" title="Sets the clipping rectangle for a surface.">SDL_SetClipRect</a>) then this function will clip based on the intersection of the clip rectangle and the dstrect rectangle and the dstrect rectangle will be modified to represent the area actually filled. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#ac5e42937782d41622cec743f145b4f81" title="This function performs a fast fill of the given rectangle with some color.">SDL_FillRect</a>(<a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *dst, <a class="code" href="struct_s_d_l___rect.html" title="Defines a rectangular area.">SDL_Rect</a> *dstrect, Uint32 color);
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>surface</em>&nbsp;</td><td>IntPtr to <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rect</em>&nbsp;</td><td>IntPtr to <a class="el" href="struct_s_d_l___rect.html" title="Defines a rectangular area.">SDL_Rect</a></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This function returns 0 on success, or -1 on error. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a8c6c5785c9010c08364e8abcd34648a0" title="Map a RGB color value to a pixel format.">SDL_MapRGB</a>, <a class="el" href="_sdl_8cs.html#aadad00b884d9cab5dcfc16b887963bb3" title="Map a RGBA color value to a pixel format.">SDL_MapRGBA</a>, <a class="el" href="_sdl_8cs.html#aec41f77b04d717457433acbecd7a257b" title="This performs a fast blit from the source surface to the destination surface.">SDL_BlitSurface</a>, <a class="el" href="struct_s_d_l___rect.html" title="Defines a rectangular area.">SDL_Rect</a></dd></dl>

</div>
</div>
<a class="anchor" id="acc195af71a1137f48f929bf559d72bc0"></a><!-- doxytag: member="Sdl.cs::SDL_Flip" ref="acc195af71a1137f48f929bf559d72bc0" args="(IntPtr screen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_Flip </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>screen</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps screen buffers. </p>
<p>On hardware that supports double-buffering, this function sets up a flip and returns. The hardware will wait for vertical retrace, and then swap video buffers before the next video surface blit or lock will return. On hardware that does not support double-buffering, this is equivalent to calling SDL_UpdateRect(System.IntPtr, int, int, int, int)(screen, 0, 0, 0, 0) </p>
<p>The SDL_DOUBLEBUF flag must have been passed to <a class="el" href="_sdl_8cs.html#a961f7efdc2a7ec3860e93140853092f7" title="Set up a video mode with the specified width, height and bits-per-pixel.">SDL_SetVideoMode(int, int, int, int)</a> when setting the video mode for this function to perform hardware flipping.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>screen</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This function returns 0 if successful, or -1 if there was an error. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a961f7efdc2a7ec3860e93140853092f7" title="Set up a video mode with the specified width, height and bits-per-pixel.">SDL_SetVideoMode(int, int, int, int)</a></dd></dl>
<p>SDL_SetVideoMode</p>
<dl class="see"><dt><b>See also:</b></dt><dd>SDL_UpdateRect(System.IntPtr, int, int, int, int)</dd></dl>
<p>SDL_UpdateRect</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></dd></dl>
<p><a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></p>

</div>
</div>
<a class="anchor" id="a9649cb004abe3f8d89f6763387ca3bc4"></a><!-- doxytag: member="Sdl.cs::SDL_FreeCursor" ref="a9649cb004abe3f8d89f6763387ca3bc4" args="(ref SDL_Cursor cursor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_FreeCursor </td>
          <td>(</td>
          <td class="paramtype">ref <a class="el" href="struct_s_d_l___cursor.html">SDL_Cursor</a>&nbsp;</td>
          <td class="paramname"> <em>cursor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees a cursor created with SDL_CreateCursor. </p>
<p>Binds to C-function call in SDL_mouse.h: </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">void</span> <a class="code" href="_sdl_8cs.html#a9649cb004abe3f8d89f6763387ca3bc4" title="Frees a cursor created with SDL_CreateCursor.">SDL_FreeCursor</a>(<a class="code" href="struct_s_d_l___cursor.html">SDL_Cursor</a> *cursor)
</pre></div><p>  Frees a <a class="el" href="struct_s_d_l___cursor.html">SDL_Cursor</a> that was created using <a class="el" href="_sdl_8cs.html#aab5253287140e2324b65aa03519ea6d8" title="Creates a new mouse cursor.">SDL_CreateCursor</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cursor</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aab5253287140e2324b65aa03519ea6d8" title="Creates a new mouse cursor.">SDL_CreateCursor</a></dd></dl>

</div>
</div>
<a class="anchor" id="a13c12ec9d6bfe668b50e13cb71ebd8ee"></a><!-- doxytag: member="Sdl.cs::SDL_FreeRW" ref="a13c12ec9d6bfe668b50e13cb71ebd8ee" args="(IntPtr context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_FreeRW </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>context</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees an SDL_RWops structure allocated by <a class="el" href="_sdl_8cs.html#aa1fe24060926a8679b4a16201728a1e9" title="Allocates an empty, unpopulated SDL_RWops structure.">SDL_AllocRW</a>. </p>
<p><a class="el" href="_sdl_8cs.html#a13c12ec9d6bfe668b50e13cb71ebd8ee" title="Frees an SDL_RWops structure allocated by SDL_AllocRW.">SDL_FreeRW</a> frees an SDL_RWops structure previously allocated by <a class="el" href="_sdl_8cs.html#aa1fe24060926a8679b4a16201728a1e9" title="Allocates an empty, unpopulated SDL_RWops structure.">SDL_AllocRW</a>. Only use it on memory allocated by <a class="el" href="_sdl_8cs.html#aa1fe24060926a8679b4a16201728a1e9" title="Allocates an empty, unpopulated SDL_RWops structure.">SDL_AllocRW</a>. Any extra memory allocated during creation of the RWops is not freed by <a class="el" href="_sdl_8cs.html#a13c12ec9d6bfe668b50e13cb71ebd8ee" title="Frees an SDL_RWops structure allocated by SDL_AllocRW.">SDL_FreeRW</a>; the programmer must be responsible for it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment"><span class="preprocessor">            #include &quot;SDL_rwops.h&quot;</span>
            <span class="keywordtype">void</span> dumb_example()
            {
                SDL_RWops *rw=<a class="code" href="_sdl_8cs.html#aa1fe24060926a8679b4a16201728a1e9" title="Allocates an empty, unpopulated SDL_RWops structure.">SDL_AllocRW</a>();
                <span class="keywordflow">if</span>(rw==NULL) <span class="keywordflow">return</span>;
                <a class="code" href="_sdl_8cs.html#a13c12ec9d6bfe668b50e13cb71ebd8ee" title="Frees an SDL_RWops structure allocated by SDL_AllocRW.">SDL_FreeRW</a>(rw);
            }
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aa1fe24060926a8679b4a16201728a1e9" title="Allocates an empty, unpopulated SDL_RWops structure.">SDL_AllocRW</a></dd></dl>

</div>
</div>
<a class="anchor" id="a3062b061d8f75b52d1c4887209a92c10"></a><!-- doxytag: member="Sdl.cs::SDL_FreeSurface" ref="a3062b061d8f75b52d1c4887209a92c10" args="(IntPtr surface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_FreeSurface </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>surface</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees (deletes) a <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a>. </p>
<p>Frees the resources used by a previously created <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a>. If the surface was created using SDL_CreateRGBSurfaceFrom(System.IntPtr, int, int, int, int, int, int, int, int) then the pixel data is not freed. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="_sdl_8cs.html#a3062b061d8f75b52d1c4887209a92c10" title="Frees (deletes) a SDL_Surface.">SDL_FreeSurface</a>(<a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *surface)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>surface</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aa732dd717414124c4710c0d25f8e07ce">SDL_CreateRGBSurface(int, int, int, int, int, int, int, int)</a></dd></dl>
<p>SDL_CreateRGBSurface</p>
<dl class="see"><dt><b>See also:</b></dt><dd>SDL_CreateRGBSurfaceFrom(System.IntPtr, int, int, int, int, int, int, int, int)</dd></dl>
<p>SDL_CreateRGBSurfaceFrom</p>

</div>
</div>
<a class="anchor" id="aa59c06f2223e64f2b5f74b82625dd43f"></a><!-- doxytag: member="Sdl.cs::SDL_FreeWAV" ref="aa59c06f2223e64f2b5f74b82625dd43f" args="(ref IntPtr audio_buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_FreeWAV </td>
          <td>(</td>
          <td class="paramtype">ref IntPtr&nbsp;</td>
          <td class="paramname"> <em>audio_buf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees previously opened WAV data. </p>
<p>After a WAVE file has been opened with SDL_LoadWAV(string, out IntPtr, out IntPtr, out int) its data can eventually be freed with SDL_FreeWAV. audio_buf is a pointer to the buffer created by SDL_LoadWAV. </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">void</span> <a class="code" href="_sdl_8cs.html#aa59c06f2223e64f2b5f74b82625dd43f" title="Frees previously opened WAV data.">SDL_FreeWAV</a>(Uint8 *audio_buf)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>audio_buf</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>SDL_LoadWAV(string, out IntPtr, out IntPtr, out int)</dd></dl>

</div>
</div>
<a class="anchor" id="a5152023ef4588c85f5190e5a067527bc"></a><!-- doxytag: member="Sdl.cs::SDL_FreeYUVOverlay" ref="a5152023ef4588c85f5190e5a067527bc" args="(IntPtr overlay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_FreeYUVOverlay </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>overlay</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free a YUV video overlay. </p>
<p>Frees an <a class="el" href="struct_s_d_l___overlay.html">overlay</a> created by <a class="el" href="_sdl_8cs.html#a433c9c002d6c6a4a3077fc12ff790372" title="Create a YUV video overlay.">SDL_CreateYUVOverlay(int, int, int, IntPtr)</a> </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="_sdl_8cs.html#a5152023ef4588c85f5190e5a067527bc" title="Free a YUV video overlay.">SDL_FreeYUVOverlay</a>(<a class="code" href="struct_s_d_l___overlay.html" title="The YUV hardware video overlay.">SDL_Overlay</a> *overlay)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>overlay</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_s_d_l___overlay.html" title="The YUV hardware video overlay.">SDL_Overlay</a>, <a class="el" href="_sdl_8cs.html#a2dd4ac9e3a2f29ca1b24098361d8b50f" title="Blit the overlay to the display.">SDL_DisplayYUVOverlay</a>, <a class="el" href="_sdl_8cs.html#a433c9c002d6c6a4a3077fc12ff790372" title="Create a YUV video overlay.">SDL_CreateYUVOverlay(int, int, int, IntPtr)</a></dd></dl>
<p><a class="el" href="struct_s_d_l___overlay.html" title="The YUV hardware video overlay.">SDL_Overlay</a>, SDL_DisplayYUVOverlay, SDL_FreeYUVOverlay </p>

</div>
</div>
<a class="anchor" id="a09dacf1e51fd361c9ddbddf72848ac18"></a><!-- doxytag: member="Sdl.cs::SDL_GetAppState" ref="a09dacf1e51fd361c9ddbddf72848ac18" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static byte SDL_GetAppState </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns the current state of the application, which is a bitwise combination of SDL_APPMOUSEFOCUS, SDL_APPINPUTFOCUS, and SDL_APPACTIVE. </p>
<p>If SDL_APPACTIVE is set, then the user is able to see your application, otherwise it has been iconified or disabled.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the current state of the application, which is a bitwise combination of SDL_APPMOUSEFOCUS, SDL_APPINPUTFOCUS, and SDL_APPACTIVE </dd></dl>

</div>
</div>
<a class="anchor" id="a577477314e53e0fc9c7edd3af022dbf5"></a><!-- doxytag: member="Sdl.cs::SDL_GetAudioStatus" ref="a577477314e53e0fc9c7edd3af022dbf5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_GetAudioStatus </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current audio state. </p>
<p>Binds to C-function call in SDL_audio.h: </p>
<div class="fragment"><pre class="fragment">SDL_audiostatus <a class="code" href="_sdl_8cs.html#a577477314e53e0fc9c7edd3af022dbf5" title="Get the current audio state.">SDL_GetAudioStatus</a>(<span class="keywordtype">void</span>)
</pre></div><dl class="return"><dt><b>Returns:</b></dt><dd>Returns either SDL_AUDIO_STOPPED, SDL_AUDIO_PAUSED or SDL_AUDIO_PLAYING (SDLaudiostatus enum) depending on the current audio state.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a557320f482d1aa5bfe6121ee7cb7ad9f" title="Pauses and unpauses the audio callback processing.">SDL_PauseAudio</a></dd></dl>

</div>
</div>
<a class="anchor" id="ac51bb2502786730c93fd5c3cddf029f9"></a><!-- doxytag: member="Sdl.cs::SDL_GetClipRect" ref="ac51bb2502786730c93fd5c3cddf029f9" args="(IntPtr surface, ref SDL_Rect rect)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_GetClipRect </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref <a class="el" href="struct_s_d_l___rect.html">SDL_Rect</a>&nbsp;</td>
          <td class="paramname"> <em>rect</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the clipping rectangle for a surface. </p>
<p>Gets the clipping rectangle for a surface. When this surface is the destination of a blit, only the area within the clip rectangle is drawn into. </p>
<p>The rectangle pointed to by rect will be filled with the clipping rectangle of the surface. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">void</span> <a class="code" href="_sdl_8cs.html#ac51bb2502786730c93fd5c3cddf029f9" title="Gets the clipping rectangle for a surface.">SDL_GetClipRect</a>(<a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *surface, <a class="code" href="struct_s_d_l___rect.html" title="Defines a rectangular area.">SDL_Rect</a> *rect)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>surface</em>&nbsp;</td><td>IntPtr to <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rect</em>&nbsp;</td><td><a class="el" href="struct_s_d_l___rect.html" title="Defines a rectangular area.">SDL_Rect</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a201a7363fdcfe07651a1298a3e4e1778" title="Sets the clipping rectangle for a surface.">SDL_SetClipRect</a></dd></dl>
<p>SDL_SetClipRect</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aec41f77b04d717457433acbecd7a257b" title="This performs a fast blit from the source surface to the destination surface.">SDL_BlitSurface</a></dd></dl>
<p>SDL_BlitSurface</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></dd></dl>
<p><a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></p>

</div>
</div>
<a class="anchor" id="a0a560b30afc5f63ddb75ea60a9ab8a2f"></a><!-- doxytag: member="Sdl.cs::SDL_GetCursor" ref="a0a560b30afc5f63ddb75ea60a9ab8a2f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_GetCursor </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the currently active cursor. </p>
<p>Binds to C-function call in SDL_mouse.h: </p>
<div class="fragment"><pre class="fragment">            <a class="code" href="struct_s_d_l___cursor.html">SDL_Cursor</a> *<a class="code" href="_sdl_8cs.html#a0a560b30afc5f63ddb75ea60a9ab8a2f" title="Returns the currently active cursor.">SDL_GetCursor</a>(<span class="keywordtype">void</span>);
</pre></div> <dl class="return"><dt><b>Returns:</b></dt><dd>IntPtr to <a class="el" href="struct_s_d_l___cursor.html">SDL_Cursor</a></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aab5253287140e2324b65aa03519ea6d8" title="Creates a new mouse cursor.">SDL_CreateCursor</a>, <a class="el" href="_sdl_8cs.html#a6b58417a3cfb7d43adae3e661991ec1f" title="Set the currently active cursor to the specified one.">SDL_SetCursor</a>, <a class="el" href="_sdl_8cs.html#a4e85211428ccac72ba71d06b2391ab06" title="Toggle whether or not the cursor is shown on the screen.">SDL_ShowCursor</a></dd></dl>

</div>
</div>
<a class="anchor" id="aba4dab0b2d671d9f083744794ba77f2d"></a><!-- doxytag: member="Sdl.cs::SDL_GetEventFilter" ref="aba4dab0b2d671d9f083744794ba77f2d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static SDL_EventFilter SDL_GetEventFilter </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a pointer to the event filter. </p>
<p>This function retrieces a pointer to the event filter that was previously set using <a class="el" href="_sdl_8cs.html#afd1ab8f1891d71ad6544323050271d2d" title="Sets up a filter to process all events before they are posted to the event queue.">SDL_SetEventFilter</a>. An SDL_EventFilter function is defined as: </p>
<div class="fragment"><pre class="fragment">             <span class="keyword">typedef</span> int (*<a class="code" href="_sdl_8cs.html#a4c40631c6aad689b8c805e443823aa42" title="This function sets up a filter to process all events before they change internal state and are posted...">SDL_EventFilter</a>)(<span class="keyword">const</span> SDL_Event *event);
</pre></div> <p>Binds to C-function in SDL_events.h </p>
<div class="fragment"><pre class="fragment"><a class="code" href="_sdl_8cs.html#a4c40631c6aad689b8c805e443823aa42" title="This function sets up a filter to process all events before they change internal state and are posted...">SDL_EventFilter</a> <a class="code" href="_sdl_8cs.html#aba4dab0b2d671d9f083744794ba77f2d" title="Retrieves a pointer to the event filter.">SDL_GetEventFilter</a>(<span class="keywordtype">void</span>);
</pre></div> <dl class="return"><dt><b>Returns:</b></dt><dd>Returns a pointer to the event filter or NULL if no filter has been set. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>SDL_Event, <a class="el" href="_sdl_8cs.html#afd1ab8f1891d71ad6544323050271d2d" title="Sets up a filter to process all events before they are posted to the event queue.">SDL_SetEventFilter</a></dd></dl>

</div>
</div>
<a class="anchor" id="ae357d10a1961d2760a67332622c788ac"></a><!-- doxytag: member="Sdl.cs::SDL_GetGammaRamp" ref="ae357d10a1961d2760a67332622c788ac" args="([In, Out] short[] red,[In, Out] short[] green,[In, Out] short[] blue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_GetGammaRamp </td>
          <td>(</td>
          <td class="paramtype">[In, Out] short[]&nbsp;</td>
          <td class="paramname"> <em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In, Out] short[]&nbsp;</td>
          <td class="paramname"> <em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In, Out] short[]&nbsp;</td>
          <td class="paramname"> <em>blue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the color gamma lookup tables for the display. </p>
<p>Gets the gamma translation lookup tables currently used by the display. Each table is an array of 256 short values. </p>
<p>You must pass in valid pointers to arrays of 256 16-bit quantities. Any of the pointers may be NULL to ignore that channel.  </p>
<p>Not all display hardware is able to change gamma.  </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#ae357d10a1961d2760a67332622c788ac" title="Gets the color gamma lookup tables for the display.">SDL_GetGammaRamp</a>(Uint16 *<a class="code" href="_sdl_8cs.html#a42c3a4a0281e61ee592e36a3eda020f2">red</a>, Uint16 *<a class="code" href="_sdl_8cs.html#ad83fb941855ba7c4aa2bb65245437777">green</a>, Uint16 *<a class="code" href="_sdl_8cs.html#aa6074166cc77c18081343a82d3af99bf">blue</a>)
</pre></div> <dl class="return"><dt><b>Returns:</b></dt><dd>If the call succeeds, it will return 0. If the display driver or hardware does not support gamma translation, or otherwise fails, this function will return -1. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aec2c6c149b3567ffb29ff86bc202b43f" title="Set the gamma correction for each of the color channels.">SDL_SetGamma</a></dd></dl>
<p>SDL_SetGamma</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#add53fba5948db676ea3988e8d8b040cf" title="Set the gamma translation table for the red, green, and blue channels of the video hardware...">SDL_SetGammaRamp</a></dd></dl>
<p>SDL_SetGammaRamp</p>

</div>
</div>
<a class="anchor" id="a50624f7a015f51e780d18ad711168f39"></a><!-- doxytag: member="Sdl.cs::SDL_GetGammaRamp" ref="a50624f7a015f51e780d18ad711168f39" args="([In, Out] ushort[] red,[In, Out] ushort[] green,[In, Out] ushort[] blue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_GetGammaRamp </td>
          <td>(</td>
          <td class="paramtype">[In, Out] ushort[]&nbsp;</td>
          <td class="paramname"> <em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In, Out] ushort[]&nbsp;</td>
          <td class="paramname"> <em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In, Out] ushort[]&nbsp;</td>
          <td class="paramname"> <em>blue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the color gamma lookup tables for the display. </p>
<p>Gets the gamma translation lookup tables currently used by the display. Each table is an array of 256 short values. </p>
<p>You must pass in valid pointers to arrays of 256 16-bit quantities. Any of the pointers may be NULL to ignore that channel.  </p>
<p>Not all display hardware is able to change gamma.  </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#ae357d10a1961d2760a67332622c788ac" title="Gets the color gamma lookup tables for the display.">SDL_GetGammaRamp</a>(Uint16 *red, Uint16 *green, Uint16 *blue)
</pre></div> <dl class="return"><dt><b>Returns:</b></dt><dd>If the call succeeds, it will return 0. If the display driver or hardware does not support gamma translation, or otherwise fails, this function will return -1. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aec2c6c149b3567ffb29ff86bc202b43f" title="Set the gamma correction for each of the color channels.">SDL_SetGamma</a></dd></dl>
<p>SDL_SetGamma</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#add53fba5948db676ea3988e8d8b040cf" title="Set the gamma translation table for the red, green, and blue channels of the video hardware...">SDL_SetGammaRamp</a></dd></dl>
<p>SDL_SetGammaRamp</p>

</div>
</div>
<a class="anchor" id="a8159db05cf68eb62d668e7c4bb8536b1"></a><!-- doxytag: member="Sdl.cs::SDL_GetKeyRepeat" ref="a8159db05cf68eb62d668e7c4bb8536b1" args="(out int rate, out int delay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_GetKeyRepeat </td>
          <td>(</td>
          <td class="paramtype">out int&nbsp;</td>
          <td class="paramname"> <em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out int&nbsp;</td>
          <td class="paramname"> <em>delay</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get keyboard repeat rate. </p>
<p>Gets the keyboard repeat rate. delay specifies how long the key must be pressed before it begins repeating, it then repeats at the speed specified by interval. Both delay and interval are expressed in milliseconds. </p>
<p>Setting delay to 0 disables key repeating completely. Good default values are SDL_DEFAULT_REPEAT_DELAY and SDL_DEFAULT_REPEAT_INTERVAL. p&gt;Binds to C-function in SDL_keyboard.h code&gt;int SDL_GetKeyRepeat(int delay, int interval); /code&gt;</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rate</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delay</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 on success and -1 on failure.</dd></dl>

</div>
</div>
<a class="anchor" id="acf4ace37b9b7f9383221e52a5b2113c3"></a><!-- doxytag: member="Sdl.cs::SDL_GetModState" ref="acf4ace37b9b7f9383221e52a5b2113c3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_GetModState </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the state of modifier keys. </p>
<p>Returns the current state of the modifier keys (CTRL, ALT, etc.). </p>
<p>Binds to C-function in SDL_keyboard.h </p>
<div class="fragment"><pre class="fragment">SDLMod <a class="code" href="_sdl_8cs.html#acf4ace37b9b7f9383221e52a5b2113c3" title="Get the state of modifier keys.">SDL_GetModState</a>(<span class="keywordtype">void</span>)
</pre></div><dl class="return"><dt><b>Returns:</b></dt><dd>The return value can be an OR'd combination of the SDLMod enum. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>SDL_GetKeyState</dd></dl>

</div>
</div>
<a class="anchor" id="a5f331fd789dbcc61437a6fe406b4454f"></a><!-- doxytag: member="Sdl.cs::SDL_GetMouseState" ref="a5f331fd789dbcc61437a6fe406b4454f" args="(out int x, out int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static byte SDL_GetMouseState </td>
          <td>(</td>
          <td class="paramtype">out int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out int&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the current state of the mouse. </p>
<p>The current button state is returned as a button bitmask, w hich can be tested using the SDL_BUTTON(X) macros, and x and y are set to the current mouse cursor position. You can pass NULL for either x or y. </p>
<p>Binds to C-function call in SDL_mouse.h: </p>
<div class="fragment"><pre class="fragment">            Uint8 <a class="code" href="_sdl_8cs.html#a5f331fd789dbcc61437a6fe406b4454f" title="Retrieve the current state of the mouse.">SDL_GetMouseState</a>(<span class="keywordtype">int</span> *x, <span class="keywordtype">int</span> *y)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<div class="fragment"><pre class="fragment">            <a class="code" href="_sdl_8cs.html#aa58333f760b728cd8f56bbdbc8a6104e" title="Pumps the event loop, gathering events from the input devices.">SDL_PumpEvents</a>();
                        <span class="keywordflow">if</span>(<a class="code" href="_sdl_8cs.html#a5f331fd789dbcc61437a6fe406b4454f" title="Retrieve the current state of the mouse.">SDL_GetMouseState</a>(NULL, NULL)&amp;amp;SDL_BUTTON(1))
                        <a class="code" href="_sdl_8cs.html#acf16cb12f21e38e5544fbe0f6a0869d6">printf</a>(<span class="stringliteral">&quot;Mouse Button 1(left) is pressed.\n&quot;</span>);
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a33fff3abfc66a4ed0344cb16d47bc92f" title="Retrieve the current state of the mouse.">SDL_GetRelativeMouseState</a>, <a class="el" href="_sdl_8cs.html#aa58333f760b728cd8f56bbdbc8a6104e" title="Pumps the event loop, gathering events from the input devices.">SDL_PumpEvents</a></dd></dl>

</div>
</div>
<a class="anchor" id="a33fff3abfc66a4ed0344cb16d47bc92f"></a><!-- doxytag: member="Sdl.cs::SDL_GetRelativeMouseState" ref="a33fff3abfc66a4ed0344cb16d47bc92f" args="(out int x, out int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static byte SDL_GetRelativeMouseState </td>
          <td>(</td>
          <td class="paramtype">out int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out int&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the current state of the mouse. </p>
<p>The current button state is returned as a button bitmask, which can be tested using the SDL_BUTTON(X) macros, and x and y are set to the change in the mouse position since the last call to SDL_GetRelativeMouseState or since event initialization. You can pass NULL for either x or y. </p>
<p>Binds to C-function call in SDL_mouse.h: </p>
<div class="fragment"><pre class="fragment">            Uint8 <a class="code" href="_sdl_8cs.html#a33fff3abfc66a4ed0344cb16d47bc92f" title="Retrieve the current state of the mouse.">SDL_GetRelativeMouseState</a>(<span class="keywordtype">int</span> *x, <span class="keywordtype">int</span> *y);
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current button state is returned as a button bitmask </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a5f331fd789dbcc61437a6fe406b4454f" title="Retrieve the current state of the mouse.">SDL_GetMouseState</a></dd></dl>

</div>
</div>
<a class="anchor" id="afff8f7111c4869f62dae87b04400b54d"></a><!-- doxytag: member="Sdl.cs::SDL_GetRGB" ref="afff8f7111c4869f62dae87b04400b54d" args="(int pixel, IntPtr fmt, out byte r, out byte g, out byte b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_GetRGB </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pixel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out byte&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out byte&nbsp;</td>
          <td class="paramname"> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out byte&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get RGB values from a pixel in the specified pixel format. </p>
<p>Get RGB component values from a pixel stored in the specified pixel format. </p>
<p>This function uses the entire 8-bit [0..255] range when converting color components from pixel formats with less than 8-bits per RGB component (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff, 0xff, 0xff] not [0xf8, 0xfc, 0xf8]). </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="_sdl_8cs.html#afff8f7111c4869f62dae87b04400b54d" title="Get RGB values from a pixel in the specified pixel format.">SDL_GetRGB</a>(Uint32 <a class="code" href="_sdl_8cs.html#a36392890a1aba4cacbe1cad263a699f0">pixel</a>, <a class="code" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a> *fmt, Uint8 *r, Uint8 *g, Uint8 *b);
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pixel</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fmt</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a283f1dfcfccd35773f6f236a7c021033" title="Get RGBA values from a pixel in the specified pixel format.">SDL_GetRGBA</a></dd></dl>
<p>SDL_GetRGBA</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a8c6c5785c9010c08364e8abcd34648a0" title="Map a RGB color value to a pixel format.">SDL_MapRGB</a></dd></dl>
<p>SDL_MapRGB</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aadad00b884d9cab5dcfc16b887963bb3" title="Map a RGBA color value to a pixel format.">SDL_MapRGBA</a></dd></dl>
<p>SDL_MapRGBA</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a></dd></dl>
<p><a class="el" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a></p>

</div>
</div>
<a class="anchor" id="a62adb9364b5184962677f5231652c59c"></a><!-- doxytag: member="Sdl.cs::SDL_GetRGB" ref="a62adb9364b5184962677f5231652c59c" args="(uint pixel, IntPtr fmt, out byte r, out byte g, out byte b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_GetRGB </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>pixel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out byte&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out byte&nbsp;</td>
          <td class="paramname"> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out byte&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get RGB values from a pixel in the specified pixel format. </p>
<p>Get RGB component values from a pixel stored in the specified pixel format. </p>
<p>This function uses the entire 8-bit [0..255] range when converting color components from pixel formats with less than 8-bits per RGB component (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff, 0xff, 0xff] not [0xf8, 0xfc, 0xf8]). </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="_sdl_8cs.html#afff8f7111c4869f62dae87b04400b54d" title="Get RGB values from a pixel in the specified pixel format.">SDL_GetRGB</a>(Uint32 <a class="code" href="_sdl_8cs.html#a36392890a1aba4cacbe1cad263a699f0">pixel</a>, <a class="code" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a> *fmt, Uint8 *r, Uint8 *g, Uint8 *b);
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pixel</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fmt</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a283f1dfcfccd35773f6f236a7c021033" title="Get RGBA values from a pixel in the specified pixel format.">SDL_GetRGBA</a></dd></dl>
<p>SDL_GetRGBA</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a8c6c5785c9010c08364e8abcd34648a0" title="Map a RGB color value to a pixel format.">SDL_MapRGB</a></dd></dl>
<p>SDL_MapRGB</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aadad00b884d9cab5dcfc16b887963bb3" title="Map a RGBA color value to a pixel format.">SDL_MapRGBA</a></dd></dl>
<p>SDL_MapRGBA</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a></dd></dl>
<p><a class="el" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a></p>

</div>
</div>
<a class="anchor" id="a283f1dfcfccd35773f6f236a7c021033"></a><!-- doxytag: member="Sdl.cs::SDL_GetRGBA" ref="a283f1dfcfccd35773f6f236a7c021033" args="(int pixel, IntPtr fmt, out byte r, out byte g, out byte b, out byte a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_GetRGBA </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pixel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out byte&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out byte&nbsp;</td>
          <td class="paramname"> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out byte&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out byte&nbsp;</td>
          <td class="paramname"> <em>a</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get RGBA values from a pixel in the specified pixel format. </p>
<p>Get RGBA component values from a pixel stored in the specified pixel format. </p>
<p>This function uses the entire 8-bit [0..255] range when converting color components from pixel formats with less than 8-bits per RGB component (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff, 0xff, 0xff] not [0xf8, 0xfc, 0xf8]). </p>
<p>If the surface has no alpha component, the alpha will be returned as 0xff (100% opaque). </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="_sdl_8cs.html#a283f1dfcfccd35773f6f236a7c021033" title="Get RGBA values from a pixel in the specified pixel format.">SDL_GetRGBA</a>(Uint32 <a class="code" href="_sdl_8cs.html#a36392890a1aba4cacbe1cad263a699f0">pixel</a>, <a class="code" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a> *fmt, Uint8 *r, Uint8 *g, Uint8 *b, Uint8 *a)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pixel</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fmt</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#afff8f7111c4869f62dae87b04400b54d" title="Get RGB values from a pixel in the specified pixel format.">SDL_GetRGB(int, IntPtr, out byte, out byte, out byte)</a></dd></dl>
<p>SDL_GetRGB</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a8c6c5785c9010c08364e8abcd34648a0" title="Map a RGB color value to a pixel format.">SDL_MapRGB</a></dd></dl>
<p>SDL_MapRGB</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aadad00b884d9cab5dcfc16b887963bb3" title="Map a RGBA color value to a pixel format.">SDL_MapRGBA</a></dd></dl>
<p>SDL_MapRGBA</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a></dd></dl>
<p><a class="el" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a></p>

</div>
</div>
<a class="anchor" id="a3f22e9f294be574d51c6397cec5cfbc3"></a><!-- doxytag: member="Sdl.cs::SDL_GetThreadID" ref="a3f22e9f294be574d51c6397cec5cfbc3" args="(IntPtr thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_GetThreadID </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>thread</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the 32-bit thread identifier for the specified thread, equivalent to <a class="el" href="_sdl_8cs.html#a4b5bdffdeb7867e252b6272b4aee0964" title="Get the 32-bit thread identifier for the current thread.">SDL_ThreadID()</a> if the specified thread is NULL. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>ID </dd></dl>
<p>Binds to C-function call in SDL_thread.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC Uint32 SDLCALL <a class="code" href="_sdl_8cs.html#a3f22e9f294be574d51c6397cec5cfbc3" title="Get the 32-bit thread identifier for the specified thread, equivalent to SDL_ThreadID() if the specif...">SDL_GetThreadID</a>(SDL_Thread *thread)
</pre></div>  
</div>
</div>
<a class="anchor" id="acafb269385363a2029e9765e6bdffe79"></a><!-- doxytag: member="Sdl.cs::SDL_GetTicks" ref="acafb269385363a2029e9765e6bdffe79" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_GetTicks </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of milliseconds since the SDL library initialization. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of milliseconds since SDL was initialized. </dd></dl>
<p>Note that this value wraps if the program runs for more than ~49 days. </p>
<p>Binds to C-function call in SDL_timer.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC Uint32 SDLCALL <a class="code" href="_sdl_8cs.html#acafb269385363a2029e9765e6bdffe79" title="Get the number of milliseconds since the SDL library initialization.">SDL_GetTicks</a>(<span class="keywordtype">void</span>)
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a71ab491dce88b1d92c008dca21b47c13" title="Wait a specified number of milliseconds before returning.">SDL_Delay(int)</a></dd></dl>

</div>
</div>
<a class="anchor" id="a016732fde2f5c8a5bf71953cc8cba10f"></a><!-- doxytag: member="Sdl.cs::SDL_GetVideoInfo" ref="a016732fde2f5c8a5bf71953cc8cba10f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_GetVideoInfo </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns a read-only pointer to information about the video hardware. </p>
<p>If this is called before <a class="el" href="_sdl_8cs.html#a961f7efdc2a7ec3860e93140853092f7" title="Set up a video mode with the specified width, height and bits-per-pixel.">SDL_SetVideoMode(int, int, int, int)</a>, the 'vfmt' member of the returned structure will contain the pixel format of the "best" video mode. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keyword">const</span> <a class="code" href="struct_s_d_l___video_info.html" title="Video Target information. Useful for determining the video hardware capabilities. Not finished...">SDL_VideoInfo</a> * SDLCALL <a class="code" href="_sdl_8cs.html#a016732fde2f5c8a5bf71953cc8cba10f" title="This function returns a read-only pointer to information about the video hardware.">SDL_GetVideoInfo</a>(<span class="keywordtype">void</span>)
</pre></div> <dl class="return"><dt><b>Returns:</b></dt><dd>IntPtr to <a class="el" href="struct_s_d_l___video_info.html" title="Video Target information. Useful for determining the video hardware capabilities. Not finished...">SDL_VideoInfo</a> struct</dd></dl>
<p><a class="el" href="_sdl_8cs.html#a961f7efdc2a7ec3860e93140853092f7" title="Set up a video mode with the specified width, height and bits-per-pixel.">SDL_SetVideoMode(int, int, int, int)</a> <a class="el" href="struct_s_d_l___video_info.html" title="Video Target information. Useful for determining the video hardware capabilities. Not finished...">SDL_VideoInfo</a> </p>

</div>
</div>
<a class="anchor" id="a997bdaa5371cb303155a6195dfc5ec4b"></a><!-- doxytag: member="Sdl.cs::SDL_GetVideoSurface" ref="a997bdaa5371cb303155a6195dfc5ec4b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_GetVideoSurface </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns a pointer to the current display surface. </p>
<p>If SDL is doing format conversion on the display surface, this function returns the publicly visible surface, not the real video surface. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> * SDLCALL <a class="code" href="_sdl_8cs.html#a997bdaa5371cb303155a6195dfc5ec4b" title="This function returns a pointer to the current display surface.">SDL_GetVideoSurface</a>(<span class="keywordtype">void</span>)
</pre></div> <dl class="return"><dt><b>Returns:</b></dt><dd>It returns a pointer to a <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> struct. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></dd></dl>

</div>
</div>
<a class="anchor" id="a148bbf4aaf00821ca48734e33384a391"></a><!-- doxytag: member="Sdl.cs::SDL_GetWMInfo" ref="a148bbf4aaf00821ca48734e33384a391" args="(out Sdl.SDL_SysWMinfo_Unix info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_GetWMInfo </td>
          <td>(</td>
          <td class="paramtype">out Sdl.SDL_SysWMinfo_Unix&nbsp;</td>
          <td class="paramname"> <em>info</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gives you custom hooks into the window manager information. </p>
<p>This function gives you custom hooks into the window manager information. It fills the structure pointed to by 'info' with custom information and returns 1 if the function is implemented. If it's not implemented, or the version member of the 'info' structure is invalid, it returns 0.</p>
<p>You typically use this function like this: SDL_SysWMInfo info; SDL_VERSION(&amp;info.version); if ( SDL_GetWMInfo(&amp;info) ) { ... } </p>
<p>Binds to C-function call in SDL_rwops.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#a148bbf4aaf00821ca48734e33384a391" title="Gives you custom hooks into the window manager information.">SDL_GetWMInfo</a>(<a class="code" href="struct_s_d_l___sys_w_minfo.html" title="The generic custom window manager information structure.">SDL_SysWMinfo</a> *info)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>IntPtr to <a class="el" href="struct_s_d_l___sys_w_minfo.html" title="The generic custom window manager information structure.">SDL_SysWMinfo</a> struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>It fills the structure pointed to by 'info' with custom information and returns 1 if the function is implemented. If it's not implemented, or the version member of the 'info' structure is invalid, it returns 0. </dd></dl>

</div>
</div>
<a class="anchor" id="abcb8c598d4a92a68e5f7e0239b1a4535"></a><!-- doxytag: member="Sdl.cs::SDL_GetWMInfo" ref="abcb8c598d4a92a68e5f7e0239b1a4535" args="(out Sdl.SDL_SysWMinfo_Windows info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_GetWMInfo </td>
          <td>(</td>
          <td class="paramtype">out Sdl.SDL_SysWMinfo_Windows&nbsp;</td>
          <td class="paramname"> <em>info</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gives you custom hooks into the window manager information. </p>
<p>This function gives you custom hooks into the window manager information. It fills the structure pointed to by 'info' with custom information and returns 1 if the function is implemented. If it's not implemented, or the version member of the 'info' structure is invalid, it returns 0.</p>
<p>You typically use this function like this: SDL_SysWMInfo info; SDL_VERSION(&amp;info.version); if ( SDL_GetWMInfo(&amp;info) ) { ... } </p>
<p>Binds to C-function call in SDL_rwops.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#a148bbf4aaf00821ca48734e33384a391" title="Gives you custom hooks into the window manager information.">SDL_GetWMInfo</a>(<a class="code" href="struct_s_d_l___sys_w_minfo.html" title="The generic custom window manager information structure.">SDL_SysWMinfo</a> *info)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>IntPtr to <a class="el" href="struct_s_d_l___sys_w_minfo.html" title="The generic custom window manager information structure.">SDL_SysWMinfo</a> struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>It fills the structure pointed to by 'info' with custom information and returns 1 if the function is implemented. If it's not implemented, or the version member of the 'info' structure is invalid, it returns 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ae99456dd9bdad465541ed1550fcd20"></a><!-- doxytag: member="Sdl.cs::SDL_GetWMInfo" ref="a5ae99456dd9bdad465541ed1550fcd20" args="(out Sdl.SDL_SysWMinfo_RiscOS info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_GetWMInfo </td>
          <td>(</td>
          <td class="paramtype">out Sdl.SDL_SysWMinfo_RiscOS&nbsp;</td>
          <td class="paramname"> <em>info</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gives you custom hooks into the window manager information. </p>
<p>This function gives you custom hooks into the window manager information. It fills the structure pointed to by 'info' with custom information and returns 1 if the function is implemented. If it's not implemented, or the version member of the 'info' structure is invalid, it returns 0.</p>
<p>You typically use this function like this: SDL_SysWMInfo info; SDL_VERSION(&amp;info.version); if ( SDL_GetWMInfo(&amp;info) ) { ... } </p>
<p>Binds to C-function call in SDL_rwops.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#a148bbf4aaf00821ca48734e33384a391" title="Gives you custom hooks into the window manager information.">SDL_GetWMInfo</a>(<a class="code" href="struct_s_d_l___sys_w_minfo.html" title="The generic custom window manager information structure.">SDL_SysWMinfo</a> *info)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>IntPtr to <a class="el" href="struct_s_d_l___sys_w_minfo.html" title="The generic custom window manager information structure.">SDL_SysWMinfo</a> struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>It fills the structure pointed to by 'info' with custom information and returns 1 if the function is implemented. If it's not implemented, or the version member of the 'info' structure is invalid, it returns 0. </dd></dl>

</div>
</div>
<a class="anchor" id="add287c559391038667a6f48f36c9b4c1"></a><!-- doxytag: member="Sdl.cs::SDL_GetWMInfo" ref="add287c559391038667a6f48f36c9b4c1" args="(out Sdl.SDL_SysWMinfo info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_GetWMInfo </td>
          <td>(</td>
          <td class="paramtype">out Sdl.SDL_SysWMinfo&nbsp;</td>
          <td class="paramname"> <em>info</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gives you custom hooks into the window manager information. </p>
<p>This function gives you custom hooks into the window manager information. It fills the structure pointed to by 'info' with custom information and returns 1 if the function is implemented. If it's not implemented, or the version member of the 'info' structure is invalid, it returns 0.</p>
<p>You typically use this function like this: SDL_SysWMInfo info; SDL_VERSION(&amp;info.version); if ( SDL_GetWMInfo(&amp;info) ) { ... } </p>
<p>Binds to C-function call in SDL_rwops.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#a148bbf4aaf00821ca48734e33384a391" title="Gives you custom hooks into the window manager information.">SDL_GetWMInfo</a>(<a class="code" href="struct_s_d_l___sys_w_minfo.html" title="The generic custom window manager information structure.">SDL_SysWMinfo</a> *info)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>IntPtr to <a class="el" href="struct_s_d_l___sys_w_minfo.html" title="The generic custom window manager information structure.">SDL_SysWMinfo</a> struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>It fills the structure pointed to by 'info' with custom information and returns 1 if the function is implemented. If it's not implemented, or the version member of the 'info' structure is invalid, it returns 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a9374dd6ba66cae1acd81cdb04fdb62db"></a><!-- doxytag: member="Sdl.cs::SDL_GL_GetAttribute" ref="a9374dd6ba66cae1acd81cdb04fdb62db" args="(int attr, out int val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_GL_GetAttribute </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out int&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the value of a special SDL/OpenGL attribute. </p>
<p>Places the value of the SDL/OpenGL attribute attr into value. This is useful after a call to <a class="el" href="_sdl_8cs.html#a961f7efdc2a7ec3860e93140853092f7" title="Set up a video mode with the specified width, height and bits-per-pixel.">SDL_SetVideoMode(int, int, int, int)</a> to check whether your attributes have been <a class="el" href="">set</a> as you expected. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#a9374dd6ba66cae1acd81cdb04fdb62db" title="Get the value of a special SDL/OpenGL attribute.">SDL_GL_GetAttribute</a>(SDLGLattr attr, <span class="keywordtype">int</span> *value)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>SDL_GLattr enum</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 on success, or -1 on an error.</dd></dl>

</div>
</div>
<a class="anchor" id="af0c1ea0385d89fbb9decae290815f665"></a><!-- doxytag: member="Sdl.cs::SDL_GL_GetProcAddress" ref="af0c1ea0385d89fbb9decae290815f665" args="(string proc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_GL_GetProcAddress </td>
          <td>(</td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>proc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the address of a GL function. </p>
<p>Returns the address of the GL function proc, or NULL if the function is not found. If the GL library is loaded at runtime, with SDL_GL_LoadLibrary, then all GL functions must be retrieved this way. Usually this is used to retrieve function pointers to OpenGL extensions. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> *<a class="code" href="_sdl_8cs.html#af0c1ea0385d89fbb9decae290815f665" title="Get the address of a GL function.">SDL_GL_GetProcAddress</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* proc);
</pre></div>  <div class="fragment"><pre class="fragment">            <span class="keyword">typedef</span> void (*GL_ActiveTextureARB_Func)(<span class="keywordtype">unsigned</span> int);
                        GL_ActiveTextureARB_Func glActiveTextureARB_ptr = 0;
                        <span class="keywordtype">int</span> has_multitexture=1;
                        .
                        .
                        .
                        <span class="comment">/* Get function pointer */</span>
                        glActiveTextureARB_ptr=(GL_ActiveTextureARB_Func) <a class="code" href="_sdl_8cs.html#af0c1ea0385d89fbb9decae290815f665" title="Get the address of a GL function.">SDL_GL_GetProcAddress</a>(<span class="stringliteral">&quot;glActiveTextureARB&quot;</span>);

                        <span class="comment">/* Check for a valid function ptr */</span>
                        <span class="keywordflow">if</span>(!glActiveTextureARB_ptr)
                                {
                        fprintf(stderr, <span class="stringliteral">&quot;Multitexture Extensions not present.\n&quot;</span>);
                        has_multitexture=0;
                }
                .
                .
                .
                .
                <span class="keywordflow">if</span>(has_multitexture)
           {
                glActiveTextureARB_ptr(GL_TEXTURE0_ARB);
                .
                .
           }
                <span class="keywordflow">else</span>
           {
                .
                .
           }
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#abb5cc574ccf8709efaf0ad4ddff8a717" title="Specify an OpenGL library.">SDL_GL_LoadLibrary</a></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the address of the GL function proc, or NULL if the function is not found.</dd></dl>

</div>
</div>
<a class="anchor" id="abb5cc574ccf8709efaf0ad4ddff8a717"></a><!-- doxytag: member="Sdl.cs::SDL_GL_LoadLibrary" ref="abb5cc574ccf8709efaf0ad4ddff8a717" args="(string path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_GL_LoadLibrary </td>
          <td>(</td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify an OpenGL library. </p>
<p>If you wish, you may load the OpenGL library at runtime, this must be done before <a class="el" href="_sdl_8cs.html#a961f7efdc2a7ec3860e93140853092f7" title="Set up a video mode with the specified width, height and bits-per-pixel.">SDL_SetVideoMode(int, int, int, int)</a> is called. The path of the GL library is passed to SDL_GL_LoadLibrary and it returns 0 on success, or -1 on an error. You must then use <a class="el" href="_sdl_8cs.html#af0c1ea0385d89fbb9decae290815f665" title="Get the address of a GL function.">SDL_GL_GetProcAddress</a> to retrieve function pointers to GL functions. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#abb5cc574ccf8709efaf0ad4ddff8a717" title="Specify an OpenGL library.">SDL_GL_LoadLibrary</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *path);
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 on success, or -1 on an error.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#af0c1ea0385d89fbb9decae290815f665" title="Get the address of a GL function.">SDL_GL_GetProcAddress</a></dd></dl>

</div>
</div>
<a class="anchor" id="a9d12980991f938865faa9cc236d88825"></a><!-- doxytag: member="Sdl.cs::SDL_GL_SetAttribute" ref="a9d12980991f938865faa9cc236d88825" args="(int attr, int val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_GL_SetAttribute </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a special SDL/OpenGL attribute. </p>
<p>Sets the OpenGL attribute attr to value. The attributes you set don't take effect until after a call to <a class="el" href="_sdl_8cs.html#a961f7efdc2a7ec3860e93140853092f7" title="Set up a video mode with the specified width, height and bits-per-pixel.">SDL_SetVideoMode(int, int, int, int)</a>. You should use <a class="el" href="_sdl_8cs.html#a9374dd6ba66cae1acd81cdb04fdb62db" title="Get the value of a special SDL/OpenGL attribute.">SDL_GL_GetAttribute</a> to check the values after a SDL_SetVideoMode call. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#a9d12980991f938865faa9cc236d88825" title="Set a special SDL/OpenGL attribute.">SDL_GL_SetAttribute</a>(SDL_GLattr attr, <span class="keywordtype">int</span> value);
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>SDL_GLattr enum</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 on success, or -1 on error.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a9374dd6ba66cae1acd81cdb04fdb62db" title="Get the value of a special SDL/OpenGL attribute.">SDL_GL_GetAttribute</a></dd></dl>

</div>
</div>
<a class="anchor" id="ab8ae049692ea8e12af57ab01980dc71f"></a><!-- doxytag: member="Sdl.cs::SDL_GL_SwapBuffers" ref="ab8ae049692ea8e12af57ab01980dc71f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_GL_SwapBuffers </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap OpenGL framebuffers/Update Display. </p>
<p>Swap the OpenGL buffers, if double-buffering is supported. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="_sdl_8cs.html#ab8ae049692ea8e12af57ab01980dc71f" title="Swap OpenGL framebuffers/Update Display.">SDL_GL_SwapBuffers</a>(<span class="keywordtype">void</span> )
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a961f7efdc2a7ec3860e93140853092f7" title="Set up a video mode with the specified width, height and bits-per-pixel.">SDL_SetVideoMode(int, int, int, int)</a>, <a class="el" href="_sdl_8cs.html#a9d12980991f938865faa9cc236d88825" title="Set a special SDL/OpenGL attribute.">SDL_GL_SetAttribute</a></dd></dl>

</div>
</div>
<a class="anchor" id="a0fa370c3c28b406d12c3350d3259e8a6"></a><!-- doxytag: member="Sdl.cs::SDL_Has3DNow" ref="a0fa370c3c28b406d12c3350d3259e8a6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_Has3DNow </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns true if the CPU has 3DNow features. </p>
<p>Binds to C-function call in SDL_cpuinfo.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC SDL_bool SDLCALL SDL_SDL_Has3DNow(<span class="keywordtype">void</span>)
</pre></div> <dl class="return"><dt><b>Returns:</b></dt><dd>Returns SDL_TRUE if the CPU has 3DNow features.</dd></dl>

</div>
</div>
<a class="anchor" id="acd1a0fc77a6322d50e92dc2cb562b8f2"></a><!-- doxytag: member="Sdl.cs::SDL_HasAltiVec" ref="acd1a0fc77a6322d50e92dc2cb562b8f2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_HasAltiVec </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns true if the CPU has AltiVec features. </p>
<p>Binds to C-function call in SDL_cpuinfo.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC SDL_bool SDLCALL SDL_SDL_HasAltiVec(<span class="keywordtype">void</span>)
</pre></div> <dl class="return"><dt><b>Returns:</b></dt><dd>Returns SDL_TRUE if the CPU has AltiVec features.</dd></dl>

</div>
</div>
<a class="anchor" id="abd8f8d256dec76719b32e239455da7d9"></a><!-- doxytag: member="Sdl.cs::SDL_HasMMX" ref="abd8f8d256dec76719b32e239455da7d9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_HasMMX </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns true if the CPU has MMX features. </p>
<p>Binds to C-function call in SDL_cpuinfo.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC SDL_bool SDLCALL <a class="code" href="_sdl_8cs.html#abd8f8d256dec76719b32e239455da7d9" title="This function returns true if the CPU has MMX features.">SDL_HasMMX</a>(<span class="keywordtype">void</span>)
</pre></div> <dl class="return"><dt><b>Returns:</b></dt><dd>Returns SDL_TRUE if the CPU has MMX features.</dd></dl>

</div>
</div>
<a class="anchor" id="ab5311886cda67ed72d52e66497d6c90b"></a><!-- doxytag: member="Sdl.cs::SDL_HasMMXExt" ref="ab5311886cda67ed72d52e66497d6c90b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_HasMMXExt </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns true if the CPU has MMX Ext. features. </p>
<p>Binds to C-function call in SDL_cpuinfo.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC SDL_bool SDLCALL <a class="code" href="_sdl_8cs.html#ab5311886cda67ed72d52e66497d6c90b" title="This function returns true if the CPU has MMX Ext. features.">SDL_HasMMXExt</a>(<span class="keywordtype">void</span>)
</pre></div> <dl class="return"><dt><b>Returns:</b></dt><dd>Returns SDL_TRUE if the CPU has MMX Ext. features.</dd></dl>

</div>
</div>
<a class="anchor" id="ac2415fc258a833a1ae094bd2ff72afcc"></a><!-- doxytag: member="Sdl.cs::SDL_HasRDTSC" ref="ac2415fc258a833a1ae094bd2ff72afcc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_HasRDTSC </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns true if the CPU has the RDTSC instruction. </p>
<p>Binds to C-function call in SDL_cpuinfo.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC SDL_bool SDLCALL <a class="code" href="_sdl_8cs.html#ac2415fc258a833a1ae094bd2ff72afcc" title="This function returns true if the CPU has the RDTSC instruction.">SDL_HasRDTSC</a>(<span class="keywordtype">void</span>)
</pre></div> <dl class="return"><dt><b>Returns:</b></dt><dd>Returns SDL_TRUE if the CPU has the RDTSC instruction.</dd></dl>

</div>
</div>
<a class="anchor" id="aa4a172e7fe8167eb7bc366195c3c9434"></a><!-- doxytag: member="Sdl.cs::SDL_HasSSE" ref="aa4a172e7fe8167eb7bc366195c3c9434" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_HasSSE </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns true if the CPU has SSE features. </p>
<p>Binds to C-function call in SDL_cpuinfo.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC SDL_bool SDLCALL SDL_SDL_HasSSE(<span class="keywordtype">void</span>)
</pre></div> <dl class="return"><dt><b>Returns:</b></dt><dd>Returns SDL_TRUE if the CPU has SSE features.</dd></dl>

</div>
</div>
<a class="anchor" id="a64ad1b3756d3d35977975a16e1900941"></a><!-- doxytag: member="Sdl.cs::SDL_HasSSE2" ref="a64ad1b3756d3d35977975a16e1900941" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_HasSSE2 </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns true if the CPU has SSE2 features. </p>
<p>Binds to C-function call in SDL_cpuinfo.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC SDL_bool SDLCALL SDL_SDL_HasSSE2void()
</pre></div> <dl class="return"><dt><b>Returns:</b></dt><dd>Returns SDL_TRUE if the CPU has SSE2 features.</dd></dl>

</div>
</div>
<a class="anchor" id="a57539dd46dc1b92fd1d1128b23e0b217"></a><!-- doxytag: member="Sdl.cs::SDL_JoystickClose" ref="a57539dd46dc1b92fd1d1128b23e0b217" args="(IntPtr joystick)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_JoystickClose </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>joystick</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes a previously opened joystick. </p>
<p>Close a joystick that was previously opened with <a class="el" href="_sdl_8cs.html#a1884e3601e7aa306d7b2e27884c16504" title="Open a joystick for use.">SDL_JoystickOpen</a>. </p>
<p>Binds to C-function in SDL_joystick.h </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="_sdl_8cs.html#a57539dd46dc1b92fd1d1128b23e0b217" title="Closes a previously opened joystick.">SDL_JoystickClose</a>(SDL_Joystick *joystick);
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>joystick</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a1884e3601e7aa306d7b2e27884c16504" title="Open a joystick for use.">SDL_JoystickOpen</a>, <a class="el" href="_sdl_8cs.html#a94f97c445e859cd7dd799f103cdf3eaa" title="Determine if a joystick has been opened.">SDL_JoystickOpened</a></dd></dl>

</div>
</div>
<a class="anchor" id="a4b5786d792bade406949c738f0290eca"></a><!-- doxytag: member="Sdl.cs::SDL_JoystickEventState" ref="a4b5786d792bade406949c738f0290eca" args="(int state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_JoystickEventState </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>state</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable/disable joystick event polling. </p>
<p>This function is used to enable or disable joystick event processing. With joystick event processing disabled you will have to update joystick states with SDL_JoystickUpdate and read the joystick information manually. state is either SDL_QUERY, SDL_ENABLE or SDL_IGNORE. </p>
<p>Note: Joystick event handling is preferred  </p>
<p>Binds to C-function in SDL_joystick.h </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#a4b5786d792bade406949c738f0290eca" title="Enable/disable joystick event polling.">SDL_JoystickEventState</a>(<span class="keywordtype">int</span> state)
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a1884e3601e7aa306d7b2e27884c16504" title="Open a joystick for use.">SDL_JoystickOpen</a>, <a class="el" href="_sdl_8cs.html#ab46ed3af900d20b62a7aa26570ecdff8" title="Get the current state of a given button on a given joystick.">SDL_JoystickGetButton</a>, <a class="el" href="_sdl_8cs.html#a37f3184ae17e4de28a75b8f2fdda592b" title="Updates the state of all joysticks.">SDL_JoystickUpdate</a>, SDL_JoyAxisEvent, SDL_JoyBallEvent, SDL_JoyButtonEvent, SDL_JoyHatEvent</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If state is SDL_QUERY then the current state is returned, otherwise the new processing state is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ab6c4b492ca0368f81c3aef8c49ebf21d"></a><!-- doxytag: member="Sdl.cs::SDL_JoystickGetAxis" ref="ab6c4b492ca0368f81c3aef8c49ebf21d" args="(IntPtr joystick, int axis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static short SDL_JoystickGetAxis </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>joystick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>axis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current state of an axis. </p>
<p>SDL_JoystickGetAxis returns the current state of the given axis on the given joystick. </p>
<p>On most modern joysticks the X axis is usually represented by axis 0 and the Y axis by axis 1. The value returned by SDL_JoystickGetAxis is a signed integer (-32768 to 32768) representing the current position of the axis, it maybe necessary to impose certain tolerances on these values to account for jitter. It is worth noting that some joysticks use axes 2 and 3 for extra buttons. </p>
<p>Binds to C-function in SDL_joystick.h </p>
<div class="fragment"><pre class="fragment">Sint16 <a class="code" href="_sdl_8cs.html#ab6c4b492ca0368f81c3aef8c49ebf21d" title="Get the current state of an axis.">SDL_JoystickGetAxis</a>(SDL_Joystick *joystick, <span class="keywordtype">int</span> axis);
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>joystick</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>axis</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a short representing the current position of the axis. </dd></dl>
<div class="fragment"><pre class="fragment">            Sint16 x_move, y_move;
                        SDL_Joystick *joy1;
                        .
                        .
                        x_move=<a class="code" href="_sdl_8cs.html#ab6c4b492ca0368f81c3aef8c49ebf21d" title="Get the current state of an axis.">SDL_JoystickGetAxis</a>(joy1, 0);
                        y_move=<a class="code" href="_sdl_8cs.html#ab6c4b492ca0368f81c3aef8c49ebf21d" title="Get the current state of an axis.">SDL_JoystickGetAxis</a>(joy1, 1);
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a80e04d0de1e40862a97c1851329bf360" title="Get the number of joystick axes.">SDL_JoystickNumAxes</a></dd></dl>

</div>
</div>
<a class="anchor" id="ac507b201a80334bc2e9a62ba44d8534b"></a><!-- doxytag: member="Sdl.cs::SDL_JoystickGetBall" ref="ac507b201a80334bc2e9a62ba44d8534b" args="(IntPtr joystick, int ball, out int dx, out int dy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_JoystickGetBall </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>joystick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ball</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out int&nbsp;</td>
          <td class="paramname"> <em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out int&nbsp;</td>
          <td class="paramname"> <em>dy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get relative trackball motion. </p>
<p>Get the ball axis change. </p>
<p>Trackballs can only return relative motion since the last call to SDL_JoystickGetBall, these motion deltas a placed into dx and dy.  </p>
<p>Binds to C-function in SDL_joystick.h </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#ac507b201a80334bc2e9a62ba44d8534b" title="Get relative trackball motion.">SDL_JoystickGetBall</a>(SDL_Joystick *joystick, <span class="keywordtype">int</span> ball, <span class="keywordtype">int</span> *dx, <span class="keywordtype">int</span> *dy);
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>joystick</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ball</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dx</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dy</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 on success or -1 on failure </dd></dl>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">int</span> delta_x, delta_y;
                        SDL_Joystick *joy;
                        .
                        .
                        .
                        <a class="code" href="_sdl_8cs.html#a37f3184ae17e4de28a75b8f2fdda592b" title="Updates the state of all joysticks.">SDL_JoystickUpdate</a>();
                        <span class="keywordflow">if</span>(<a class="code" href="_sdl_8cs.html#ac507b201a80334bc2e9a62ba44d8534b" title="Get relative trackball motion.">SDL_JoystickGetBall</a>(joy, 0, &amp;amp;delta_x, &amp;amp;delta_y)==-1)
                        <a class="code" href="_sdl_8cs.html#acf16cb12f21e38e5544fbe0f6a0869d6">printf</a>(<span class="stringliteral">&quot;TrackBall Read Error!\n&quot;</span>);
                        <a class="code" href="_sdl_8cs.html#acf16cb12f21e38e5544fbe0f6a0869d6">printf</a>(<span class="stringliteral">&quot;Trackball Delta- X:%d, Y:%d\n&quot;</span>, delta_x, delta_y);
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#ac3a30f56273e3f2919bb2db0e9770929" title="Get the number of joystick trackballs.">SDL_JoystickNumBalls</a></dd></dl>

</div>
</div>
<a class="anchor" id="ab46ed3af900d20b62a7aa26570ecdff8"></a><!-- doxytag: member="Sdl.cs::SDL_JoystickGetButton" ref="ab46ed3af900d20b62a7aa26570ecdff8" args="(IntPtr joystick, int button)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static byte SDL_JoystickGetButton </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>joystick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>button</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current state of a given button on a given joystick. </p>
<p>SDL_JoystickGetButton returns the current state of the given button on the given joystick. </p>
<p>Binds to C-function in SDL_joystick.h </p>
<div class="fragment"><pre class="fragment">Uint8 <a class="code" href="_sdl_8cs.html#ab46ed3af900d20b62a7aa26570ecdff8" title="Get the current state of a given button on a given joystick.">SDL_JoystickGetButton</a>(SDL_Joystick *joystick, <span class="keywordtype">int</span> button);
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>joystick</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>button</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the button is pressed. Otherwise, 0. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a059acbc1523b7994d3882d4fbb8e20ff" title="Get the number of joystick buttons.">SDL_JoystickNumButtons</a></dd></dl>

</div>
</div>
<a class="anchor" id="aa92ba2b7e2f685e0fe7587b73cbd8f22"></a><!-- doxytag: member="Sdl.cs::SDL_JoystickGetHat" ref="aa92ba2b7e2f685e0fe7587b73cbd8f22" args="(IntPtr joystick, int hat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static byte SDL_JoystickGetHat </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>joystick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>hat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current state of a joystick hat. </p>
<p>SDL_JoystickGetHat returns the current state of the given hat on the given joystick. </p>
<p>Binds to C-function in SDL_joystick.h </p>
<div class="fragment"><pre class="fragment">Uint8 <a class="code" href="_sdl_8cs.html#aa92ba2b7e2f685e0fe7587b73cbd8f22" title="Get the current state of a joystick hat.">SDL_JoystickGetHat</a>(SDL_Joystick *joystick, <span class="keywordtype">int</span> hat)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>joystick</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hat</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current state is returned as a byte which is defined as an OR'd combination of one or more of the following: <div class="fragment"><pre class="fragment">            SDL_HAT_CENTERED 
                SDL_HAT_UP 
                SDL_HAT_RIGHT 
                SDL_HAT_DOWN 
                SDL_HAT_LEFT 
                SDL_HAT_RIGHTUP 
                SDL_HAT_RIGHTDOWN 
                SDL_HAT_LEFTUP 
            SDL_HAT_LEFTDOWN 
</pre></div> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a41286db94e72dd658f4e394843ccd994" title="Get the number of joystick hats.">SDL_JoystickNumHats</a></dd></dl>

</div>
</div>
<a class="anchor" id="a71323f226d822778a13e1a91448e185c"></a><!-- doxytag: member="Sdl.cs::SDL_JoystickIndex" ref="a71323f226d822778a13e1a91448e185c" args="(IntPtr joystick)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_JoystickIndex </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>joystick</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the index of an SDL_Joystick. </p>
<p>Returns the index of a given SDL_Joystick structure. </p>
<p>Binds to C-function in SDL_joystick.h </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#a71323f226d822778a13e1a91448e185c" title="Get the index of an SDL_Joystick.">SDL_JoystickIndex</a>(SDL_Joystick *joystick)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>joystick</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Index number of the joystick. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a1884e3601e7aa306d7b2e27884c16504" title="Open a joystick for use.">SDL_JoystickOpen</a></dd></dl>

</div>
</div>
<a class="anchor" id="a80e04d0de1e40862a97c1851329bf360"></a><!-- doxytag: member="Sdl.cs::SDL_JoystickNumAxes" ref="a80e04d0de1e40862a97c1851329bf360" args="(IntPtr joystick)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_JoystickNumAxes </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>joystick</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of joystick axes. </p>
<p>Return the number of axes available from a previously opened SDL_Joystick. </p>
<p>Binds to C-function in SDL_joystick.h </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#a80e04d0de1e40862a97c1851329bf360" title="Get the number of joystick axes.">SDL_JoystickNumAxes</a>(SDL_Joystick *joystick)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>joystick</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of axes. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a1884e3601e7aa306d7b2e27884c16504" title="Open a joystick for use.">SDL_JoystickOpen</a>, <a class="el" href="_sdl_8cs.html#ab6c4b492ca0368f81c3aef8c49ebf21d" title="Get the current state of an axis.">SDL_JoystickGetAxis</a></dd></dl>

</div>
</div>
<a class="anchor" id="ac3a30f56273e3f2919bb2db0e9770929"></a><!-- doxytag: member="Sdl.cs::SDL_JoystickNumBalls" ref="ac3a30f56273e3f2919bb2db0e9770929" args="(IntPtr joystick)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_JoystickNumBalls </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>joystick</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of joystick trackballs. </p>
<p>Return the number of trackballs available from a previously opened SDL_Joystick. </p>
<p>Binds to C-function in SDL_joystick.h </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#ac3a30f56273e3f2919bb2db0e9770929" title="Get the number of joystick trackballs.">SDL_JoystickNumBalls</a>(SDL_Joystick *joystick)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>joystick</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of trackballs. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a1884e3601e7aa306d7b2e27884c16504" title="Open a joystick for use.">SDL_JoystickOpen</a>, <a class="el" href="_sdl_8cs.html#ac507b201a80334bc2e9a62ba44d8534b" title="Get relative trackball motion.">SDL_JoystickGetBall</a></dd></dl>

</div>
</div>
<a class="anchor" id="a059acbc1523b7994d3882d4fbb8e20ff"></a><!-- doxytag: member="Sdl.cs::SDL_JoystickNumButtons" ref="a059acbc1523b7994d3882d4fbb8e20ff" args="(IntPtr joystick)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_JoystickNumButtons </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>joystick</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of joystick buttons. </p>
<p>Return the number of buttons available from a previously opened SDL_Joystick. </p>
<p>Binds to C-function in SDL_joystick.h </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#a059acbc1523b7994d3882d4fbb8e20ff" title="Get the number of joystick buttons.">SDL_JoystickNumButtons</a>(SDL_Joystick *joystick)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>joystick</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of buttons. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a1884e3601e7aa306d7b2e27884c16504" title="Open a joystick for use.">SDL_JoystickOpen</a>, <a class="el" href="_sdl_8cs.html#ab46ed3af900d20b62a7aa26570ecdff8" title="Get the current state of a given button on a given joystick.">SDL_JoystickGetButton</a></dd></dl>

</div>
</div>
<a class="anchor" id="a41286db94e72dd658f4e394843ccd994"></a><!-- doxytag: member="Sdl.cs::SDL_JoystickNumHats" ref="a41286db94e72dd658f4e394843ccd994" args="(IntPtr joystick)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_JoystickNumHats </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>joystick</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of joystick hats. </p>
<p>Binds to C-function in SDL_joystick.h </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#a41286db94e72dd658f4e394843ccd994" title="Get the number of joystick hats.">SDL_JoystickNumHats</a>(SDL_Joystick *joystick);
</pre></div><p>Return the number of hats available from a previously opened SDL_Joystick. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>joystick</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of hats. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a1884e3601e7aa306d7b2e27884c16504" title="Open a joystick for use.">SDL_JoystickOpen</a>, <a class="el" href="_sdl_8cs.html#aa92ba2b7e2f685e0fe7587b73cbd8f22" title="Get the current state of a joystick hat.">SDL_JoystickGetHat</a></dd></dl>

</div>
</div>
<a class="anchor" id="a1884e3601e7aa306d7b2e27884c16504"></a><!-- doxytag: member="Sdl.cs::SDL_JoystickOpen" ref="a1884e3601e7aa306d7b2e27884c16504" args="(int device_index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_JoystickOpen </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>device_index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a joystick for use. </p>
<p>Opens a joystick for use within SDL. The index refers to the N'th joystick in the system. A joystick must be opened before it game be used. </p>
<p>Binds to C-function in SDL_joystick.h </p>
<div class="fragment"><pre class="fragment"></pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>device_index</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a IntPtr to a SDL_Joystick structure on success. NULL on failure. </dd></dl>
<div class="fragment"><pre class="fragment">            SDL_Joystick *joy;
            Check <span class="keywordflow">for</span> joystick
                        <span class="keywordflow">if</span>(<a class="code" href="_sdl_8cs.html#a4b02c05e1ac0903e32c86f0702140a78" title="Count the number of joysticks attached to the system.">SDL_NumJoysticks</a>()&gt;0)
                {
                        <span class="comment">// Open joystick</span>
                        joy=<a class="code" href="_sdl_8cs.html#a1884e3601e7aa306d7b2e27884c16504" title="Open a joystick for use.">SDL_JoystickOpen</a>(0);

                        <span class="keywordflow">if</span>(joy)
                {
                        <a class="code" href="_sdl_8cs.html#acf16cb12f21e38e5544fbe0f6a0869d6">printf</a>(<span class="stringliteral">&quot;Opened Joystick 0\n&quot;</span>);
                        <a class="code" href="_sdl_8cs.html#acf16cb12f21e38e5544fbe0f6a0869d6">printf</a>(<span class="stringliteral">&quot;Name: %s\n&quot;</span>, SDL_JoystickName(0));
                        <a class="code" href="_sdl_8cs.html#acf16cb12f21e38e5544fbe0f6a0869d6">printf</a>(<span class="stringliteral">&quot;Number of Axes: %d\n&quot;</span>, <a class="code" href="_sdl_8cs.html#a80e04d0de1e40862a97c1851329bf360" title="Get the number of joystick axes.">SDL_JoystickNumAxes</a>(joy));
                        <a class="code" href="_sdl_8cs.html#acf16cb12f21e38e5544fbe0f6a0869d6">printf</a>(<span class="stringliteral">&quot;Number of Buttons: %d\n&quot;</span>, <a class="code" href="_sdl_8cs.html#a059acbc1523b7994d3882d4fbb8e20ff" title="Get the number of joystick buttons.">SDL_JoystickNumButtons</a>(joy));
                        <a class="code" href="_sdl_8cs.html#acf16cb12f21e38e5544fbe0f6a0869d6">printf</a>(<span class="stringliteral">&quot;Number of Balls: %d\n&quot;</span>, <a class="code" href="_sdl_8cs.html#ac3a30f56273e3f2919bb2db0e9770929" title="Get the number of joystick trackballs.">SDL_JoystickNumBalls</a>(joy));
                }
                <span class="keywordflow">else</span>
                <a class="code" href="_sdl_8cs.html#acf16cb12f21e38e5544fbe0f6a0869d6">printf</a>(<span class="stringliteral">&quot;Couldn&#39;t open Joystick 0\n&quot;</span>);

                <span class="comment">// Close if opened</span>
                <span class="keywordflow">if</span>(<a class="code" href="_sdl_8cs.html#a94f97c445e859cd7dd799f103cdf3eaa" title="Determine if a joystick has been opened.">SDL_JoystickOpened</a>(0))
                <a class="code" href="_sdl_8cs.html#a57539dd46dc1b92fd1d1128b23e0b217" title="Closes a previously opened joystick.">SDL_JoystickClose</a>(joy);
           }
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a57539dd46dc1b92fd1d1128b23e0b217" title="Closes a previously opened joystick.">SDL_JoystickClose</a></dd></dl>

</div>
</div>
<a class="anchor" id="a94f97c445e859cd7dd799f103cdf3eaa"></a><!-- doxytag: member="Sdl.cs::SDL_JoystickOpened" ref="a94f97c445e859cd7dd799f103cdf3eaa" args="(int device_index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_JoystickOpened </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>device_index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine if a joystick has been opened. </p>
<p>Determines whether a joystick has already been opened within the application. index refers to the N'th joystick on the system. </p>
<p>Binds to C-function in SDL_joystick.h </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#a94f97c445e859cd7dd799f103cdf3eaa" title="Determine if a joystick has been opened.">SDL_JoystickOpened</a>(<span class="keywordtype">int</span> index)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>device_index</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 1 if the joystick has been opened, or 0 if it has not. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a1884e3601e7aa306d7b2e27884c16504" title="Open a joystick for use.">SDL_JoystickOpen</a>, <a class="el" href="_sdl_8cs.html#a57539dd46dc1b92fd1d1128b23e0b217" title="Closes a previously opened joystick.">SDL_JoystickClose</a></dd></dl>

</div>
</div>
<a class="anchor" id="a37f3184ae17e4de28a75b8f2fdda592b"></a><!-- doxytag: member="Sdl.cs::SDL_JoystickUpdate" ref="a37f3184ae17e4de28a75b8f2fdda592b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_JoystickUpdate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the state of all joysticks. </p>
<p>Updates the state(position, buttons, etc.) of all open joysticks. If joystick events have been enabled with <a class="el" href="_sdl_8cs.html#a4b5786d792bade406949c738f0290eca" title="Enable/disable joystick event polling.">SDL_JoystickEventState</a> then this is called automatically in the event loop. </p>
<p>Binds to C-function in SDL_joystick.h </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="_sdl_8cs.html#a37f3184ae17e4de28a75b8f2fdda592b" title="Updates the state of all joysticks.">SDL_JoystickUpdate</a>(<span class="keywordtype">void</span>)
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a1884e3601e7aa306d7b2e27884c16504" title="Open a joystick for use.">SDL_JoystickOpen</a>, <a class="el" href="_sdl_8cs.html#ab46ed3af900d20b62a7aa26570ecdff8" title="Get the current state of a given button on a given joystick.">SDL_JoystickGetButton</a></dd></dl>

</div>
</div>
<a class="anchor" id="a3c935d9acb1768be97c494edaa628bab"></a><!-- doxytag: member="Sdl.cs::SDL_KillThread" ref="a3c935d9acb1768be97c494edaa628bab" args="(IntPtr thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_KillThread </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>thread</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Forcefully kill a thread without worrying about its state. </p>
<p>Binds to C-function call in SDL_thread.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">void</span> SDLCALL <a class="code" href="_sdl_8cs.html#a3c935d9acb1768be97c494edaa628bab" title="Forcefully kill a thread without worrying about its state.">SDL_KillThread</a>(SDL_Thread *thread)
</pre></div>  
</div>
</div>
<a class="anchor" id="a380d06edefbb8abcc0f14859fd25108c"></a><!-- doxytag: member="Sdl.cs::SDL_LoadBMP_RW" ref="a380d06edefbb8abcc0f14859fd25108c" args="(IntPtr src, int freesrc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_LoadBMP_RW </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>freesrc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a surface from a seekable SDL data source (memory or file.). </p>
<p>If 'freesrc' is non-zero, the source will be closed after being read. Returns the new surface, or NULL if there was an error. The new surface should be freed with <a class="el" href="_sdl_8cs.html#a3062b061d8f75b52d1c4887209a92c10" title="Frees (deletes) a SDL_Surface.">SDL_FreeSurface()</a>. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> * SDLCALL <a class="code" href="_sdl_8cs.html#a380d06edefbb8abcc0f14859fd25108c" title="Load a surface from a seekable SDL data source (memory or file.).">SDL_LoadBMP_RW</a>(SDL_RWops *src, <span class="keywordtype">int</span> freesrc)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>IntPtr to <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freesrc</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aea95d437c48a63fc2b057278ab0b9c69"></a><!-- doxytag: member="Sdl.cs::SDL_LoadFunction" ref="aea95d437c48a63fc2b057278ab0b9c69" args="(IntPtr handle, string name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_LoadFunction </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given an object handle, this function looks up the address of the named function in the shared object and returns it. This address is no longer valid after calling <a class="el" href="_sdl_8cs.html#a39ec0a82df272b96dec07e31b7da403a" title="Unload a shared object from memory.">SDL_UnloadObject()</a>. </p>
<p>Binds to C-function in SDL_loadso.h </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">void</span> * SDLCALL <a class="code" href="_sdl_8cs.html#aea95d437c48a63fc2b057278ab0b9c69" title="Given an object handle, this function looks up the address of the named function in the shared object...">SDL_LoadFunction</a>(<span class="keywordtype">void</span> *handle, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Object handle</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of function in the shared object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#adf86ae9120ae0ea0fb602dfa34401edc" title="This function dynamically loads a shared object and returns a pointer to the object handle (or NULL i...">SDL_LoadObject</a>, <a class="el" href="_sdl_8cs.html#a39ec0a82df272b96dec07e31b7da403a" title="Unload a shared object from memory.">SDL_UnloadObject</a></dd></dl>

</div>
</div>
<a class="anchor" id="adf86ae9120ae0ea0fb602dfa34401edc"></a><!-- doxytag: member="Sdl.cs::SDL_LoadObject" ref="adf86ae9120ae0ea0fb602dfa34401edc" args="(string sofile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_LoadObject </td>
          <td>(</td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>sofile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function dynamically loads a shared object and returns a pointer to the object handle (or NULL if there was an error). </p>
<p>Binds to C-function in SDL_loadso.h </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">void</span> * SDLCALL <a class="code" href="_sdl_8cs.html#adf86ae9120ae0ea0fb602dfa34401edc" title="This function dynamically loads a shared object and returns a pointer to the object handle (or NULL i...">SDL_LoadObject</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *sofile)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sofile</em>&nbsp;</td><td>System dependent name of the object file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aea95d437c48a63fc2b057278ab0b9c69" title="Given an object handle, this function looks up the address of the named function in the shared object...">SDL_LoadFunction</a>, <a class="el" href="_sdl_8cs.html#a39ec0a82df272b96dec07e31b7da403a" title="Unload a shared object from memory.">SDL_UnloadObject</a></dd></dl>

</div>
</div>
<a class="anchor" id="a4b1642f748d1819ccb0d085a5c243c81"></a><!-- doxytag: member="Sdl.cs::SDL_LoadWAV_RW" ref="a4b1642f748d1819ccb0d085a5c243c81" args="(IntPtr src, int freesrc, out IntPtr spec, out IntPtr audio_buf, out uint audio_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_LoadWAV_RW </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>freesrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&nbsp;</td>
          <td class="paramname"> <em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&nbsp;</td>
          <td class="paramname"> <em>audio_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out uint&nbsp;</td>
          <td class="paramname"> <em>audio_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function loads a WAVE from the data source, automatically freeing that source if 'freesrc' is non-zero. For example, to load a WAVE file, you could do: SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, ...);. </p>
<p>If this function succeeds, it returns the given SDL_AudioSpec, filled with the audio data format of the wave data, and sets 'audio_buf' to a malloc()'d buffer containing the audio data, and sets 'audio_len' to the length of that audio buffer, in bytes. You need to free the audio buffer with <a class="el" href="_sdl_8cs.html#aa59c06f2223e64f2b5f74b82625dd43f" title="Frees previously opened WAV data.">SDL_FreeWAV()</a> when you are done with it. </p>
<p>This function returns NULL and sets the SDL error message if the wave file cannot be opened, uses an unknown data format, or is corrupt. Currently raw and MS-ADPCM WAVE files are supported. </p>
<p>Binds to C-function call in SDL_audio.h: </p>
<div class="fragment"><pre class="fragment">SDL_AudioSpec * <a class="code" href="_sdl_8cs.html#aa8db921890dcf82c3a3d759d07a594f6" title="This function loads a WAVE from the data source, automatically freeing that source if &amp;#39;freesrc&amp;#3...">SDL_LoadWAV_RW</a>(SDL_RWops *src, <span class="keywordtype">int</span> freesrc, SDL_AudioSpec *spec, Uint8 **audio_buf, Uint32 *audio_len)
</pre></div>  <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>audio_buf</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>audio_len</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freesrc</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>spec</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aa8db921890dcf82c3a3d759d07a594f6"></a><!-- doxytag: member="Sdl.cs::SDL_LoadWAV_RW" ref="aa8db921890dcf82c3a3d759d07a594f6" args="(IntPtr src, int freesrc, out IntPtr spec, out IntPtr audio_buf, out int audio_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_LoadWAV_RW </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>freesrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&nbsp;</td>
          <td class="paramname"> <em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&nbsp;</td>
          <td class="paramname"> <em>audio_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out int&nbsp;</td>
          <td class="paramname"> <em>audio_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function loads a WAVE from the data source, automatically freeing that source if 'freesrc' is non-zero. For example, to load a WAVE file, you could do: SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, ...);. </p>
<p>If this function succeeds, it returns the given SDL_AudioSpec, filled with the audio data format of the wave data, and sets 'audio_buf' to a malloc()'d buffer containing the audio data, and sets 'audio_len' to the length of that audio buffer, in bytes. You need to free the audio buffer with <a class="el" href="_sdl_8cs.html#aa59c06f2223e64f2b5f74b82625dd43f" title="Frees previously opened WAV data.">SDL_FreeWAV()</a> when you are done with it. </p>
<p>This function returns NULL and sets the SDL error message if the wave file cannot be opened, uses an unknown data format, or is corrupt. Currently raw and MS-ADPCM WAVE files are supported. </p>
<p>Binds to C-function call in SDL_audio.h: </p>
<div class="fragment"><pre class="fragment">SDL_AudioSpec * <a class="code" href="_sdl_8cs.html#aa8db921890dcf82c3a3d759d07a594f6" title="This function loads a WAVE from the data source, automatically freeing that source if &amp;#39;freesrc&amp;#3...">SDL_LoadWAV_RW</a>(SDL_RWops *src, <span class="keywordtype">int</span> freesrc, SDL_AudioSpec *spec, Uint8 **audio_buf, Uint32 *audio_len)
</pre></div>  <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>audio_buf</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>audio_len</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freesrc</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>spec</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a228aa7a773a8820468022d53fed4ecd2"></a><!-- doxytag: member="Sdl.cs::SDL_LockAudio" ref="a228aa7a773a8820468022d53fed4ecd2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_LockAudio </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lock out the callback function. </p>
<p>The lock manipulated by these functions protects the callback function. During a LockAudio period, you can be guaranteed that the callback function is not running. Do not call these from the callback function or you will cause deadlock. </p>
<p>Binds to C-function call in SDL_audio.h: </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">void</span> <a class="code" href="_sdl_8cs.html#a228aa7a773a8820468022d53fed4ecd2" title="Lock out the callback function.">SDL_LockAudio</a>(<span class="keywordtype">void</span>);
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#ad374c9d61753113b30c8c4b96295ff3b" title="Opens the audio device with the desired parameters.">SDL_OpenAudio</a></dd></dl>

</div>
</div>
<a class="anchor" id="afae9570bf3fb2b26f7403cb1fc4f1353"></a><!-- doxytag: member="Sdl.cs::SDL_LockSurface" ref="afae9570bf3fb2b26f7403cb1fc4f1353" args="(IntPtr surface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">.&lt;/code&gt;&lt;p&gt; Binds to C function call in SDL_video.or if the <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a> couldn t be locked.&lt;/returns&gt;&lt;seealsocref=&quot;SDL_UnlockSurface&quot;&gt; SDL_UnlockSurface&lt;/seealso&gt;* static int SDL_LockSurface </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>surface</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad1c3562c62aaf55f95641f0bafab9e8f"></a><!-- doxytag: member="Sdl.cs::SDL_LockSurface" ref="ad1c3562c62aaf55f95641f0bafab9e8f" args="(surface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDL_LockSurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a>&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lock a surface for directly access. </p>
<p>SDL_LockSurface sets up a surface for directly accessing the pixels. Between calls to SDL_LockSurface and SDL_UnlockSurface, you can write to and read from <em>surface.pixels</em>, using the pixel format stored in <em>surface.format</em>. Once you are done accessing the surface, you should use SDL_UnlockSurface to release it. </p>
<p>Not all surfaces require locking. If SDL_MUSTLOCK(surface) evaluates to 0, then you can read and write to the surface at any time, and the pixel format of the surface will not change.  </p>
<p>No operating system or library calls should be made between lock/unlock pairs, as critical system locks may be held during this time.  </p>
<p>It should be noted, that since SDL 1.1.8 surface locks are recursive. This means that you can lock a surface multiple times, but each lock must have a match unlock.  code&gt; <a class="el" href="_sdl_8cs.html#ad1c3562c62aaf55f95641f0bafab9e8f" title="Lock a surface for directly access.">SDL_LockSurface( surface )</a>; /* Surface is locked </p>

</div>
</div>
<a class="anchor" id="aef75e3a4590a542c940f024fa387031d"></a><!-- doxytag: member="Sdl.cs::SDL_LockYUVOverlay" ref="aef75e3a4590a542c940f024fa387031d" args="(IntPtr overlay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_LockYUVOverlay </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>overlay</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lock an overlay. </p>
<p>Much the same as <a class="el" href="_sdl_8cs.html#afae9570bf3fb2b26f7403cb1fc4f1353">SDL_LockSurface</a>, SDL_LockYUVOverlay locks the overlay for direct access to pixel data. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#aef75e3a4590a542c940f024fa387031d" title="Lock an overlay.">SDL_LockYUVOverlay</a>(<a class="code" href="struct_s_d_l___overlay.html" title="The YUV hardware video overlay.">SDL_Overlay</a> *overlay)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>overlay</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 on success, or -1 on an error</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a593554f2e6f34c6fed0c39295884b85d" title="Unlock an overlay.">SDL_UnlockYUVOverlay</a>, <a class="el" href="_sdl_8cs.html#a433c9c002d6c6a4a3077fc12ff790372" title="Create a YUV video overlay.">SDL_CreateYUVOverlay(int, int, int, IntPtr)</a>, <a class="el" href="struct_s_d_l___overlay.html" title="The YUV hardware video overlay.">SDL_Overlay</a></dd></dl>

</div>
</div>
<a class="anchor" id="a8c6c5785c9010c08364e8abcd34648a0"></a><!-- doxytag: member="Sdl.cs::SDL_MapRGB" ref="a8c6c5785c9010c08364e8abcd34648a0" args="(IntPtr format, byte r, byte g, byte b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_MapRGB </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&nbsp;</td>
          <td class="paramname"> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Map a RGB color value to a pixel format. </p>
<p>Maps the RGB color value to the specified pixel format and returns the pixel value as a 32-bit int. </p>
<p>If the format has a palette (8-bit) the index of the closest matching color in the palette will be returned. </p>
<p>If the specified pixel format has an alpha component it will be returned as all 1 bits (fully opaque). </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC Uint32 SDLCALL <a class="code" href="_sdl_8cs.html#a8c6c5785c9010c08364e8abcd34648a0" title="Map a RGB color value to a pixel format.">SDL_MapRGB</a> (<a class="code" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a> *format, Uint8 r, Uint8 g, Uint8 b)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td>IntPtr to <a class="el" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pixel value best approximating the given RGB color value for a given pixel format. If the pixel format bpp (color depth) is less than 32-bpp then the unused upper bits of the return value can safely be ignored (e.g., with a 16-bpp format the return value can be assigned to a Uint16, and similarly a Uint8 for an 8-bpp format).</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#afff8f7111c4869f62dae87b04400b54d" title="Get RGB values from a pixel in the specified pixel format.">SDL_GetRGB(int, IntPtr, out byte, out byte, out byte)</a></dd></dl>
<p>SDL_GetRGB</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a283f1dfcfccd35773f6f236a7c021033" title="Get RGBA values from a pixel in the specified pixel format.">SDL_GetRGBA</a></dd></dl>
<p>SDL_GetRGBA</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aadad00b884d9cab5dcfc16b887963bb3" title="Map a RGBA color value to a pixel format.">SDL_MapRGBA</a></dd></dl>
<p>SDL_MapRGBA</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a></dd></dl>
<p><a class="el" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a></p>

</div>
</div>
<a class="anchor" id="aadad00b884d9cab5dcfc16b887963bb3"></a><!-- doxytag: member="Sdl.cs::SDL_MapRGBA" ref="aadad00b884d9cab5dcfc16b887963bb3" args="(IntPtr format, byte r, byte g, byte b, byte a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_MapRGBA </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&nbsp;</td>
          <td class="paramname"> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&nbsp;</td>
          <td class="paramname"> <em>a</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Map a RGBA color value to a pixel format. </p>
<p>Maps the RGBA color value to the specified pixel format and returns the pixel value as a 32-bit int. </p>
<p>If the format has a palette (8-bit) the index of the closest matching color in the palette will be returned. </p>
<p>If the specified pixel format has no alpha component the alpha value will be ignored (as it will be in formats with a palette). </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC Uint32 SDLCALL <a class="code" href="_sdl_8cs.html#aadad00b884d9cab5dcfc16b887963bb3" title="Map a RGBA color value to a pixel format.">SDL_MapRGBA</a> (<a class="code" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a> *format, Uint8 r, Uint8 g, Uint8 b, Uint8 a)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pixel value best approximating the given RGBA color value for a given pixel format. If the pixel format bpp (color depth) is less than 32-bpp then the unused upper bits of the return value can safely be ignored (e.g., with a 16-bpp format the return value can be assigned to a Uint16, and similarly a Uint8 for an 8-bpp format).</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#afff8f7111c4869f62dae87b04400b54d" title="Get RGB values from a pixel in the specified pixel format.">SDL_GetRGB(int, IntPtr, out byte, out byte, out byte)</a></dd></dl>
<p>SDL_GetRGB</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a283f1dfcfccd35773f6f236a7c021033" title="Get RGBA values from a pixel in the specified pixel format.">SDL_GetRGBA</a></dd></dl>
<p>SDL_GetRGBA</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a8c6c5785c9010c08364e8abcd34648a0" title="Map a RGB color value to a pixel format.">SDL_MapRGB</a></dd></dl>
<p>SDL_MapRGB</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a></dd></dl>
<p><a class="el" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a></p>

</div>
</div>
<a class="anchor" id="affaed37dcb295519bdb4bce591c66797"></a><!-- doxytag: member="Sdl.cs::SDL_MixAudio" ref="affaed37dcb295519bdb4bce591c66797" args="(IntPtr dst, IntPtr src, int len, int volume)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_MixAudio </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>volume</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mix audio data. </p>
<p>This function takes two audio buffers of len bytes each of the playing audio format and mixes them, performing addition, volume adjustment, and overflow clipping. The volume ranges from 0 to SDL_MIX_MAXVOLUME and should be set to the maximum value for full audio volume. Note this does not change hardware volume. This is provided for convenience -- you can mix your own audio data. </p>
<p>Note: Do not use this function for mixing together more than two streams of sample data. The output from repeated application of this function may be distorted by clipping, because there is no accumulator with greater range than the input (not to mention this being an inefficient way of doing it). Use mixing functions from SDL_mixer, OpenAL, or write your own mixer instead. </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">void</span> <a class="code" href="_sdl_8cs.html#affaed37dcb295519bdb4bce591c66797" title="Mix audio data.">SDL_MixAudio</a>(Uint8 *dst, Uint8 *src, Uint32 len, <span class="keywordtype">int</span> volume)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>volume</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#ad374c9d61753113b30c8c4b96295ff3b" title="Opens the audio device with the desired parameters.">SDL_OpenAudio</a></dd></dl>

</div>
</div>
<a class="anchor" id="a64dae2fd7e298f7ce4f3185af1a7f676"></a><!-- doxytag: member="Sdl.cs::SDL_MixAudio" ref="a64dae2fd7e298f7ce4f3185af1a7f676" args="(IntPtr dst, IntPtr src, uint len, int volume)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_MixAudio </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>volume</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mix audio data. </p>
<p>This function takes two audio buffers of len bytes each of the playing audio format and mixes them, performing addition, volume adjustment, and overflow clipping. The volume ranges from 0 to SDL_MIX_MAXVOLUME and should be set to the maximum value for full audio volume. Note this does not change hardware volume. This is provided for convenience -- you can mix your own audio data. </p>
<p>Note: Do not use this function for mixing together more than two streams of sample data. The output from repeated application of this function may be distorted by clipping, because there is no accumulator with greater range than the input (not to mention this being an inefficient way of doing it). Use mixing functions from SDL_mixer, OpenAL, or write your own mixer instead. </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">void</span> <a class="code" href="_sdl_8cs.html#affaed37dcb295519bdb4bce591c66797" title="Mix audio data.">SDL_MixAudio</a>(Uint8 *dst, Uint8 *src, Uint32 len, <span class="keywordtype">int</span> volume)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>volume</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#ad374c9d61753113b30c8c4b96295ff3b" title="Opens the audio device with the desired parameters.">SDL_OpenAudio</a></dd></dl>

</div>
</div>
<a class="anchor" id="ac1f1e28042806cf6563ecc9da8b43cff"></a><!-- doxytag: member="Sdl.cs::SDL_mutexP" ref="ac1f1e28042806cf6563ecc9da8b43cff" args="(IntPtr mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_mutexP </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>mutex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lock the mutex (Returns 0, or -1 on error). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Lock the mutex (Returns 0, or -1 on error) </dd></dl>
<p>Binds to C-function call in SDL_mutex.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#ac1f1e28042806cf6563ecc9da8b43cff" title="Lock the mutex (Returns 0, or -1 on error).">SDL_mutexP</a>(SDL_mutex *mutex)
</pre></div>  
</div>
</div>
<a class="anchor" id="ab31b43efd85be6ef6987deec813d582b"></a><!-- doxytag: member="Sdl.cs::SDL_mutexV" ref="ab31b43efd85be6ef6987deec813d582b" args="(IntPtr mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_mutexV </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>mutex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlock the mutex (Returns 0, or -1 on error). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Unlock the mutex (Returns 0, or -1 on error) </dd></dl>
<p>Binds to C-function call in SDL_mutex.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#ab31b43efd85be6ef6987deec813d582b" title="Unlock the mutex (Returns 0, or -1 on error).">SDL_mutexV</a>(SDL_mutex *mutex)
</pre></div>  
</div>
</div>
<a class="anchor" id="a643398553379a3feb14d264cbaf343d3"></a><!-- doxytag: member="Sdl.cs::SDL_NewTimerCallback" ref="a643398553379a3feb14d264cbaf343d3" args="(int interval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">delegate int SDL_NewTimerCallback </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>interval</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prototype for the new timer callback. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>interval</em>&nbsp;</td><td>The current timer interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The next timer interval. </dd></dl>
<p>The callback function is passed the current timer interval and returns the next timer interval. If the returned value is the same as the one passed in, the periodic alarm continues, otherwise a new alarm is scheduled. If the callback returns 0, the periodic alarm is cancelled. </p>
<p>Binds to C callback in SDL_timer.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> Uint32 (SDLCALL *<a class="code" href="_sdl_8cs.html#a643398553379a3feb14d264cbaf343d3" title="Prototype for the new timer callback.">SDL_NewTimerCallback</a>)(Uint32 interval, <span class="keywordtype">void</span> *param)
</pre></div>  <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a135aaf0e0425b1dcf1904b966509c3c0" title="Remove a timer which was added with SDL_AddTimer(int, SDL_NewTimerCallback).">SDL_RemoveTimer</a></dd></dl>

</div>
</div>
<a class="anchor" id="a4b02c05e1ac0903e32c86f0702140a78"></a><!-- doxytag: member="Sdl.cs::SDL_NumJoysticks" ref="a4b02c05e1ac0903e32c86f0702140a78" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_NumJoysticks </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Count the number of joysticks attached to the system. </p>
<p>Counts the number of joysticks attached to the system. </p>
<p>Binds to C-function in SDL_joystick.h </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#a4b02c05e1ac0903e32c86f0702140a78" title="Count the number of joysticks attached to the system.">SDL_NumJoysticks</a>(<span class="keywordtype">void</span>)
</pre></div><dl class="return"><dt><b>Returns:</b></dt><dd>Returns the number of attached joysticks </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>SDL_JoystickName, <a class="el" href="_sdl_8cs.html#a1884e3601e7aa306d7b2e27884c16504" title="Open a joystick for use.">SDL_JoystickOpen</a></dd></dl>

</div>
</div>
<a class="anchor" id="ad374c9d61753113b30c8c4b96295ff3b"></a><!-- doxytag: member="Sdl.cs::SDL_OpenAudio" ref="ad374c9d61753113b30c8c4b96295ff3b" args="(IntPtr desired, IntPtr obtained)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_OpenAudio </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>obtained</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opens the audio device with the desired parameters. </p>
<p>This function opens the audio device with the desired parameters, and returns 0 if successful, placing the actual hardware parameters in the structure pointed to by obtained. If obtained is NULL, the audio data passed to the callback function will be guaranteed to be in the requested format, and will be automatically converted to the hardware audio format if necessary. This function returns -1 if it failed to open the audio device, or couldn't set up the audio thread. </p>
<p>To open the audio device a desired SDL_AudioSpec must be created. </p>
<div class="fragment"><pre class="fragment">            SDL_AudioSpec *desired;
            .
            .
            desired = malloc(<span class="keyword">sizeof</span>(SDL_AudioSpec)); 
</pre></div> <p>You must then fill this structure with your desired audio specifications. </p>
<p>desired-&gt;freq The desired audio frequency in samples-per-second. </p>
<p>desired-&gt;format The desired audio format (see SDL_AudioSpec) </p>
<p>desired-&gt;samples The desired size of the audio buffer in samples. This number should be a power of two, and may be adjusted by the audio driver to a value more suitable for the hardware. Good values seem to range between 512 and 8192 inclusive, depending on the application and CPU speed. Smaller values yield faster response time, but can lead to underflow if the application is doing heavy processing and cannot fill the audio buffer in time. A stereo sample consists of both right and left channels in LR ordering. Note that the number of samples is directly related to time by the following formula: ms = (samples*1000)/freq </p>
<p>desired-&gt;callback This should be set to a function that will be called when the audio device is ready for more data. It is passed a pointer to the audio buffer, and the length in bytes of the audio buffer. This function usually runs in a separate thread, and so you should protect data structures that it accesses by calling <a class="el" href="_sdl_8cs.html#a228aa7a773a8820468022d53fed4ecd2" title="Lock out the callback function.">SDL_LockAudio</a> and <a class="el" href="_sdl_8cs.html#a0a82eaee2425abf8428bca38acbbd8e6" title="Unlock the callback function.">SDL_UnlockAudio</a> in your code. The callback prototype is: </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">void</span> callback(<span class="keywordtype">void</span> *userdata, Uint8 *stream, <span class="keywordtype">int</span> len);
</pre></div> <p>userdata is the pointer stored in userdata field of the SDL_AudioSpec. stream is a pointer to the audio buffer you want to fill with information and len is the length of the audio buffer in bytes. </p>
<p>desired-&gt;userdata p&gt; This pointer is passed as the first parameter to the callback function. p&gt; SDL_OpenAudio reads these fields from the desired SDL_AudioSpec structure pass to the function and attempts to find an audio configuration matching your desired. As mentioned above, if the obtained parameter is NULL then SDL with convert from your desired audio settings to the hardware settings as it plays. p&gt;If obtained is NULL then the desired SDL_AudioSpec is your working specification, otherwise the obtained SDL_AudioSpec becomes the working specification and the desirec specification can be deleted. The data in the working specification is used when building SDL_AudioCVT's for converting loaded data to the hardware format. p&gt;SDL_OpenAudio calculates the size and silence fields for both the desired and obtained specifications. The size field stores the total size of the audio buffer in bytes, while the silence stores the value used to represent silence in the audio buffer.  </p>
<p>The audio device starts out playing silence when it's opened, and should be enabled for playing by calling <a class="el" href="_sdl_8cs.html#a557320f482d1aa5bfe6121ee7cb7ad9f" title="Pauses and unpauses the audio callback processing.">SDL_PauseAudio</a>(0) when you are ready for your audio callback function to be called. Since the audio driver may modify the requested size of the audio buffer, you should allocate any local mixing buffers after you open the audio device. </p>
<p>Binds to C-function call in SDL_audio.h: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#ad374c9d61753113b30c8c4b96295ff3b" title="Opens the audio device with the desired parameters.">SDL_OpenAudio</a>(SDL_AudioSpec *desired, SDL_AudioSpec *obtained);
</pre></div><div class="fragment"><pre class="fragment">            <span class="comment">/* Prototype of our callback function */</span>
                        <span class="keywordtype">void</span> my_audio_callback(<span class="keywordtype">void</span> *userdata, Uint8 *stream, <span class="keywordtype">int</span> len);

                        <span class="comment">/* Open the audio device */</span>
                        SDL_AudioSpec *desired, *obtained;
                        SDL_AudioSpec *hardware_spec;

                        <span class="comment">/* Allocate a desired SDL_AudioSpec */</span>
                        desired = malloc(<span class="keyword">sizeof</span>(SDL_AudioSpec));

                        <span class="comment">/* Allocate space for the obtained SDL_AudioSpec */</span>
                        obtained = malloc(<span class="keyword">sizeof</span>(SDL_AudioSpec));

                        <span class="comment">/* 22050Hz - FM Radio quality */</span>
                        desired-&amp;gt;freq=22050;

                        <span class="comment">/* 16-bit signed audio */</span>
                        desired-&amp;gt;format=AUDIO_S16LSB;

                        <span class="comment">/* Mono */</span>
                        desired-&amp;gt;channels=0;

                <span class="comment">/* Large audio buffer reduces risk of dropouts but </span>
<span class="comment">                increases response time */</span>
                        desired-&amp;gt;samples=8192;

                        <span class="comment">/* Our callback function */</span>
                        desired-&amp;gt;callback=my_audio_callback;

                        desired-&amp;gt;userdata=NULL;

                        <span class="comment">/* Open the audio device */</span>
                        <span class="keywordflow">if</span> ( <a class="code" href="_sdl_8cs.html#ad374c9d61753113b30c8c4b96295ff3b" title="Opens the audio device with the desired parameters.">SDL_OpenAudio</a>(desired, obtained) &amp;lt; 0 )
                {
                        fprintf(stderr, <span class="stringliteral">&quot;Couldn&#39;t open audio: %s\n&quot;</span>, SDL_GetError());
                        exit(-1);
                }
                <span class="comment">/* desired spec is no longer needed */</span>
                free(desired);
                hardware_spec=obtained;
                .
                .
                <span class="comment">/* Prepare callback for playing */</span>
                .
                .
                .
                <span class="comment">/* Start playing */</span>
                <a class="code" href="_sdl_8cs.html#a557320f482d1aa5bfe6121ee7cb7ad9f" title="Pauses and unpauses the audio callback processing.">SDL_PauseAudio</a>(0);
</pre></div><p> /example&gt; </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>desired</em>&nbsp;</td><td>IntPtr to SDL_AudioSpec</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>obtained</em>&nbsp;</td><td>IntPtr to SDL_AudioSpec</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>SDL_AudioSpec, <a class="el" href="_sdl_8cs.html#a228aa7a773a8820468022d53fed4ecd2" title="Lock out the callback function.">SDL_LockAudio</a>, <a class="el" href="_sdl_8cs.html#a0a82eaee2425abf8428bca38acbbd8e6" title="Unlock the callback function.">SDL_UnlockAudio</a>, <a class="el" href="_sdl_8cs.html#a557320f482d1aa5bfe6121ee7cb7ad9f" title="Pauses and unpauses the audio callback processing.">SDL_PauseAudio</a></dd></dl>

</div>
</div>
<a class="anchor" id="a557320f482d1aa5bfe6121ee7cb7ad9f"></a><!-- doxytag: member="Sdl.cs::SDL_PauseAudio" ref="a557320f482d1aa5bfe6121ee7cb7ad9f" args="(int pause_on)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_PauseAudio </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pause_on</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pauses and unpauses the audio callback processing. </p>
<p>This function pauses and unpauses the audio callback processing. It should be called with pause_on=0 after opening the audio device to start playing sound. This is so you can safely initialize data for your callback function after opening the audio device. Silence will be written to the audio device during the pause. </p>
<p>Binds to C-function call in SDL_audio.h: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="_sdl_8cs.html#a557320f482d1aa5bfe6121ee7cb7ad9f" title="Pauses and unpauses the audio callback processing.">SDL_PauseAudio</a>(<span class="keywordtype">int</span> pause_on)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pause_on</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a577477314e53e0fc9c7edd3af022dbf5" title="Get the current audio state.">SDL_GetAudioStatus</a>, <a class="el" href="_sdl_8cs.html#ad374c9d61753113b30c8c4b96295ff3b" title="Opens the audio device with the desired parameters.">SDL_OpenAudio</a></dd></dl>

</div>
</div>
<a class="anchor" id="ac37ad33a4754eb016a62bf60e6401ca3"></a><!-- doxytag: member="Sdl.cs::SDL_PeepEvents" ref="ac37ad33a4754eb016a62bf60e6401ca3" args="([In, Out]SDL_Event[] events, int numevents, int action, uint mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_PeepEvents </td>
          <td>(</td>
          <td class="paramtype">[In, Out] SDL_Event[]&nbsp;</td>
          <td class="paramname"> <em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numevents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks the event queue for messages and optionally returns them. </p>
<p>Checks the event queue for messages and optionally returns them. </p>
<p>If action is SDL_ADDEVENT, up to numevents events will be added to the back of the event queue. </p>
<p>If action is SDL_PEEKEVENT, up to numevents events at the front of the event queue, matching mask, will be returned and will not be removed from the queue. </p>
<p>If action is SDL_GETEVENT, up to numevents events at the front of the event queue, matching mask, will be returned and will be removed from the queue. </p>
<p>The mask parameter is an bitwise OR of SDL_EVENTMASK(event_type), for all event types you are interested in.  </p>
<p>This function is thread-safe. </p>
<p>Binds to C-function in SDL_events.h </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#a85b2190359149f45ab4ef3ab7b4d6887" title="Checks the event queue for messages and optionally returns them.">SDL_PeepEvents</a>(SDL_Event *events, <span class="keywordtype">int</span> numevents, SDL_eventaction action, Uint32 mask);
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>events</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numevents</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>action</em>&nbsp;</td><td>SDL_eventaction enum</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This function returns the number of events actually stored, or -1 if there was an error. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a85f90a4d8d6ae6e2ab13c9e286a9afd2" title="Polls for currently pending events.">SDL_PollEvent</a>, SDL_Event, <a class="el" href="_sdl_8cs.html#a521bf458cc5cfc65b822c2b5b8226646" title="Pushes an event onto the event queue.">SDL_PushEvent</a></dd></dl>

</div>
</div>
<a class="anchor" id="a85b2190359149f45ab4ef3ab7b4d6887"></a><!-- doxytag: member="Sdl.cs::SDL_PeepEvents" ref="a85b2190359149f45ab4ef3ab7b4d6887" args="([In, Out]SDL_Event[] events, int numevents, int action, int mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_PeepEvents </td>
          <td>(</td>
          <td class="paramtype">[In, Out] SDL_Event[]&nbsp;</td>
          <td class="paramname"> <em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numevents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks the event queue for messages and optionally returns them. </p>
<p>Checks the event queue for messages and optionally returns them. </p>
<p>If action is SDL_ADDEVENT, up to numevents events will be added to the back of the event queue. </p>
<p>If action is SDL_PEEKEVENT, up to numevents events at the front of the event queue, matching mask, will be returned and will not be removed from the queue. </p>
<p>If action is SDL_GETEVENT, up to numevents events at the front of the event queue, matching mask, will be returned and will be removed from the queue. </p>
<p>The mask parameter is an bitwise OR of SDL_EVENTMASK(event_type), for all event types you are interested in.  </p>
<p>This function is thread-safe. </p>
<p>Binds to C-function in SDL_events.h </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#a85b2190359149f45ab4ef3ab7b4d6887" title="Checks the event queue for messages and optionally returns them.">SDL_PeepEvents</a>(SDL_Event *events, <span class="keywordtype">int</span> numevents, SDL_eventaction action, Uint32 mask);
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>events</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numevents</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>action</em>&nbsp;</td><td>SDL_eventaction enum</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This function returns the number of events actually stored, or -1 if there was an error. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a85f90a4d8d6ae6e2ab13c9e286a9afd2" title="Polls for currently pending events.">SDL_PollEvent</a>, SDL_Event, <a class="el" href="_sdl_8cs.html#a521bf458cc5cfc65b822c2b5b8226646" title="Pushes an event onto the event queue.">SDL_PushEvent</a></dd></dl>

</div>
</div>
<a class="anchor" id="a85f90a4d8d6ae6e2ab13c9e286a9afd2"></a><!-- doxytag: member="Sdl.cs::SDL_PollEvent" ref="a85f90a4d8d6ae6e2ab13c9e286a9afd2" args="(out SDL_Event sdlEvent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_PollEvent </td>
          <td>(</td>
          <td class="paramtype">out SDL_Event&nbsp;</td>
          <td class="paramname"> <em>sdlEvent</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Polls for currently pending events. </p>
<p>Polls for currently pending events, and returns 1 if there are any pending events, or 0 if there are none available. </p>
<p>If event is not NULL, the next event is removed from the queue and stored in that area. </p>
<p>Binds to C-function in SDL_events.h </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#a85f90a4d8d6ae6e2ab13c9e286a9afd2" title="Polls for currently pending events.">SDL_PollEvent</a>(SDL_Event *event);
</pre></div> <div class="fragment"><pre class="fragment">            SDL_Event event; <span class="comment">/* Event structure */</span>

                        .
                        .
                        .
                        <span class="comment">/* Check for events */</span>
                        <span class="keywordflow">while</span>(<a class="code" href="_sdl_8cs.html#a85f90a4d8d6ae6e2ab13c9e286a9afd2" title="Polls for currently pending events.">SDL_PollEvent</a>(&amp;amp;event))
                {  <span class="comment">/* Loop until there are no events left on the queue */</span>
                        <span class="keywordflow">switch</span>(event.type)
                                                 {  <span class="comment">/* Process the appropiate event type */</span>
                        <span class="keywordflow">case</span> SDL_KEYDOWN:  <span class="comment">/* Handle a KEYDOWN event */</span>         
                        <a class="code" href="_sdl_8cs.html#acf16cb12f21e38e5544fbe0f6a0869d6">printf</a>(<span class="stringliteral">&quot;Oh! Key press\n&quot;</span>);
                        <span class="keywordflow">break</span>;
                        <span class="keywordflow">case</span> SDL_MOUSEMOTION:
                        .
                        .
                        .
                        <span class="keywordflow">default</span>: <span class="comment">/* Report an unhandled event */</span>
                        <a class="code" href="_sdl_8cs.html#acf16cb12f21e38e5544fbe0f6a0869d6">printf</a>(<span class="stringliteral">&quot;I don&#39;t know what this event is!\n&quot;</span>);
                }
           }
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sdlEvent</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 1 if there are any pending events, or 0 if there are none available</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a6cf955d55444b337d368ea677e99b6f9" title="Waits indefinitely for the next available event.">SDL_WaitEvent</a>, SDL_Event, SDL_PeepEvents(SDL_Event[], int, int, int)</dd></dl>

</div>
</div>
<a class="anchor" id="aa58333f760b728cd8f56bbdbc8a6104e"></a><!-- doxytag: member="Sdl.cs::SDL_PumpEvents" ref="aa58333f760b728cd8f56bbdbc8a6104e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_PumpEvents </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pumps the event loop, gathering events from the input devices. </p>
<p>Pumps the event loop, gathering events from the input devices. </p>
<p>SDL_PumpEvents gathers all the pending input information from devices and places it on the event queue. Without calls to SDL_PumpEvents no events would ever be placed on the queue. Often calls the need for SDL_PumpEvents is hidden from the user since <a class="el" href="_sdl_8cs.html#a85f90a4d8d6ae6e2ab13c9e286a9afd2" title="Polls for currently pending events.">SDL_PollEvent</a> and <a class="el" href="_sdl_8cs.html#a6cf955d55444b337d368ea677e99b6f9" title="Waits indefinitely for the next available event.">SDL_WaitEvent</a> implicitly call SDL_PumpEvents. However, if you are not polling or waiting for events (e.g. you are filtering them), then you must call SDL_PumpEvents to force an event queue update.  </p>
<p>Note: You can only call this function in the thread that set the video mode. </p>
<p>Binds to C-function in SDL_events.h </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">void</span> <a class="code" href="_sdl_8cs.html#aa58333f760b728cd8f56bbdbc8a6104e" title="Pumps the event loop, gathering events from the input devices.">SDL_PumpEvents</a>(<span class="keywordtype">void</span>);
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a85f90a4d8d6ae6e2ab13c9e286a9afd2" title="Polls for currently pending events.">SDL_PollEvent</a></dd></dl>

</div>
</div>
<a class="anchor" id="a521bf458cc5cfc65b822c2b5b8226646"></a><!-- doxytag: member="Sdl.cs::SDL_PushEvent" ref="a521bf458cc5cfc65b822c2b5b8226646" args="(out SDL_Event evt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_PushEvent </td>
          <td>(</td>
          <td class="paramtype">out SDL_Event&nbsp;</td>
          <td class="paramname"> <em>evt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pushes an event onto the event queue. </p>
<p>The event queue can actually be used as a two way communication channel. Not only can events be read from the queue, but the user can also push their own events onto it. event is a pointer to the event structure you wish to push onto the queue. </p>
<p>Note: Pushing device input events onto the queue doesn't modify the state of the device within SDL. </p>
<p>Binds to C-function in SDL_events.h </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#a521bf458cc5cfc65b822c2b5b8226646" title="Pushes an event onto the event queue.">SDL_PushEvent</a>(SDL_Event *event)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>evt</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 on success or -1 if the event couldn't be pushed. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>SDL_Event, <a class="el" href="_sdl_8cs.html#a85f90a4d8d6ae6e2ab13c9e286a9afd2" title="Polls for currently pending events.">SDL_PollEvent</a>, SDL_PeepEvents(SDL_Event[], int, int, int)</dd></dl>

</div>
</div>
<a class="anchor" id="a6c1f0715d41310329e65705f5d54e83f"></a><!-- doxytag: member="Sdl.cs::SDL_putenv" ref="a6c1f0715d41310329e65705f5d54e83f" args="(string variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_putenv </td>
          <td>(</td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Puts a variable of the form "name=value" into the environment. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>variable</em>&nbsp;</td><td>The "name=value" pair to write to the environment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns -1 on an error or 0 on success. </dd></dl>
<p>Not all environments have a working putenv(). <a class="el" href="_sdl_8cs.html#a6c1f0715d41310329e65705f5d54e83f" title="Puts a variable of the form &quot;name=value&quot; into the environment.">SDL_putenv()</a> is not available on Windows. </p>
<p>Binds to C-function call in SDL_getenv.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#a6c1f0715d41310329e65705f5d54e83f" title="Puts a variable of the form &amp;quot;name=value&amp;quot; into the environment.">SDL_putenv</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *variable)
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd>SDL_getenv</dd></dl>

</div>
</div>
<a class="anchor" id="a3acfba2794297d8a0a6d5b047dbaa53c"></a><!-- doxytag: member="Sdl.cs::SDL_Quit" ref="a3acfba2794297d8a0a6d5b047dbaa53c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_Quit </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shuts down SDL. </p>
<p><b>SDL_Quit</b> shuts down all SDL subsystems and frees the resources allocated to them. This should always be called before you exit. </p>
<p>Binds to C-function call in SDL.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">void</span> SDLCALL <a class="code" href="_sdl_8cs.html#a3acfba2794297d8a0a6d5b047dbaa53c" title="Shuts down SDL.">SDL_Quit</a>(<span class="keywordtype">void</span>)
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd>SDL_Init(int), <a class="el" href="_sdl_8cs.html#ada019f86ff1d7d9d7ebf28e8f71cdea1" title="Shuts down specified subsystems.">SDL_QuitSubSystem(int)</a></dd></dl>

</div>
</div>
<a class="anchor" id="ac9fba8906c8de0e5bffa554258d92118"></a><!-- doxytag: member="Sdl.cs::SDL_QuitSubSystem" ref="ac9fba8906c8de0e5bffa554258d92118" args="(uint flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_QuitSubSystem </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>flags</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shuts down specified subsystems. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Specifies what part(s) of SDL to shut down: <table  type="table">
<tr>
<th>Flag</b> </th><th>Description  </th></tr>
<tr>
<td>SDL_INIT_TIMER</b> </td><td>Shuts down the timer subsystem.  </td></tr>
<tr>
<td>SDL_INIT_AUDIO</b> </td><td>Shuts down the audio subsystem.  </td></tr>
<tr>
<td>SDL_INIT_VIDEO</b> </td><td>Shuts down the video subsystem.  </td></tr>
<tr>
<td>SDL_INIT_CDROM</b> </td><td>Shuts down the CD-ROM subsystem.  </td></tr>
<tr>
<td>SDL_INIT_JOYSTICK</b> </td><td>Shuts down the joystick subsystem.  </td></tr>
<tr>
<td>SDL_INIT_EVERYTHING</b> </td><td>Shuts down all subsystems.  </td></tr>
<tr>
<td>SDL_INIT_NOPARACHUTE</b> </td><td>Prevents SDL from catching fatal signals.  </td></tr>
<tr>
<td>SDL_INIT_EVENTTHREAD</b> </td><td>Not supported on all OS's.  </td></tr>
</table>
</td></tr>
  </table>
  </dd>
</dl>
<p><b>SDL_QuitSubSystem</b> allows you to shut down a subsystem that has been previously initialized by SDL_Init(int) or SDL_InitSubSystem(int). </p>
<p>Binds to C-function call in SDL.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">void</span> SDLCALL <a class="code" href="_sdl_8cs.html#ada019f86ff1d7d9d7ebf28e8f71cdea1" title="Shuts down specified subsystems.">SDL_QuitSubSystem</a>(Uint32 flags)
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd>SDL_Init(int), SDL_InitSubSystem(int), <a class="el" href="_sdl_8cs.html#a3acfba2794297d8a0a6d5b047dbaa53c" title="Shuts down SDL.">SDL_Quit</a></dd></dl>

</div>
</div>
<a class="anchor" id="ada019f86ff1d7d9d7ebf28e8f71cdea1"></a><!-- doxytag: member="Sdl.cs::SDL_QuitSubSystem" ref="ada019f86ff1d7d9d7ebf28e8f71cdea1" args="(int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_QuitSubSystem </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shuts down specified subsystems. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Specifies what part(s) of SDL to shut down: <table  type="table">
<tr>
<th>Flag</b> </th><th>Description  </th></tr>
<tr>
<td>SDL_INIT_TIMER</b> </td><td>Shuts down the timer subsystem.  </td></tr>
<tr>
<td>SDL_INIT_AUDIO</b> </td><td>Shuts down the audio subsystem.  </td></tr>
<tr>
<td>SDL_INIT_VIDEO</b> </td><td>Shuts down the video subsystem.  </td></tr>
<tr>
<td>SDL_INIT_CDROM</b> </td><td>Shuts down the CD-ROM subsystem.  </td></tr>
<tr>
<td>SDL_INIT_JOYSTICK</b> </td><td>Shuts down the joystick subsystem.  </td></tr>
<tr>
<td>SDL_INIT_EVERYTHING</b> </td><td>Shuts down all subsystems.  </td></tr>
<tr>
<td>SDL_INIT_NOPARACHUTE</b> </td><td>Prevents SDL from catching fatal signals.  </td></tr>
<tr>
<td>SDL_INIT_EVENTTHREAD</b> </td><td>Not supported on all OS's.  </td></tr>
</table>
</td></tr>
  </table>
  </dd>
</dl>
<p><b>SDL_QuitSubSystem</b> allows you to shut down a subsystem that has been previously initialized by SDL_Init(int) or SDL_InitSubSystem(int). </p>
<p>Binds to C-function call in SDL.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">void</span> SDLCALL <a class="code" href="_sdl_8cs.html#ada019f86ff1d7d9d7ebf28e8f71cdea1" title="Shuts down specified subsystems.">SDL_QuitSubSystem</a>(Uint32 flags)
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd>SDL_Init(int), SDL_InitSubSystem(int), <a class="el" href="_sdl_8cs.html#a3acfba2794297d8a0a6d5b047dbaa53c" title="Shuts down SDL.">SDL_Quit</a></dd></dl>

</div>
</div>
<a class="anchor" id="a3820fcdf32f5c14454dfca107f5fd5c3"></a><!-- doxytag: member="Sdl.cs::SDL_ReadBE16" ref="a3820fcdf32f5c14454dfca107f5fd5c3" args="(IntPtr src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static short SDL_ReadBE16 </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>src</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read an item of the specified endianness and return in native format. </p>
<p>Binds to C-function in SDL_rwops.h </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">extern</span> DECLSPEC Uint16 SDLCALL <a class="code" href="_sdl_8cs.html#a3820fcdf32f5c14454dfca107f5fd5c3" title="Read an item of the specified endianness and return in native format.">SDL_ReadBE16</a>(SDL_RWops *src)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aa1fe24060926a8679b4a16201728a1e9" title="Allocates an empty, unpopulated SDL_RWops structure.">SDL_AllocRW</a></dd></dl>

</div>
</div>
<a class="anchor" id="aa8d7489565807f2a237912cacf5fac42"></a><!-- doxytag: member="Sdl.cs::SDL_ReadBE32" ref="aa8d7489565807f2a237912cacf5fac42" args="(IntPtr src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_ReadBE32 </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>src</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read an item of the specified endianness and return in native format. </p>
<p>Binds to C-function in SDL_rwops.h </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">extern</span> DECLSPEC Uint32 SDLCALL <a class="code" href="_sdl_8cs.html#aa8d7489565807f2a237912cacf5fac42" title="Read an item of the specified endianness and return in native format.">SDL_ReadBE32</a>(SDL_RWops *src)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aa1fe24060926a8679b4a16201728a1e9" title="Allocates an empty, unpopulated SDL_RWops structure.">SDL_AllocRW</a></dd></dl>

</div>
</div>
<a class="anchor" id="a3bb1c79f8a17c889dd6bab03b6545306"></a><!-- doxytag: member="Sdl.cs::SDL_ReadBE64" ref="a3bb1c79f8a17c889dd6bab03b6545306" args="(IntPtr src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static long SDL_ReadBE64 </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>src</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read an item of the specified endianness and return in native format. </p>
<p>Binds to C-function in SDL_rwops.h </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">extern</span> DECLSPEC Uint64 SDLCALL <a class="code" href="_sdl_8cs.html#a3bb1c79f8a17c889dd6bab03b6545306" title="Read an item of the specified endianness and return in native format.">SDL_ReadBE64</a>(SDL_RWops *src)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aa1fe24060926a8679b4a16201728a1e9" title="Allocates an empty, unpopulated SDL_RWops structure.">SDL_AllocRW</a></dd></dl>

</div>
</div>
<a class="anchor" id="a206f12b60270e78917d75bda7e5acd1d"></a><!-- doxytag: member="Sdl.cs::SDL_ReadLE16" ref="a206f12b60270e78917d75bda7e5acd1d" args="(IntPtr src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static short SDL_ReadLE16 </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>src</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read an item of the specified endianness and return in native format. </p>
<p>Binds to C-function in SDL_rwops.h </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">extern</span> DECLSPEC Uint16 SDLCALL <a class="code" href="_sdl_8cs.html#a206f12b60270e78917d75bda7e5acd1d" title="Read an item of the specified endianness and return in native format.">SDL_ReadLE16</a>(SDL_RWops *src)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aa1fe24060926a8679b4a16201728a1e9" title="Allocates an empty, unpopulated SDL_RWops structure.">SDL_AllocRW</a></dd></dl>

</div>
</div>
<a class="anchor" id="a0cfac7e23f6953f72d60dc5c04cf39e6"></a><!-- doxytag: member="Sdl.cs::SDL_ReadLE32" ref="a0cfac7e23f6953f72d60dc5c04cf39e6" args="(IntPtr src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_ReadLE32 </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>src</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read an item of the specified endianness and return in native format. </p>
<p>Binds to C-function in SDL_rwops.h </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">extern</span> DECLSPEC Uint32 SDLCALL <a class="code" href="_sdl_8cs.html#a0cfac7e23f6953f72d60dc5c04cf39e6" title="Read an item of the specified endianness and return in native format.">SDL_ReadLE32</a>(SDL_RWops *src)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aa1fe24060926a8679b4a16201728a1e9" title="Allocates an empty, unpopulated SDL_RWops structure.">SDL_AllocRW</a></dd></dl>

</div>
</div>
<a class="anchor" id="a64bbc037c191d11d49b4bf080f5fd0f8"></a><!-- doxytag: member="Sdl.cs::SDL_ReadLE64" ref="a64bbc037c191d11d49b4bf080f5fd0f8" args="(IntPtr src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static long SDL_ReadLE64 </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>src</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read an item of the specified endianness and return in native format. </p>
<p>Binds to C-function in SDL_rwops.h </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">extern</span> DECLSPEC Uint64 SDLCALL <a class="code" href="_sdl_8cs.html#a64bbc037c191d11d49b4bf080f5fd0f8" title="Read an item of the specified endianness and return in native format.">SDL_ReadLE64</a>(SDL_RWops *src)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aa1fe24060926a8679b4a16201728a1e9" title="Allocates an empty, unpopulated SDL_RWops structure.">SDL_AllocRW</a></dd></dl>

</div>
</div>
<a class="anchor" id="a135aaf0e0425b1dcf1904b966509c3c0"></a><!-- doxytag: member="Sdl.cs::SDL_RemoveTimer" ref="a135aaf0e0425b1dcf1904b966509c3c0" args="(SDL_TimerID t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_RemoveTimer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_d_l___timer_i_d.html">SDL_TimerID</a>&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a timer which was added with <a class="el" href="_sdl_8cs.html#a0847fd552fc17aa314f866ac16db60df" title="Add a timer which will call a callback after the specified number of milliseconds has elapsed...">SDL_AddTimer(int, SDL_NewTimerCallback)</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The timer ID to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A boolean value indicating success. SDL_TRUE or SDL_FALSE. </dd></dl>
<p>Binds to C-function call in SDL_timer.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC SDL_bool SDLCALL <a class="code" href="_sdl_8cs.html#a135aaf0e0425b1dcf1904b966509c3c0" title="Remove a timer which was added with SDL_AddTimer(int, SDL_NewTimerCallback).">SDL_RemoveTimer</a>(<a class="code" href="struct_s_d_l___timer_i_d.html">SDL_TimerID</a> t)
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a0847fd552fc17aa314f866ac16db60df" title="Add a timer which will call a callback after the specified number of milliseconds has elapsed...">SDL_AddTimer(int, SDL_NewTimerCallback)</a></dd></dl>

</div>
</div>
<a class="anchor" id="ab5bf8b28e005615987c706138b89ff26"></a><!-- doxytag: member="Sdl.cs::SDL_RWFromConstMem" ref="ab5bf8b28e005615987c706138b89ff26" args="(IntPtr mem, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_RWFromConstMem </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepares a constant memory area for use with RWops. </p>
<p><a class="el" href="_sdl_8cs.html#ab5bf8b28e005615987c706138b89ff26" title="Prepares a constant memory area for use with RWops.">SDL_RWFromConstMem</a> sets up a RWops struct based on a memory area of a certain size. It assumes the memory area is not writable. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mem</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a pointer to a new RWops struct, or NULL if it fails.</dd></dl>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">char</span> bitmap[] = {
                        66, 77, 86, 2, 0, 0, 0, 0 ...
                }
                 SDL_RWops *rw;
                 <a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *img;

                 rw = <a class="code" href="_sdl_8cs.html#ab5bf8b28e005615987c706138b89ff26" title="Prepares a constant memory area for use with RWops.">SDL_RWFromConstMem</a>(bitmap, <span class="keyword">sizeof</span>(bitmap));
                 img = <a class="code" href="_sdl_8cs.html#a380d06edefbb8abcc0f14859fd25108c" title="Load a surface from a seekable SDL data source (memory or file.).">SDL_LoadBMP_RW</a>(rw, 1); <span class="comment">// Automatically frees the RWops struct for us</span>

                 <span class="comment">//Do something with img...</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a5b1012f5444376abc443d022a9d8c547" title="Create SDL_RWops structures from memory.">SDL_RWFromMem(IntPtr, int)</a></dd></dl>

</div>
</div>
<a class="anchor" id="a5c5d2e26df99930f33d8b57c2a95874b"></a><!-- doxytag: member="Sdl.cs::SDL_RWFromFile" ref="a5c5d2e26df99930f33d8b57c2a95874b" args="(string file, string mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_RWFromFile </td>
          <td>(</td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create SDL_RWops structures from file. </p>
<p>Binds to C-function call in SDL_rwops.h: </p>
<div class="fragment"><pre class="fragment">            SDL_RWops * SDLCALL <a class="code" href="_sdl_8cs.html#a5c5d2e26df99930f33d8b57c2a95874b" title="Create SDL_RWops structures from file.">SDL_RWFromFile</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *file, <span class="keyword">const</span> <span class="keywordtype">char</span> *mode)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>"rb"</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>IntPtr to SDL_RWops</dd></dl>

</div>
</div>
<a class="anchor" id="a3c6da7942616b307b7fdf86e6402daf4"></a><!-- doxytag: member="Sdl.cs::SDL_RWFromFP" ref="a3c6da7942616b307b7fdf86e6402daf4" args="(IntPtr fp, int autoclose)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_RWFromFP </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>autoclose</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>SDL_RWFromFP creates a new SDL_RWops structure from a file pointer, opened with stdio. If autoclose is nonzero, the file will be automatically closed when the RWops structure is closed. </p>
<p>This is not available under Win32, since files opened in an application on that platform cannot be used by a dynamically linked library. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>autoclose</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns pointer to a new RWops structure, or NULL if it fails.</dd></dl>
<div class="fragment"><pre class="fragment">            FILE *fp;
            SDL_RWops *rw;

            fp = fopen(<span class="stringliteral">&quot;myfile.dat&quot;</span>, <span class="stringliteral">&quot;rb&quot;</span>);
            rw = <a class="code" href="_sdl_8cs.html#a3c6da7942616b307b7fdf86e6402daf4" title="SDL_RWFromFP creates a new SDL_RWops structure from a file pointer, opened with stdio. If autoclose is nonzero, the file will be automatically closed when the RWops structure is closed.">SDL_RWFromFP</a>(fp, 1);

            <span class="comment">// Do things with rw...</span>
            SDL_RWclose(rw); <span class="comment">// Automatically does an fclose(fp)</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a5c5d2e26df99930f33d8b57c2a95874b" title="Create SDL_RWops structures from file.">SDL_RWFromFile</a></dd></dl>

</div>
</div>
<a class="anchor" id="a5b1012f5444376abc443d022a9d8c547"></a><!-- doxytag: member="Sdl.cs::SDL_RWFromMem" ref="a5b1012f5444376abc443d022a9d8c547" args="(IntPtr mem, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_RWFromMem </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create SDL_RWops structures from memory. </p>
<p>Binds to C-function call in SDL_rwops.h: </p>
<div class="fragment"><pre class="fragment">            SDL_RWops * SDLCALL <a class="code" href="_sdl_8cs.html#a5b1012f5444376abc443d022a9d8c547" title="Create SDL_RWops structures from memory.">SDL_RWFromMem</a>(<span class="keywordtype">void</span> *mem, <span class="keywordtype">int</span> size)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mem</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>IntPtr to SDL_RWops</dd></dl>

</div>
</div>
<a class="anchor" id="a06454ef83d9e843c1c3f4f47da8435f7"></a><!-- doxytag: member="Sdl.cs::SDL_SaveBMP_RW" ref="a06454ef83d9e843c1c3f4f47da8435f7" args="(IntPtr surface, IntPtr dst, int freedst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_SaveBMP_RW </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>freedst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a surface to a seekable SDL data source (memory or file.). </p>
<p>If 'freedst' is non-zero, the source will be closed after being written. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#a06454ef83d9e843c1c3f4f47da8435f7" title="Save a surface to a seekable SDL data source (memory or file.).">SDL_SaveBMP_RW</a> (<a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *surface, SDL_RWops *dst, <span class="keywordtype">int</span> freedst)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>surface</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freedst</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 if successful or -1 if there was an error.</dd></dl>

</div>
</div>
<a class="anchor" id="a335e67ad56be81afeb4f714d82176f7b"></a><!-- doxytag: member="Sdl.cs::SDL_SemPost" ref="a335e67ad56be81afeb4f714d82176f7b" args="(IntPtr sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_SemPost </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>sem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomically increases the semaphore's count (not blocking), returns 0, or -1 on error. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Atomically increases the semaphore's count (not blocking), returns 0, or -1 on error. </dd></dl>
<p>Binds to C-function call in SDL_mutex.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#a335e67ad56be81afeb4f714d82176f7b" title="Atomically increases the semaphore&amp;#39;s count (not blocking), returns 0, or -1 on error...">SDL_SemPost</a>(SDL_sem *sem)
</pre></div>  
</div>
</div>
<a class="anchor" id="a89e09512b0fd719d679aa5c4b1468fcc"></a><!-- doxytag: member="Sdl.cs::SDL_SemtryWait" ref="a89e09512b0fd719d679aa5c4b1468fcc" args="(IntPtr sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_SemtryWait </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>sem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-blocking variant of <a class="el" href="_sdl_8cs.html#a47831bed0a285a3d765b401347eb09cc" title="This function suspends the calling thread until the semaphore pointed to by sem has a positive count...">SDL_SemWait()</a>, returns 0 if the wait succeeds, SDL_MUTEX_TIMEDOUT if the wait would block, and -1 on error. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Non-blocking variant of <a class="el" href="_sdl_8cs.html#a47831bed0a285a3d765b401347eb09cc" title="This function suspends the calling thread until the semaphore pointed to by sem has a positive count...">SDL_SemWait()</a>, returns 0 if the wait succeeds, SDL_MUTEX_TIMEDOUT if the wait would block, and -1 on error. </dd></dl>
<p>Binds to C-function call in SDL_mutex.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL SDL_SemTryWait(SDL_sem *sem)
</pre></div>  
</div>
</div>
<a class="anchor" id="aa815d7907553c24ac8225e5f9b3bae47"></a><!-- doxytag: member="Sdl.cs::SDL_SemValue" ref="aa815d7907553c24ac8225e5f9b3bae47" args="(IntPtr sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_SemValue </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>sem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the current count of the semaphore. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the current count of the semaphore </dd></dl>
<p>Binds to C-function call in SDL_mutex.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC Uint32 SDLCALL <a class="code" href="_sdl_8cs.html#aa815d7907553c24ac8225e5f9b3bae47" title="Returns the current count of the semaphore.">SDL_SemValue</a>(SDL_sem *sem)
</pre></div>  
</div>
</div>
<a class="anchor" id="a47831bed0a285a3d765b401347eb09cc"></a><!-- doxytag: member="Sdl.cs::SDL_SemWait" ref="a47831bed0a285a3d765b401347eb09cc" args="(IntPtr sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_SemWait </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>sem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function suspends the calling thread until the semaphore pointed to by sem has a positive count. It then atomically decreases the semaphore count. </p>
<p>Binds to C-function call in SDL_mutex.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#a47831bed0a285a3d765b401347eb09cc" title="This function suspends the calling thread until the semaphore pointed to by sem has a positive count...">SDL_SemWait</a>(SDL_sem *sem)
</pre></div>  
</div>
</div>
<a class="anchor" id="a790d70652c06bb2c6ed8a550f4306eb9"></a><!-- doxytag: member="Sdl.cs::SDL_SemWaitTimeout" ref="a790d70652c06bb2c6ed8a550f4306eb9" args="(IntPtr sem, uint ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_SemWaitTimeout </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Variant of <a class="el" href="_sdl_8cs.html#a47831bed0a285a3d765b401347eb09cc" title="This function suspends the calling thread until the semaphore pointed to by sem has a positive count...">SDL_SemWait()</a> with a timeout in milliseconds, returns 0 if the wait succeeds, SDL_MUTEX_TIMEDOUT if the wait does not succeed in the allotted time, and -1 on error. On some platforms this function is implemented by looping with a delay of 1 ms, and so should be avoided if possible. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Variant of <a class="el" href="_sdl_8cs.html#a47831bed0a285a3d765b401347eb09cc" title="This function suspends the calling thread until the semaphore pointed to by sem has a positive count...">SDL_SemWait()</a> with a timeout in milliseconds, returns 0 if the wait succeeds, SDL_MUTEX_TIMEDOUT if the wait does not succeed in the allotted time, and -1 on error. On some platforms this function is implemented by looping with a delay of 1 ms, and so should be avoided if possible. </dd></dl>
<p>Binds to C-function call in SDL_mutex.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#a2ceabbfbfd3f7953a3d8588ddc7f2dd1" title="Variant of SDL_SemWait() with a timeout in milliseconds, returns 0 if the wait succeeds, SDL_MUTEX_TIMEDOUT if the wait does not succeed in the allotted time, and -1 on error. On some platforms this function is implemented by looping with a delay of 1 ms, and so should be avoided if possible.">SDL_SemWaitTimeout</a>(SDL_sem *sem, Uint32 ms)
</pre></div>  
</div>
</div>
<a class="anchor" id="a2ceabbfbfd3f7953a3d8588ddc7f2dd1"></a><!-- doxytag: member="Sdl.cs::SDL_SemWaitTimeout" ref="a2ceabbfbfd3f7953a3d8588ddc7f2dd1" args="(IntPtr sem, int ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_SemWaitTimeout </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Variant of <a class="el" href="_sdl_8cs.html#a47831bed0a285a3d765b401347eb09cc" title="This function suspends the calling thread until the semaphore pointed to by sem has a positive count...">SDL_SemWait()</a> with a timeout in milliseconds, returns 0 if the wait succeeds, SDL_MUTEX_TIMEDOUT if the wait does not succeed in the allotted time, and -1 on error. On some platforms this function is implemented by looping with a delay of 1 ms, and so should be avoided if possible. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Variant of <a class="el" href="_sdl_8cs.html#a47831bed0a285a3d765b401347eb09cc" title="This function suspends the calling thread until the semaphore pointed to by sem has a positive count...">SDL_SemWait()</a> with a timeout in milliseconds, returns 0 if the wait succeeds, SDL_MUTEX_TIMEDOUT if the wait does not succeed in the allotted time, and -1 on error. On some platforms this function is implemented by looping with a delay of 1 ms, and so should be avoided if possible. </dd></dl>
<p>Binds to C-function call in SDL_mutex.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#a2ceabbfbfd3f7953a3d8588ddc7f2dd1" title="Variant of SDL_SemWait() with a timeout in milliseconds, returns 0 if the wait succeeds, SDL_MUTEX_TIMEDOUT if the wait does not succeed in the allotted time, and -1 on error. On some platforms this function is implemented by looping with a delay of 1 ms, and so should be avoided if possible.">SDL_SemWaitTimeout</a>(SDL_sem *sem, Uint32 ms)
</pre></div>  
</div>
</div>
<a class="anchor" id="a77f6839de15f85b6c5afd9174894a41a"></a><!-- doxytag: member="Sdl.cs::SDL_SetAlpha" ref="a77f6839de15f85b6c5afd9174894a41a" args="(IntPtr surface, int flag, byte alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_SetAlpha </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adjust the alpha properties of a surface. </p>
<p>SDL_SetAlpha is used for setting the per-surface alpha value and/or enabling and disabling alpha blending. </p>
<p>The surface parameter specifies which surface whose alpha attributes you wish to adjust. flags is used to specify whether alpha blending should be used (SDL_SRCALPHA) and whether the surface should use RLE acceleration for blitting (SDL_RLEACCEL). flags can be an OR'd combination of these two options, one of these options or 0. If SDL_SRCALPHA is not passed as a flag then all alpha information is ignored when blitting the surface. The alpha parameter is the per-surface alpha value; a surface need not have an alpha channel to use per-surface alpha and blitting can still be accelerated with SDL_RLEACCEL. </p>
<p>Note: The per-surface alpha value of 128 is considered a special case and is optimised, so it's much faster than other per-surface values. Alpha effects surface blitting in the following ways: </p>
<table  type="table">
<tr>
<td>RGBA-&gt;RGB with SDL_SRCALPHA</b> </td><td>The source is alpha-blended with the destination, using the alpha channel. SDL_SRCCOLORKEY and the per-surface alpha are ignored.  </td></tr>
<tr>
<td>RGBA-&gt;RGB without SDL_SRCALPHA</b> </td><td>The RGB data is copied from the source. The source alpha channel and the per-surface alpha value are ignored.  </td></tr>
<tr>
<td>RGB-&gt;RGBA with SDL_SRCALPHA</b> </td><td>The source is alpha-blended with the destination using the per-surface alpha value. If SDL_SRCCOLORKEY is set, only the pixels not matching the colorkey value are copied. The alpha channel of the copied pixels is set to opaque.   </td></tr>
<tr>
<td>RGB-&gt;RGBA without SDL_SRCALPHA</b> </td><td>The RGB data is copied from the source and the alpha value of the copied pixels is set to opaque. If SDL_SRCCOLORKEY is set, only the pixels not matching the colorkey value are copied.  </td></tr>
<tr>
<td>RGBA-&gt;RGBA with SDL_SRCALPHA</b> </td><td>The source is alpha-blended with the destination using the source alpha channel. The alpha channel in the destination surface is left untouched. SDL_SRCCOLORKEY is ignored.   </td></tr>
<tr>
<td>RGBA-&gt;RGBA without SDL_SRCALPHA</b> </td><td>The RGBA data is copied to the destination surface. If SDL_SRCCOLORKEY is set, only the pixels not matching the colorkey value are copied.   </td></tr>
<tr>
<td>RGB-&gt;RGB with SDL_SRCALPHA</b> </td><td>The source is alpha-blended with the destination using the per-surface alpha value. If SDL_SRCCOLORKEY is set, only the pixels not matching the colorkey value are copied.   </td></tr>
<tr>
<td>RGB-&gt;RGB without SDL_SRCALPHA</b> </td><td>The RGB data is copied from the source. If SDL_SRCCOLORKEY is set, only the pixels not matching the colorkey value are copied.   </td></tr>
</table>
<p>Note: Note that RGBA-&gt;RGBA blits (with SDL_SRCALPHA set) keep the alpha of the destination surface. This means that you cannot compose two arbitrary RGBA surfaces this way and get the result you would expect from "overlaying" them; the destination alpha will work as a mask. </p>
<p>Also note that per-pixel and per-surface alpha cannot be combined; the per-pixel alpha is always used if available. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#a77f6839de15f85b6c5afd9174894a41a" title="Adjust the alpha properties of a surface.">SDL_SetAlpha</a>(<a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *surface, Uint32 flag, Uint8 alpha);
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>surface</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flag</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This function returns 0, or -1 if there was an error. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aadad00b884d9cab5dcfc16b887963bb3" title="Map a RGBA color value to a pixel format.">SDL_MapRGBA</a></dd></dl>
<p>SDL_MapRGBA</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a283f1dfcfccd35773f6f236a7c021033" title="Get RGBA values from a pixel in the specified pixel format.">SDL_GetRGBA</a></dd></dl>
<p>SDL_GetRGBA</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#ad76ca477f17f31fd3aaccf8c19f643c1" title="Convert a surface to the display format.">SDL_DisplayFormatAlpha</a></dd></dl>
<p>SDL_DisplayFormatAlpha</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aec41f77b04d717457433acbecd7a257b" title="This performs a fast blit from the source surface to the destination surface.">SDL_BlitSurface</a></dd></dl>
<p>SDL_BlitSurface</p>

</div>
</div>
<a class="anchor" id="a00c013823736cccea1529c8431beaf5c"></a><!-- doxytag: member="Sdl.cs::SDL_SetAlpha" ref="a00c013823736cccea1529c8431beaf5c" args="(IntPtr surface, uint flag, byte alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_SetAlpha </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adjust the alpha properties of a surface. </p>
<p>SDL_SetAlpha is used for setting the per-surface alpha value and/or enabling and disabling alpha blending. </p>
<p>The surface parameter specifies which surface whose alpha attributes you wish to adjust. flags is used to specify whether alpha blending should be used (SDL_SRCALPHA) and whether the surface should use RLE acceleration for blitting (SDL_RLEACCEL). flags can be an OR'd combination of these two options, one of these options or 0. If SDL_SRCALPHA is not passed as a flag then all alpha information is ignored when blitting the surface. The alpha parameter is the per-surface alpha value; a surface need not have an alpha channel to use per-surface alpha and blitting can still be accelerated with SDL_RLEACCEL. </p>
<p>Note: The per-surface alpha value of 128 is considered a special case and is optimised, so it's much faster than other per-surface values. Alpha effects surface blitting in the following ways: </p>
<table  type="table">
<tr>
<td>RGBA-&gt;RGB with SDL_SRCALPHA</b> </td><td>The source is alpha-blended with the destination, using the alpha channel. SDL_SRCCOLORKEY and the per-surface alpha are ignored.  </td></tr>
<tr>
<td>RGBA-&gt;RGB without SDL_SRCALPHA</b> </td><td>The RGB data is copied from the source. The source alpha channel and the per-surface alpha value are ignored.  </td></tr>
<tr>
<td>RGB-&gt;RGBA with SDL_SRCALPHA</b> </td><td>The source is alpha-blended with the destination using the per-surface alpha value. If SDL_SRCCOLORKEY is set, only the pixels not matching the colorkey value are copied. The alpha channel of the copied pixels is set to opaque.   </td></tr>
<tr>
<td>RGB-&gt;RGBA without SDL_SRCALPHA</b> </td><td>The RGB data is copied from the source and the alpha value of the copied pixels is set to opaque. If SDL_SRCCOLORKEY is set, only the pixels not matching the colorkey value are copied.  </td></tr>
<tr>
<td>RGBA-&gt;RGBA with SDL_SRCALPHA</b> </td><td>The source is alpha-blended with the destination using the source alpha channel. The alpha channel in the destination surface is left untouched. SDL_SRCCOLORKEY is ignored.   </td></tr>
<tr>
<td>RGBA-&gt;RGBA without SDL_SRCALPHA</b> </td><td>The RGBA data is copied to the destination surface. If SDL_SRCCOLORKEY is set, only the pixels not matching the colorkey value are copied.   </td></tr>
<tr>
<td>RGB-&gt;RGB with SDL_SRCALPHA</b> </td><td>The source is alpha-blended with the destination using the per-surface alpha value. If SDL_SRCCOLORKEY is set, only the pixels not matching the colorkey value are copied.   </td></tr>
<tr>
<td>RGB-&gt;RGB without SDL_SRCALPHA</b> </td><td>The RGB data is copied from the source. If SDL_SRCCOLORKEY is set, only the pixels not matching the colorkey value are copied.   </td></tr>
</table>
<p>Note: Note that RGBA-&gt;RGBA blits (with SDL_SRCALPHA set) keep the alpha of the destination surface. This means that you cannot compose two arbitrary RGBA surfaces this way and get the result you would expect from "overlaying" them; the destination alpha will work as a mask. </p>
<p>Also note that per-pixel and per-surface alpha cannot be combined; the per-pixel alpha is always used if available. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#a77f6839de15f85b6c5afd9174894a41a" title="Adjust the alpha properties of a surface.">SDL_SetAlpha</a>(<a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *surface, Uint32 flag, Uint8 alpha);
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>surface</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flag</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This function returns 0, or -1 if there was an error. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aadad00b884d9cab5dcfc16b887963bb3" title="Map a RGBA color value to a pixel format.">SDL_MapRGBA</a></dd></dl>
<p>SDL_MapRGBA</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a283f1dfcfccd35773f6f236a7c021033" title="Get RGBA values from a pixel in the specified pixel format.">SDL_GetRGBA</a></dd></dl>
<p>SDL_GetRGBA</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#ad76ca477f17f31fd3aaccf8c19f643c1" title="Convert a surface to the display format.">SDL_DisplayFormatAlpha</a></dd></dl>
<p>SDL_DisplayFormatAlpha</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aec41f77b04d717457433acbecd7a257b" title="This performs a fast blit from the source surface to the destination surface.">SDL_BlitSurface</a></dd></dl>
<p>SDL_BlitSurface</p>

</div>
</div>
<a class="anchor" id="a201a7363fdcfe07651a1298a3e4e1778"></a><!-- doxytag: member="Sdl.cs::SDL_SetClipRect" ref="a201a7363fdcfe07651a1298a3e4e1778" args="(IntPtr surface, ref SDL_Rect rect)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_SetClipRect </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref <a class="el" href="struct_s_d_l___rect.html">SDL_Rect</a>&nbsp;</td>
          <td class="paramname"> <em>rect</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the clipping rectangle for a surface. </p>
<p>Sets the clipping rectangle for a surface. When this surface is the destination of a blit, only the area within the clip rectangle will be drawn into. </p>
<p>The rectangle pointed to by rect will be clipped to the edges of the surface so that the clip rectangle for a surface can never fall outside the edges of the surface. </p>
<p>If rect is NULL the clipping rectangle will be set to the full size of the surface. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">void</span> <a class="code" href="_sdl_8cs.html#a201a7363fdcfe07651a1298a3e4e1778" title="Sets the clipping rectangle for a surface.">SDL_SetClipRect</a>(<a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *surface, <a class="code" href="struct_s_d_l___rect.html" title="Defines a rectangular area.">SDL_Rect</a> *rect)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>surface</em>&nbsp;</td><td>IntPtr to <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rect</em>&nbsp;</td><td><a class="el" href="struct_s_d_l___rect.html" title="Defines a rectangular area.">SDL_Rect</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#ac51bb2502786730c93fd5c3cddf029f9" title="Gets the clipping rectangle for a surface.">SDL_GetClipRect</a></dd></dl>
<p>SDL_GetClipRect</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aec41f77b04d717457433acbecd7a257b" title="This performs a fast blit from the source surface to the destination surface.">SDL_BlitSurface</a></dd></dl>
<p>SDL_BlitSurface</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></dd></dl>
<p><a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></p>

</div>
</div>
<a class="anchor" id="a6143709fbf5b39f734e9de78cfa1d6c8"></a><!-- doxytag: member="Sdl.cs::SDL_SetColorKey" ref="a6143709fbf5b39f734e9de78cfa1d6c8" args="(IntPtr surface, int flag, int key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_SetColorKey </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the color key (transparent pixel) in a blittable surface and RLE acceleration. </p>
<p>Sets the color key (transparent pixel) in a blittable surface and enables or disables RLE blit acceleration. </p>
<p>RLE acceleration can substantially speed up blitting of images with large horizontal runs of transparent pixels (i.e., pixels that match the key value). The key must be of the same pixel format as the surface, <a class="el" href="_sdl_8cs.html#a8c6c5785c9010c08364e8abcd34648a0" title="Map a RGB color value to a pixel format.">SDL_MapRGB</a> is often useful for obtaining an acceptable value. </p>
<p>If flag is SDL_SRCCOLORKEY then key is the transparent pixel value in the source image of a blit. </p>
<p>If flag is OR'd with SDL_RLEACCEL then the surface will be draw using RLE acceleration when drawn with <a class="el" href="_sdl_8cs.html#aec41f77b04d717457433acbecd7a257b" title="This performs a fast blit from the source surface to the destination surface.">SDL_BlitSurface</a>. The surface will actually be encoded for RLE acceleration the first time <a class="el" href="_sdl_8cs.html#aec41f77b04d717457433acbecd7a257b" title="This performs a fast blit from the source surface to the destination surface.">SDL_BlitSurface</a> or <a class="el" href="_sdl_8cs.html#a557565508a6c32f7bb4703f040a622c1" title="Convert a surface to the display format.">SDL_DisplayFormat</a> is called on the surface. </p>
<p>If flag is 0, this function clears any current color key. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#a6143709fbf5b39f734e9de78cfa1d6c8" title="Sets the color key (transparent pixel) in a blittable surface and RLE acceleration.">SDL_SetColorKey</a>(<a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *surface, Uint32 flag, Uint32 key);
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>surface</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flag</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This function returns 0, or -1 if there was an error. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aec41f77b04d717457433acbecd7a257b" title="This performs a fast blit from the source surface to the destination surface.">SDL_BlitSurface</a></dd></dl>
<p>SDL_BlitSurface</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a557565508a6c32f7bb4703f040a622c1" title="Convert a surface to the display format.">SDL_DisplayFormat</a></dd></dl>
<p>SDL_DisplayFormat</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a8c6c5785c9010c08364e8abcd34648a0" title="Map a RGB color value to a pixel format.">SDL_MapRGB</a></dd></dl>
<p>SDL_MapRGB</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a77f6839de15f85b6c5afd9174894a41a" title="Adjust the alpha properties of a surface.">SDL_SetAlpha(IntPtr, int, byte)</a></dd></dl>
<p>SDL_SetAlpha</p>

</div>
</div>
<a class="anchor" id="a163c4948f939354528b9734d816beeb7"></a><!-- doxytag: member="Sdl.cs::SDL_SetColorKey" ref="a163c4948f939354528b9734d816beeb7" args="(IntPtr surface, uint flag, uint key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_SetColorKey </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the color key (transparent pixel) in a blittable surface and RLE acceleration. </p>
<p>Sets the color key (transparent pixel) in a blittable surface and enables or disables RLE blit acceleration. </p>
<p>RLE acceleration can substantially speed up blitting of images with large horizontal runs of transparent pixels (i.e., pixels that match the key value). The key must be of the same pixel format as the surface, <a class="el" href="_sdl_8cs.html#a8c6c5785c9010c08364e8abcd34648a0" title="Map a RGB color value to a pixel format.">SDL_MapRGB</a> is often useful for obtaining an acceptable value. </p>
<p>If flag is SDL_SRCCOLORKEY then key is the transparent pixel value in the source image of a blit. </p>
<p>If flag is OR'd with SDL_RLEACCEL then the surface will be draw using RLE acceleration when drawn with <a class="el" href="_sdl_8cs.html#aec41f77b04d717457433acbecd7a257b" title="This performs a fast blit from the source surface to the destination surface.">SDL_BlitSurface</a>. The surface will actually be encoded for RLE acceleration the first time <a class="el" href="_sdl_8cs.html#aec41f77b04d717457433acbecd7a257b" title="This performs a fast blit from the source surface to the destination surface.">SDL_BlitSurface</a> or <a class="el" href="_sdl_8cs.html#a557565508a6c32f7bb4703f040a622c1" title="Convert a surface to the display format.">SDL_DisplayFormat</a> is called on the surface. </p>
<p>If flag is 0, this function clears any current color key. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#a6143709fbf5b39f734e9de78cfa1d6c8" title="Sets the color key (transparent pixel) in a blittable surface and RLE acceleration.">SDL_SetColorKey</a>(<a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *surface, Uint32 flag, Uint32 key);
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>surface</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flag</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This function returns 0, or -1 if there was an error. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aec41f77b04d717457433acbecd7a257b" title="This performs a fast blit from the source surface to the destination surface.">SDL_BlitSurface</a></dd></dl>
<p>SDL_BlitSurface</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a557565508a6c32f7bb4703f040a622c1" title="Convert a surface to the display format.">SDL_DisplayFormat</a></dd></dl>
<p>SDL_DisplayFormat</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a8c6c5785c9010c08364e8abcd34648a0" title="Map a RGB color value to a pixel format.">SDL_MapRGB</a></dd></dl>
<p>SDL_MapRGB</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a77f6839de15f85b6c5afd9174894a41a" title="Adjust the alpha properties of a surface.">SDL_SetAlpha(IntPtr, int, byte)</a></dd></dl>
<p>SDL_SetAlpha</p>

</div>
</div>
<a class="anchor" id="ace1bdb02bdad276fcbce4b46012ba4b0"></a><!-- doxytag: member="Sdl.cs::SDL_SetColors" ref="ace1bdb02bdad276fcbce4b46012ba4b0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">....&lt;/example&gt;&lt;paramname=&quot;surface&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;firstcolor&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;ncolors&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;colors&quot;&gt;&lt;/param&gt;&lt;returns&gt; If <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a> is not a palettized this function does returning.If all of the <a class="el" href="_sdl_8cs.html#aece5a7af4770c985f1b8cc20246f5b28">colors</a> were set as passed to SDL_SetColors </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7d863c2bb7590dba1b9eb040d44449e7"></a><!-- doxytag: member="Sdl.cs::SDL_SetColors" ref="a7d863c2bb7590dba1b9eb040d44449e7" args="(IntPtr surface,[In, Out] SDL_Color[] colors, int firstcolor, int ncolors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">....&lt;/example&gt;&lt;paramname=&quot;surface&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;firstcolor&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;ncolors&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;colors&quot;&gt;&lt;/param&gt;&lt;returns&gt; If <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a> is not a palettized this function does returning.If all of the <a class="el" href="_sdl_8cs.html#aece5a7af4770c985f1b8cc20246f5b28">colors</a> were set as passed to it will return.If not all the color entries were set exactly as it will and you should look at the <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a> palette to determine the actual color palette.&lt;/returns&gt;&lt;seealsocref=&quot;SDL_Color&quot;&gt; SDL_Color&lt;/seealso&gt;&lt;seealsocref=&quot;SDL_Surface&quot;&gt; SDL_Surface&lt;/seealso&gt;&lt;seealsocref=&quot;SDL_SetPalette&quot;&gt; SDL_SetPalette&lt;/seealso&gt;&lt;seealsocref=&quot;SDL_SetVideoMode(int,int,int,int)&quot;&gt; SDL_SetVideoMode&lt;/seealso&gt;* static int SDL_SetColors </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In, Out] <a class="el" href="struct_s_d_l___color.html">SDL_Color</a>[]&nbsp;</td>
          <td class="paramname"> <em>colors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>firstcolor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ncolors</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad3dd27ac574c77908bc25298e847f77a"></a><!-- doxytag: member="Sdl.cs::SDL_SetColors" ref="ad3dd27ac574c77908bc25298e847f77a" args="(screen, colors, 0, 256)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDL_SetColors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_sdl_8cs.html#a968bba55c7ad32b326939fefd1bbb017">screen</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sdl_8cs.html#aece5a7af4770c985f1b8cc20246f5b28">colors</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">256&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6b58417a3cfb7d43adae3e661991ec1f"></a><!-- doxytag: member="Sdl.cs::SDL_SetCursor" ref="a6b58417a3cfb7d43adae3e661991ec1f" args="(ref SDL_Cursor cursor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_SetCursor </td>
          <td>(</td>
          <td class="paramtype">ref <a class="el" href="struct_s_d_l___cursor.html">SDL_Cursor</a>&nbsp;</td>
          <td class="paramname"> <em>cursor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the currently active cursor to the specified one. </p>
<p>Sets the currently active cursor to the specified one. If the cursor is currently visible, the change will be immediately represented on the display. </p>
<p>Binds to C-function call in SDL_mouse.h: </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">void</span> *<a class="code" href="_sdl_8cs.html#a6b58417a3cfb7d43adae3e661991ec1f" title="Set the currently active cursor to the specified one.">SDL_SetCursor</a>(<a class="code" href="struct_s_d_l___cursor.html">SDL_Cursor</a> *cursor);
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cursor</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a0a560b30afc5f63ddb75ea60a9ab8a2f" title="Returns the currently active cursor.">SDL_GetCursor</a>, <a class="el" href="_sdl_8cs.html#aab5253287140e2324b65aa03519ea6d8" title="Creates a new mouse cursor.">SDL_CreateCursor</a>, <a class="el" href="_sdl_8cs.html#a4e85211428ccac72ba71d06b2391ab06" title="Toggle whether or not the cursor is shown on the screen.">SDL_ShowCursor</a></dd></dl>

</div>
</div>
<a class="anchor" id="a9b33a09f6189c19b70c91f4d19ac03be"></a><!-- doxytag: member="Sdl.cs::SDL_SetError" ref="a9b33a09f6189c19b70c91f4d19ac03be" args="(string message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_SetError </td>
          <td>(</td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>message</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets an SDL error string. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>message</em>&nbsp;</td><td>The error message to set. </td></tr>
  </table>
  </dd>
</dl>
<p>Binds to C-function call in SDL_error.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">void</span> SDLCALL <a class="code" href="_sdl_8cs.html#a9b33a09f6189c19b70c91f4d19ac03be" title="Sets an SDL error string.">SDL_SetError</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ...)
</pre></div>  
</div>
</div>
<a class="anchor" id="afd1ab8f1891d71ad6544323050271d2d"></a><!-- doxytag: member="Sdl.cs::SDL_SetEventFilter" ref="afd1ab8f1891d71ad6544323050271d2d" args="(SDL_EventFilter filter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_SetEventFilter </td>
          <td>(</td>
          <td class="paramtype">SDL_EventFilter&nbsp;</td>
          <td class="paramname"> <em>filter</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets up a filter to process all events before they are posted to the event queue. </p>
<p>This function sets up a filter to process all events before they are posted to the event queue. This is a very powerful and flexible feature. The filter is prototyped as: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> int (*<a class="code" href="_sdl_8cs.html#a4c40631c6aad689b8c805e443823aa42" title="This function sets up a filter to process all events before they change internal state and are posted...">SDL_EventFilter</a>)(<span class="keyword">const</span> SDL_Event *event);
</pre></div> <p>If the filter returns 1, then the event will be added to the internal queue. If it returns 0, then the event will be dropped from the queue. This allows selective filtering of dynamically.  </p>
<p>There is one caveat when dealing with the SDL_QUITEVENT event type. The event filter is only called when the window manager desires to close the application window. If the event filter returns 1, then the window will be closed, otherwise the window will remain open if possible. If the quit event is generated by an interrupt signal, it will bypass the internal queue and be delivered to the application at the next event poll. </p>
<p>Note: Events pushed onto the queue with <a class="el" href="_sdl_8cs.html#a521bf458cc5cfc65b822c2b5b8226646" title="Pushes an event onto the event queue.">SDL_PushEvent</a> or SDL_PeepEvents(SDL_Event[], int, int, int) do not get passed through the event filter. </p>
<p>Note: Be Careful! The event filter function may run in a different thread so be careful what you do within it. </p>
<p>Binds to C-function in SDL_events.h </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="_sdl_8cs.html#afd1ab8f1891d71ad6544323050271d2d" title="Sets up a filter to process all events before they are posted to the event queue.">SDL_SetEventFilter</a>(<a class="code" href="_sdl_8cs.html#a4c40631c6aad689b8c805e443823aa42" title="This function sets up a filter to process all events before they change internal state and are posted...">SDL_EventFilter</a> filter);
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filter</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>SDL_Event, <a class="el" href="_sdl_8cs.html#aba4dab0b2d671d9f083744794ba77f2d" title="Retrieves a pointer to the event filter.">SDL_GetEventFilter</a>, <a class="el" href="_sdl_8cs.html#a521bf458cc5cfc65b822c2b5b8226646" title="Pushes an event onto the event queue.">SDL_PushEvent</a></dd></dl>

</div>
</div>
<a class="anchor" id="aec2c6c149b3567ffb29ff86bc202b43f"></a><!-- doxytag: member="Sdl.cs::SDL_SetGamma" ref="aec2c6c149b3567ffb29ff86bc202b43f" args="(float red, float green, float blue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_SetGamma </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>blue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the gamma correction for each of the color channels. </p>
<p>Sets the "gamma function" for the display of each color component. Gamma controls the brightness/contrast of colors displayed on the screen. A gamma value of 1.0 is identity (i.e., no adjustment is made).  </p>
<p>This function adjusts the gamma based on the "gamma function" parameter, you can directly specify lookup tables for gamma adjustment with SDL_SetGammaRamp. </p>
<p>Not all display hardware is able to change gamma. </p>
<p>The gamma values range (approximately) between 0.1 and 10.0. </p>
<p>If this function isn't supported directly by the hardware, it will be emulated using gamma ramps, if available. If successful, this function returns 0, otherwise it returns -1. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#aec2c6c149b3567ffb29ff86bc202b43f" title="Set the gamma correction for each of the color channels.">SDL_SetGamma</a>(<span class="keywordtype">float</span> red, <span class="keywordtype">float</span> green, <span class="keywordtype">float</span> blue)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>blue</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>green</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>red</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If successful, this function returns 0, otherwise it returns -1. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>SDL_GetGammaRamp(short[], short[], short[])</dd></dl>
<p>SDL_GetGammaRamp</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#add53fba5948db676ea3988e8d8b040cf" title="Set the gamma translation table for the red, green, and blue channels of the video hardware...">SDL_SetGammaRamp</a></dd></dl>
<p>SDL_SetGammaRamp</p>

</div>
</div>
<a class="anchor" id="add53fba5948db676ea3988e8d8b040cf"></a><!-- doxytag: member="Sdl.cs::SDL_SetGammaRamp" ref="add53fba5948db676ea3988e8d8b040cf" args="([In, Out] short[] red,[In, Out] short[] green,[In, Out] short[] blue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_SetGammaRamp </td>
          <td>(</td>
          <td class="paramtype">[In, Out] short[]&nbsp;</td>
          <td class="paramname"> <em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In, Out] short[]&nbsp;</td>
          <td class="paramname"> <em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In, Out] short[]&nbsp;</td>
          <td class="paramname"> <em>blue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the gamma translation table for the red, green, and blue channels of the video hardware. </p>
<p>Each table is an array of 256 16-bit quantities, representing a mapping between the input and output for that channel. The input is the index into the array, and the output is the 16-bit gamma value at that index, scaled to the output color precision. You may pass NULL for any of the channels to leave it unchanged.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>If the call succeeds, it will return 0. If the display driver or hardware does not support gamma translation, or otherwise fails, this function will return -1. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>blue</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>green</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>red</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aec2c6c149b3567ffb29ff86bc202b43f" title="Set the gamma correction for each of the color channels.">SDL_SetGamma</a></dd></dl>
<p>SDL_SetGamma</p>
<dl class="see"><dt><b>See also:</b></dt><dd>SDL_GetGammaRamp(short[], short[], short[])</dd></dl>
<p>SDL_GetGammaRamp</p>

</div>
</div>
<a class="anchor" id="a5d90d7264d596d72c47e57870d2c05fa"></a><!-- doxytag: member="Sdl.cs::SDL_SetModState" ref="a5d90d7264d596d72c47e57870d2c05fa" args="(int modstate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_SetModState </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>modstate</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the current key modifier state. </p>
<p>The inverse of SDL_GetModState, SDL_SetModState allows you to impose modifier key states on your application. </p>
<p>Simply pass your desired modifier states into modstate. This value my be a logical OR'd combination of SDLMod. </p>
<p>Binds to C-function in SDL_keyboard.h </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="_sdl_8cs.html#a5d90d7264d596d72c47e57870d2c05fa" title="Set the current key modifier state.">SDL_SetModState</a>(SDLMod modstate)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>modstate</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#acf4ace37b9b7f9383221e52a5b2113c3" title="Get the state of modifier keys.">SDL_GetModState</a></dd></dl>

</div>
</div>
<a class="anchor" id="a1f330365593a084550a4845aebe80441"></a><!-- doxytag: member="Sdl.cs::SDL_SetPalette" ref="a1f330365593a084550a4845aebe80441" args="(screen, SDL_LOGPAL|SDL_PHYSPAL, colors, 0, 256)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDL_SetPalette </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_sdl_8cs.html#a968bba55c7ad32b326939fefd1bbb017">screen</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_LOGPAL|&nbsp;</td>
          <td class="paramname"> <em>SDL_PHYSPAL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sdl_8cs.html#aece5a7af4770c985f1b8cc20246f5b28">colors</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">256&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afe8acab3b160f7859c903cec5fbb4f86"></a><!-- doxytag: member="Sdl.cs::SDL_SetPalette" ref="afe8acab3b160f7859c903cec5fbb4f86" args="(IntPtr surface, int flags,[In, Out] SDL_Color[] colors, int firstcolor, int ncolors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">....&lt;/code&gt;&lt;/example&gt;&lt;paramname=&quot;surface&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;colors&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;firstcolor&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;flags&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;ncolors&quot;&gt;&lt;/param&gt;&lt;returns&gt; If <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a> is not a palettized this function does returning.If all of the <a class="el" href="_sdl_8cs.html#aece5a7af4770c985f1b8cc20246f5b28">colors</a> were set as passed to it will return.If not all the color entries were set exactly as it will and you should look at the <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a> palette to determine the actual color palette.&lt;/returns&gt; * static int SDL_SetPalette </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In, Out] <a class="el" href="struct_s_d_l___color.html">SDL_Color</a>[]&nbsp;</td>
          <td class="paramname"> <em>colors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>firstcolor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ncolors</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a43f6e27a3a67800dd7c252305fe79839"></a><!-- doxytag: member="Sdl.cs::SDL_SetTimer" ref="a43f6e27a3a67800dd7c252305fe79839" args="(int interval, SDL_TimerCallback callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_SetTimer </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_TimerCallback&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a callback to run after the specified number of milliseconds has elapsed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>interval</em>&nbsp;</td><td>The timer interval. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>The callback to run. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The next timer interval. </dd></dl>
<p>The callback function is passed the current timer interval and returns the next timer interval. If the returned value is the same as the one passed in, the periodic alarm continues, otherwise a new alarm is scheduled. </p>
<p>To cancel a currently running timer, call <code>Sdl.SDL_SetTimer(0, null);</code> </p>
<p>The timer callback function may run in a different thread than your main constant, and so shouldn't call any functions from within itself. </p>
<p>The maximum resolution of this timer is 10 ms, which means that if you request a 16 ms timer, your callback will run approximately 20 ms later on an unloaded system. If you wanted to set a flag signaling a frame update at 30 frames per second (every 33 ms), you might set a timer for 30 ms. </p>
<p>If you use this function, you need to pass SDL_INIT_TIMER to SDL_Init(int). </p>
<p>This function is kept for compatibility but has been superseded by the new timer functions <a class="el" href="_sdl_8cs.html#a0847fd552fc17aa314f866ac16db60df" title="Add a timer which will call a callback after the specified number of milliseconds has elapsed...">SDL_AddTimer(int, SDL_NewTimerCallback)</a> and <a class="el" href="_sdl_8cs.html#a135aaf0e0425b1dcf1904b966509c3c0" title="Remove a timer which was added with SDL_AddTimer(int, SDL_NewTimerCallback).">SDL_RemoveTimer</a> which support multiple timers. </p>
<p>Binds to C-function call in SDL_timer.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#a43f6e27a3a67800dd7c252305fe79839" title="Set a callback to run after the specified number of milliseconds has elapsed.">SDL_SetTimer</a>(Uint32 interval, 
                <a class="code" href="_sdl_8cs.html#a43a7c7ef24b53b00cb058b4e7d446d75" title="Prototype for the timer callback.">SDL_TimerCallback</a> callback)
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a0847fd552fc17aa314f866ac16db60df" title="Add a timer which will call a callback after the specified number of milliseconds has elapsed...">SDL_AddTimer(int, SDL_NewTimerCallback)</a>, <a class="el" href="_sdl_8cs.html#a43a7c7ef24b53b00cb058b4e7d446d75" title="Prototype for the timer callback.">SDL_TimerCallback</a></dd></dl>

</div>
</div>
<a class="anchor" id="a7e9d2d16dfb1cdd312f1d0b45f989dcc"></a><!-- doxytag: member="Sdl.cs::SDL_SetTimer" ref="a7e9d2d16dfb1cdd312f1d0b45f989dcc" args="(uint interval, SDL_TimerCallback callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_SetTimer </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDL_TimerCallback&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a callback to run after the specified number of milliseconds has elapsed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>interval</em>&nbsp;</td><td>The timer interval. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>The callback to run. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The next timer interval. </dd></dl>
<p>The callback function is passed the current timer interval and returns the next timer interval. If the returned value is the same as the one passed in, the periodic alarm continues, otherwise a new alarm is scheduled. </p>
<p>To cancel a currently running timer, call <code>Sdl.SDL_SetTimer(0, null);</code> </p>
<p>The timer callback function may run in a different thread than your main constant, and so shouldn't call any functions from within itself. </p>
<p>The maximum resolution of this timer is 10 ms, which means that if you request a 16 ms timer, your callback will run approximately 20 ms later on an unloaded system. If you wanted to set a flag signaling a frame update at 30 frames per second (every 33 ms), you might set a timer for 30 ms. </p>
<p>If you use this function, you need to pass SDL_INIT_TIMER to SDL_Init(int). </p>
<p>This function is kept for compatibility but has been superseded by the new timer functions <a class="el" href="_sdl_8cs.html#a0847fd552fc17aa314f866ac16db60df" title="Add a timer which will call a callback after the specified number of milliseconds has elapsed...">SDL_AddTimer(int, SDL_NewTimerCallback)</a> and <a class="el" href="_sdl_8cs.html#a135aaf0e0425b1dcf1904b966509c3c0" title="Remove a timer which was added with SDL_AddTimer(int, SDL_NewTimerCallback).">SDL_RemoveTimer</a> which support multiple timers. </p>
<p>Binds to C-function call in SDL_timer.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#a43f6e27a3a67800dd7c252305fe79839" title="Set a callback to run after the specified number of milliseconds has elapsed.">SDL_SetTimer</a>(Uint32 interval, 
                <a class="code" href="_sdl_8cs.html#a43a7c7ef24b53b00cb058b4e7d446d75" title="Prototype for the timer callback.">SDL_TimerCallback</a> callback)
</pre></div>  <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a43a7c7ef24b53b00cb058b4e7d446d75" title="Prototype for the timer callback.">SDL_TimerCallback</a></dd></dl>

</div>
</div>
<a class="anchor" id="a9f7878de4f7e109ea2485a4865d81afd"></a><!-- doxytag: member="Sdl.cs::SDL_SetVideoMode" ref="a9f7878de4f7e109ea2485a4865d81afd" args="(int width, int height, int bpp, uint flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_SetVideoMode </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set up a video mode with the specified width, height and bits-per-pixel. </p>
<p>If 'bpp' is 0, it is treated as the current display bits per pixel. </p>
<p>The flags parameter is the same as the flags field of the <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> structure. OR'd combinations of the following values are valid.  </p>
<table  type="table">
<tr>
<th>Flag</b> </th><th>Description  </th></tr>
<tr>
<td>SDL_SWSURFACE</b> </td><td>Create the video surface in system memory.  </td></tr>
<tr>
<td>SDL_HWSURFACE</b> </td><td>Create the video surface in video memory ,if possible, and you may have to call <a class="el" href="_sdl_8cs.html#ad1c3562c62aaf55f95641f0bafab9e8f" title="Lock a surface for directly access.">SDL_LockSurface()</a> in order to access the raw framebuffer. Otherwise, the video surface will be created in system memory.  </td></tr>
<tr>
<td>SDL_ASYNCBLIT</b> </td><td>Enables the use of asynchronous updates of the display surface, but you must always lock before accessing pixels. SDL will wait for updates to complete before returning from the lock. This will usually slow down blitting on single CPU machines, but may provide a speed increase on SMP systems.  </td></tr>
<tr>
<td>SDL_ANYFORMAT</b> </td><td>Normally, if a video surface of the requested bits-per-pixel (bpp) is not available, SDL will emulate one with a shadow surface. Passing SDL_ANYFORMAT prevents this and causes SDL to use the video surface, regardless of its pixel depth.  </td></tr>
<tr>
<td>SDL_HWPALETTE</b> </td><td>Give SDL exclusive palette access. Without this flag you may not always get the the colors you request with <a class="el" href="_sdl_8cs.html#a7d863c2bb7590dba1b9eb040d44449e7">SDL_SetColors</a> or <a class="el" href="_sdl_8cs.html#afe8acab3b160f7859c903cec5fbb4f86">SDL_SetPalette</a>. You should look at the video surface structure to determine the actual palette. If SDL cannot guarantee that the colors you request can be set, i.e. if the colormap is shared, then the video surface may be created under emulation in system memory, overriding the SDL_HWSURFACE flag.   </td></tr>
<tr>
<td>SDL_DOUBLEBUF</b> </td><td>Enable hardware double buffering; only valid with SDL_HWSURFACE. Calling <a class="el" href="_sdl_8cs.html#acc195af71a1137f48f929bf559d72bc0" title="Swaps screen buffers.">SDL_Flip</a> will flip the buffers and update the screen. All drawing will take place on the surface that is not displayed at the moment. If double buffering could not be enabled then SDL_Flip will just perform a SDL_UpdateRect(System.IntPtr, int, int, int, int) on the entire screen. This is usually slower than the normal single-buffering scheme, but prevents "tearing" artifacts caused by modifying video memory while the monitor is refreshing. It should only be used by applications that redraw the entire screen on every update.  </td></tr>
<tr>
<td>SDL_FULLSCREEN</b> </td><td>SDL will attempt to use a fullscreen mode. If a hardware resolution change is not possible (for whatever reason), the next higher resolution will be used and the display window centered on a black background. The default is to create a windowed mode if the current graphics system has a window manager. If the SDL library is able to set a fullscreen video mode, this flag will be set in the surface that is returned.  </td></tr>
<tr>
<td>SDL_OPENGL</b> </td><td>Create an OpenGL rendering context. You should have previously set OpenGL video attributes with <a class="el" href="_sdl_8cs.html#a9d12980991f938865faa9cc236d88825" title="Set a special SDL/OpenGL attribute.">SDL_GL_SetAttribute</a>.   </td></tr>
<tr>
<td>SDL_OPENGLBLIT</b> </td><td>Create an OpenGL rendering context, like above, but allow normal blitting operations. The screen (2D) surface may have an alpha channel, and <a class="el" href="_sdl_8cs.html#a7a553064b9c7c9be654714fa618d67db" title="Makes sure the given list of rectangles is updated on the given screen.">SDL_UpdateRects</a> must be used for updating changes to the screen surface. NOTE: This option is kept for compatibility only, and is not recommended for new code.   </td></tr>
<tr>
<td>SDL_RESIZABLE</b> </td><td>Create a resizable window. When the window is resized by the user a SDL_VIDEORESIZE event is generated and SDL_SetVideoMode can be called again with the new size.   </td></tr>
<tr>
<td>SDL_NOFRAME</b> </td><td>If possible, SDL_NOFRAME causes SDL to create a window with no title bar or frame decoration. Fullscreen modes automatically have this flag set.   </td></tr>
</table>
<p>If you rely on functionality provided by certain video flags, check the flags of the returned surface to make sure that functionality is available. SDL will fall back to reduced functionality if the exact flags you wanted are not available. </p>
<p>Whatever flags SDL_SetVideoMode could satisfy are set in the flags member of the returned surface. </p>
<p>The bpp parameter is the number of bits per pixel, so a bpp of 24 uses the packed representation of 3 bytes/pixel. For the more common 4 bytes/pixel mode, use a bpp of 32. Somewhat oddly, both 15 and 16 will request a 2 bytes/pixel mode, but different pixel formats.  </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> * SDLCALL <a class="code" href="_sdl_8cs.html#a961f7efdc2a7ec3860e93140853092f7" title="Set up a video mode with the specified width, height and bits-per-pixel.">SDL_SetVideoMode</a>
            (<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height, <span class="keywordtype">int</span> bpp, Uint32 flags);
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#afae9570bf3fb2b26f7403cb1fc4f1353">SDL_LockSurface</a></dd></dl>
<p>SDL_LockSurface</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a7d863c2bb7590dba1b9eb040d44449e7">SDL_SetColors</a></dd></dl>
<p>SDL_SetColors</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#acc195af71a1137f48f929bf559d72bc0" title="Swaps screen buffers.">SDL_Flip</a></dd></dl>
<p>SDL_Flip</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></dd></dl>
<p><a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bpp</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The framebuffer surface, or NULL if it fails. The surface returned is freed by <a class="el" href="_sdl_8cs.html#a3acfba2794297d8a0a6d5b047dbaa53c" title="Shuts down SDL.">SDL_Quit()</a> and should not be freed by the caller. </dd></dl>

</div>
</div>
<a class="anchor" id="a961f7efdc2a7ec3860e93140853092f7"></a><!-- doxytag: member="Sdl.cs::SDL_SetVideoMode" ref="a961f7efdc2a7ec3860e93140853092f7" args="(int width, int height, int bpp, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr SDL_SetVideoMode </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set up a video mode with the specified width, height and bits-per-pixel. </p>
<p>If 'bpp' is 0, it is treated as the current display bits per pixel. </p>
<p>The flags parameter is the same as the flags field of the <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> structure. OR'd combinations of the following values are valid.  </p>
<table  type="table">
<tr>
<th>Flag</b> </th><th>Description  </th></tr>
<tr>
<td>SDL_SWSURFACE</b> </td><td>Create the video surface in system memory.  </td></tr>
<tr>
<td>SDL_HWSURFACE</b> </td><td>Create the video surface in video memory ,if possible, and you may have to call <a class="el" href="_sdl_8cs.html#ad1c3562c62aaf55f95641f0bafab9e8f" title="Lock a surface for directly access.">SDL_LockSurface()</a> in order to access the raw framebuffer. Otherwise, the video surface will be created in system memory.  </td></tr>
<tr>
<td>SDL_ASYNCBLIT</b> </td><td>Enables the use of asynchronous updates of the display surface, but you must always lock before accessing pixels. SDL will wait for updates to complete before returning from the lock. This will usually slow down blitting on single CPU machines, but may provide a speed increase on SMP systems.  </td></tr>
<tr>
<td>SDL_ANYFORMAT</b> </td><td>Normally, if a video surface of the requested bits-per-pixel (bpp) is not available, SDL will emulate one with a shadow surface. Passing SDL_ANYFORMAT prevents this and causes SDL to use the video surface, regardless of its pixel depth.  </td></tr>
<tr>
<td>SDL_HWPALETTE</b> </td><td>Give SDL exclusive palette access. Without this flag you may not always get the the colors you request with <a class="el" href="_sdl_8cs.html#a7d863c2bb7590dba1b9eb040d44449e7">SDL_SetColors</a> or <a class="el" href="_sdl_8cs.html#afe8acab3b160f7859c903cec5fbb4f86">SDL_SetPalette</a>. You should look at the video surface structure to determine the actual palette. If SDL cannot guarantee that the colors you request can be set, i.e. if the colormap is shared, then the video surface may be created under emulation in system memory, overriding the SDL_HWSURFACE flag.   </td></tr>
<tr>
<td>SDL_DOUBLEBUF</b> </td><td>Enable hardware double buffering; only valid with SDL_HWSURFACE. Calling <a class="el" href="_sdl_8cs.html#acc195af71a1137f48f929bf559d72bc0" title="Swaps screen buffers.">SDL_Flip</a> will flip the buffers and update the screen. All drawing will take place on the surface that is not displayed at the moment. If double buffering could not be enabled then SDL_Flip will just perform a SDL_UpdateRect(System.IntPtr, int, int, int, int) on the entire screen. This is usually slower than the normal single-buffering scheme, but prevents "tearing" artifacts caused by modifying video memory while the monitor is refreshing. It should only be used by applications that redraw the entire screen on every update.  </td></tr>
<tr>
<td>SDL_FULLSCREEN</b> </td><td>SDL will attempt to use a fullscreen mode. If a hardware resolution change is not possible (for whatever reason), the next higher resolution will be used and the display window centered on a black background. The default is to create a windowed mode if the current graphics system has a window manager. If the SDL library is able to set a fullscreen video mode, this flag will be set in the surface that is returned.  </td></tr>
<tr>
<td>SDL_OPENGL</b> </td><td>Create an OpenGL rendering context. You should have previously set OpenGL video attributes with <a class="el" href="_sdl_8cs.html#a9d12980991f938865faa9cc236d88825" title="Set a special SDL/OpenGL attribute.">SDL_GL_SetAttribute</a>.   </td></tr>
<tr>
<td>SDL_OPENGLBLIT</b> </td><td>Create an OpenGL rendering context, like above, but allow normal blitting operations. The screen (2D) surface may have an alpha channel, and <a class="el" href="_sdl_8cs.html#a7a553064b9c7c9be654714fa618d67db" title="Makes sure the given list of rectangles is updated on the given screen.">SDL_UpdateRects</a> must be used for updating changes to the screen surface. NOTE: This option is kept for compatibility only, and is not recommended for new code.   </td></tr>
<tr>
<td>SDL_RESIZABLE</b> </td><td>Create a resizable window. When the window is resized by the user a SDL_VIDEORESIZE event is generated and SDL_SetVideoMode can be called again with the new size.   </td></tr>
<tr>
<td>SDL_NOFRAME</b> </td><td>If possible, SDL_NOFRAME causes SDL to create a window with no title bar or frame decoration. Fullscreen modes automatically have this flag set.   </td></tr>
</table>
<p>If you rely on functionality provided by certain video flags, check the flags of the returned surface to make sure that functionality is available. SDL will fall back to reduced functionality if the exact flags you wanted are not available. </p>
<p>Whatever flags SDL_SetVideoMode could satisfy are set in the flags member of the returned surface. </p>
<p>The bpp parameter is the number of bits per pixel, so a bpp of 24 uses the packed representation of 3 bytes/pixel. For the more common 4 bytes/pixel mode, use a bpp of 32. Somewhat oddly, both 15 and 16 will request a 2 bytes/pixel mode, but different pixel formats.  </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> * SDLCALL <a class="code" href="_sdl_8cs.html#a961f7efdc2a7ec3860e93140853092f7" title="Set up a video mode with the specified width, height and bits-per-pixel.">SDL_SetVideoMode</a>
            (<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height, <span class="keywordtype">int</span> bpp, Uint32 flags);
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#afae9570bf3fb2b26f7403cb1fc4f1353">SDL_LockSurface</a></dd></dl>
<p>SDL_LockSurface</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a7d863c2bb7590dba1b9eb040d44449e7">SDL_SetColors</a></dd></dl>
<p>SDL_SetColors</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#acc195af71a1137f48f929bf559d72bc0" title="Swaps screen buffers.">SDL_Flip</a></dd></dl>
<p>SDL_Flip</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></dd></dl>
<p><a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bpp</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The framebuffer surface, or NULL if it fails. The surface returned is freed by <a class="el" href="_sdl_8cs.html#a3acfba2794297d8a0a6d5b047dbaa53c" title="Shuts down SDL.">SDL_Quit()</a> and should not be freed by the caller. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e85211428ccac72ba71d06b2391ab06"></a><!-- doxytag: member="Sdl.cs::SDL_ShowCursor" ref="a4e85211428ccac72ba71d06b2391ab06" args="(int toggle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_ShowCursor </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>toggle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Toggle whether or not the cursor is shown on the screen. </p>
<p>Toggle whether or not the cursor is shown on the screen. Passing SDL_ENABLE displays the cursor and passing SDL_DISABLE hides it. The current state of the mouse cursor can be queried by passing SDL_QUERY, either SDL_DISABLE or SDL_ENABLE will be returned. </p>
<p>The cursor starts off displayed, but can be turned off.  </p>
<p>Binds to C-function call in SDL_mouse.h: </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#a4e85211428ccac72ba71d06b2391ab06" title="Toggle whether or not the cursor is shown on the screen.">SDL_ShowCursor</a>(<span class="keywordtype">int</span> toggle);
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>toggle</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aab5253287140e2324b65aa03519ea6d8" title="Creates a new mouse cursor.">SDL_CreateCursor</a>, <a class="el" href="_sdl_8cs.html#a6b58417a3cfb7d43adae3e661991ec1f" title="Set the currently active cursor to the specified one.">SDL_SetCursor</a></dd></dl>

</div>
</div>
<a class="anchor" id="a4b5bdffdeb7867e252b6272b4aee0964"></a><!-- doxytag: member="Sdl.cs::SDL_ThreadID" ref="a4b5bdffdeb7867e252b6272b4aee0964" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_ThreadID </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the 32-bit thread identifier for the current thread. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>ID </dd></dl>
<p>Binds to C-function call in SDL_thread.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC Uint32 SDLCALL <a class="code" href="_sdl_8cs.html#a4b5bdffdeb7867e252b6272b4aee0964" title="Get the 32-bit thread identifier for the current thread.">SDL_ThreadID</a>(<span class="keywordtype">void</span>)
</pre></div>  
</div>
</div>
<a class="anchor" id="a43a7c7ef24b53b00cb058b4e7d446d75"></a><!-- doxytag: member="Sdl.cs::SDL_TimerCallback" ref="a43a7c7ef24b53b00cb058b4e7d446d75" args="(int interval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">delegate int SDL_TimerCallback </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>interval</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prototype for the timer callback. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>interval</em>&nbsp;</td><td>The current timer interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The next timer interval. </dd></dl>
<p>Binds to C callback in SDL_timer.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> Uint32 (SDLCALL *<a class="code" href="_sdl_8cs.html#a43a7c7ef24b53b00cb058b4e7d446d75" title="Prototype for the timer callback.">SDL_TimerCallback</a>)(Uint32 interval, <span class="keywordtype">void</span> *param)
</pre></div>  
</div>
</div>
<a class="anchor" id="a39ec0a82df272b96dec07e31b7da403a"></a><!-- doxytag: member="Sdl.cs::SDL_UnloadObject" ref="a39ec0a82df272b96dec07e31b7da403a" args="(IntPtr handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_UnloadObject </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unload a shared object from memory. </p>
<p>Binds to C-function in SDL_loadso.h </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">void</span> * SDLCALL <a class="code" href="_sdl_8cs.html#a39ec0a82df272b96dec07e31b7da403a" title="Unload a shared object from memory.">SDL_UnloadObject</a>(<span class="keywordtype">void</span> *handle)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Object handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aea95d437c48a63fc2b057278ab0b9c69" title="Given an object handle, this function looks up the address of the named function in the shared object...">SDL_LoadFunction</a>, <a class="el" href="_sdl_8cs.html#adf86ae9120ae0ea0fb602dfa34401edc" title="This function dynamically loads a shared object and returns a pointer to the object handle (or NULL i...">SDL_LoadObject</a></dd></dl>

</div>
</div>
<a class="anchor" id="a0a82eaee2425abf8428bca38acbbd8e6"></a><!-- doxytag: member="Sdl.cs::SDL_UnlockAudio" ref="a0a82eaee2425abf8428bca38acbbd8e6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_UnlockAudio </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlock the callback function. </p>
<p>Unlocks a previous <a class="el" href="_sdl_8cs.html#a228aa7a773a8820468022d53fed4ecd2" title="Lock out the callback function.">SDL_LockAudio</a> call. </p>
<p>Binds to C-function call in SDL_audio.h: </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">void</span> <a class="code" href="_sdl_8cs.html#a0a82eaee2425abf8428bca38acbbd8e6" title="Unlock the callback function.">SDL_UnlockAudio</a>(<span class="keywordtype">void</span>)
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#ad374c9d61753113b30c8c4b96295ff3b" title="Opens the audio device with the desired parameters.">SDL_OpenAudio</a></dd></dl>

</div>
</div>
<a class="anchor" id="a575d113e5463394a260668c1eb9a7390"></a><!-- doxytag: member="Sdl.cs::SDL_UnlockSurface" ref="a575d113e5463394a260668c1eb9a7390" args="(surface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDL_UnlockSurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a>&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7a8e68d1721140930c21ac9e793a0a1a"></a><!-- doxytag: member="Sdl.cs::SDL_UnlockSurface" ref="a7a8e68d1721140930c21ac9e793a0a1a" args="(IntPtr surface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_UnlockSurface </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>surface</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlocks a previously locked surface. </p>
<p>Surfaces that were previously locked using <a class="el" href="_sdl_8cs.html#afae9570bf3fb2b26f7403cb1fc4f1353">SDL_LockSurface</a> must be unlocked with SDL_UnlockSurface. Surfaces should be unlocked as soon as possible. </p>
<p>It should be noted that since 1.1.8, surface locks are recursive. See <a class="el" href="_sdl_8cs.html#afae9570bf3fb2b26f7403cb1fc4f1353">SDL_LockSurface</a>. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="_sdl_8cs.html#a575d113e5463394a260668c1eb9a7390">SDL_UnlockSurface</a>(<a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *surface)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>surface</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#afae9570bf3fb2b26f7403cb1fc4f1353">SDL_LockSurface</a></dd></dl>
<p>SDL_LockSurface</p>

</div>
</div>
<a class="anchor" id="a593554f2e6f34c6fed0c39295884b85d"></a><!-- doxytag: member="Sdl.cs::SDL_UnlockYUVOverlay" ref="a593554f2e6f34c6fed0c39295884b85d" args="(IntPtr overlay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_UnlockYUVOverlay </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>overlay</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlock an overlay. </p>
<p>The opposite to <a class="el" href="_sdl_8cs.html#aef75e3a4590a542c940f024fa387031d" title="Lock an overlay.">SDL_LockYUVOverlay</a>. Unlocks a previously locked overlay. An overlay must be unlocked before it can be displayed. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> SDLCALL <a class="code" href="_sdl_8cs.html#a593554f2e6f34c6fed0c39295884b85d" title="Unlock an overlay.">SDL_UnlockYUVOverlay</a>(<a class="code" href="struct_s_d_l___overlay.html" title="The YUV hardware video overlay.">SDL_Overlay</a> *overlay)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>overlay</em>&nbsp;</td><td>IntPtr to <a class="el" href="struct_s_d_l___overlay.html" title="The YUV hardware video overlay.">SDL_Overlay</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a593554f2e6f34c6fed0c39295884b85d" title="Unlock an overlay.">SDL_UnlockYUVOverlay</a>, <a class="el" href="_sdl_8cs.html#a433c9c002d6c6a4a3077fc12ff790372" title="Create a YUV video overlay.">SDL_CreateYUVOverlay(int, int, int, IntPtr)</a>, <a class="el" href="struct_s_d_l___overlay.html" title="The YUV hardware video overlay.">SDL_Overlay</a></dd></dl>

</div>
</div>
<a class="anchor" id="a332672dbfad4d5a62f042f8039203de1"></a><!-- doxytag: member="Sdl.cs::SDL_UpdateRect" ref="a332672dbfad4d5a62f042f8039203de1" args="(IntPtr screen, int x, int y, int w, int h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_UpdateRect </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>screen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>h</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Makes sure the given area is updated on the given screen. </p>
<p>The rectangle must be confined within the screen boundaries (no clipping is done).  </p>
<p>If 'x', 'y', 'w' and 'h' are all 0, SDL_UpdateRect will update the entire screen. </p>
<p>These functions should not be called while 'screen' is <a class="el" href="">locked</a>. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">void</span> SDLCALL <a class="code" href="_sdl_8cs.html#a332672dbfad4d5a62f042f8039203de1" title="Makes sure the given area is updated on the given screen.">SDL_UpdateRect</a> (<a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *<a class="code" href="_sdl_8cs.html#a968bba55c7ad32b326939fefd1bbb017" title="Sets a portion of the colormap for the given 8-bit surface.">screen</a>, Sint32 x, Sint32 y, Uint32 w, Uint32 <a class="code" href="_sdl_8cs.html#ae53b59602879361d91ef9a2bdd5ae091">h</a>)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>screen</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a918ef68b4ae9d6cb43373143d05e187d"></a><!-- doxytag: member="Sdl.cs::SDL_UpdateRect" ref="a918ef68b4ae9d6cb43373143d05e187d" args="(IntPtr screen, int x, int y, uint w, uint h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_UpdateRect </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>screen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>h</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Makes sure the given area is updated on the given screen. </p>
<p>The rectangle must be confined within the screen boundaries (no clipping is done).  </p>
<p>If 'x', 'y', 'w' and 'h' are all 0, SDL_UpdateRect will update the entire screen. </p>
<p>These functions should not be called while 'screen' is <a class="el" href="">locked</a>. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">void</span> SDLCALL <a class="code" href="_sdl_8cs.html#a332672dbfad4d5a62f042f8039203de1" title="Makes sure the given area is updated on the given screen.">SDL_UpdateRect</a> (<a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *screen, Sint32 x, Sint32 y, Uint32 w, Uint32 h)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>screen</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a553064b9c7c9be654714fa618d67db"></a><!-- doxytag: member="Sdl.cs::SDL_UpdateRects" ref="a7a553064b9c7c9be654714fa618d67db" args="(IntPtr screen, int numrects,[In, Out] SDL_Rect[] rects)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_UpdateRects </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>screen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numrects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[In, Out] <a class="el" href="struct_s_d_l___rect.html">SDL_Rect</a>[]&nbsp;</td>
          <td class="paramname"> <em>rects</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Makes sure the given list of rectangles is updated on the given screen. </p>
<p>The rectangles must all be confined within the screen boundaries (no clipping is done). </p>
<p>This function should not be called while screen is locked.  </p>
<p>Note: It is adviced to call this function only once per frame, since each call has some processing overhead. This is no restriction since you can pass any number of rectangles each time.  </p>
<p>The rectangles are not automatically merged or checked for overlap. In general, the programmer can use his knowledge about his particular rectangles to merge them in an efficient way, to avoid overdraw. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">void</span> SDLCALL <a class="code" href="_sdl_8cs.html#a7a553064b9c7c9be654714fa618d67db" title="Makes sure the given list of rectangles is updated on the given screen.">SDL_UpdateRects</a> (<a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *screen, <span class="keywordtype">int</span> numrects, <a class="code" href="struct_s_d_l___rect.html" title="Defines a rectangular area.">SDL_Rect</a> *rects)
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd>SDL_UpdateRect(System.IntPtr, int, int, int, int)</dd></dl>
<p>SDL_UpdateRect</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_s_d_l___rect.html" title="Defines a rectangular area.">SDL_Rect</a></dd></dl>
<p><a class="el" href="struct_s_d_l___rect.html" title="Defines a rectangular area.">SDL_Rect</a></p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></dd></dl>
<p><a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#afae9570bf3fb2b26f7403cb1fc4f1353">SDL_LockSurface</a></dd></dl>
<p>SDL_LockSurface</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>screen</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numrects</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rects</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac022f5f4d029ec3d89f6257b8f716951"></a><!-- doxytag: member="Sdl.cs::SDL_VideoModeOK" ref="ac022f5f4d029ec3d89f6257b8f716951" args="(int width, int height, int bpp, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_VideoModeOK </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check to see if a particular video mode is supported. </p>
<p>SDL_VideoModeOK returns 0 if the requested mode is not supported under any bit depth, or returns the bits-per-pixel of the closest available mode with the given width, height and requested <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> flags. See <a class="el" href="_sdl_8cs.html#a961f7efdc2a7ec3860e93140853092f7" title="Set up a video mode with the specified width, height and bits-per-pixel.">SDL_SetVideoMode(int, int, int, int)</a>. </p>
<p>The bits-per-pixel value returned is only a suggested mode. You can usually request and bpp you want when setting the video mode and SDL will emulate that color depth with a shadow video surface.  </p>
<p>The arguments to <a class="el" href="_sdl_8cs.html#ac022f5f4d029ec3d89f6257b8f716951" title="Check to see if a particular video mode is supported.">SDL_VideoModeOK()</a> are the same ones you would pass to <a class="el" href="_sdl_8cs.html#a961f7efdc2a7ec3860e93140853092f7" title="Set up a video mode with the specified width, height and bits-per-pixel.">SDL_SetVideoMode(int, int, int, int)</a>  </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#ac022f5f4d029ec3d89f6257b8f716951" title="Check to see if a particular video mode is supported.">SDL_VideoModeOK</a>(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height, <span class="keywordtype">int</span> bpp, Uint32 flags)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>Width of mode</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>Height of mode</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bpp</em>&nbsp;</td><td>bit depth of Mode</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a7af0f2e30f654a9e5f260d561fe09ef8"></a><!-- doxytag: member="Sdl.cs::SDL_VideoModeOK" ref="a7af0f2e30f654a9e5f260d561fe09ef8" args="(int width, int height, int bpp, uint flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_VideoModeOK </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check to see if a particular video mode is supported. </p>
<p>SDL_VideoModeOK returns 0 if the requested mode is not supported under any bit depth, or returns the bits-per-pixel of the closest available mode with the given width, height and requested <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> flags. See <a class="el" href="_sdl_8cs.html#a961f7efdc2a7ec3860e93140853092f7" title="Set up a video mode with the specified width, height and bits-per-pixel.">SDL_SetVideoMode(int, int, int, int)</a>. </p>
<p>The bits-per-pixel value returned is only a suggested mode. You can usually request and bpp you want when setting the video mode and SDL will emulate that color depth with a shadow video surface.  </p>
<p>The arguments to <a class="el" href="_sdl_8cs.html#ac022f5f4d029ec3d89f6257b8f716951" title="Check to see if a particular video mode is supported.">SDL_VideoModeOK()</a> are the same ones you would pass to <a class="el" href="_sdl_8cs.html#a961f7efdc2a7ec3860e93140853092f7" title="Set up a video mode with the specified width, height and bits-per-pixel.">SDL_SetVideoMode(int, int, int, int)</a>  </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#ac022f5f4d029ec3d89f6257b8f716951" title="Check to see if a particular video mode is supported.">SDL_VideoModeOK</a>(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height, <span class="keywordtype">int</span> bpp, Uint32 flags)
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>Width of mode</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>Height of mode</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bpp</em>&nbsp;</td><td>bit depth of Mode</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a6cf955d55444b337d368ea677e99b6f9"></a><!-- doxytag: member="Sdl.cs::SDL_WaitEvent" ref="a6cf955d55444b337d368ea677e99b6f9" args="(out SDL_Event evt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_WaitEvent </td>
          <td>(</td>
          <td class="paramtype">out SDL_Event&nbsp;</td>
          <td class="paramname"> <em>evt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Waits indefinitely for the next available event. </p>
<p>Waits indefinitely for the next available event, returning 1, or 0 if there was an error while waiting for events. </p>
<p>If 'event' is not NULL, the next event is removed from the queue and stored in that area. </p>
<p>Binds to C-function in SDL_events.h </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#a6cf955d55444b337d368ea677e99b6f9" title="Waits indefinitely for the next available event.">SDL_WaitEvent</a>(SDL_Event *event);
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>evt</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 1, or 0 if there was an error while waiting for events</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>SDL_Event, <a class="el" href="_sdl_8cs.html#a85f90a4d8d6ae6e2ab13c9e286a9afd2" title="Polls for currently pending events.">SDL_PollEvent</a></dd></dl>

</div>
</div>
<a class="anchor" id="aa3d063882199499f0ce29c84ac2a1ddb"></a><!-- doxytag: member="Sdl.cs::SDL_WaitThread" ref="aa3d063882199499f0ce29c84ac2a1ddb" args="(IntPtr thread, out int status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_WaitThread </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out int&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for a thread to finish. The return code for the thread function is placed in the area pointed to by 'status', if 'status' is not NULL. </p>
<p>Binds to C-function call in SDL_thread.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">void</span> SDLCALL <a class="code" href="_sdl_8cs.html#aa3d063882199499f0ce29c84ac2a1ddb" title="Wait for a thread to finish. The return code for the thread function is placed in the area pointed to...">SDL_WaitThread</a>(SDL_Thread *thread, <span class="keywordtype">int</span> *status)
</pre></div>  
</div>
</div>
<a class="anchor" id="a1f870df2b13fdb36e3ea8a10aab057ca"></a><!-- doxytag: member="Sdl.cs::SDL_WarpMouse" ref="a1f870df2b13fdb36e3ea8a10aab057ca" args="(short x, short y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_WarpMouse </td>
          <td>(</td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the position of the mouse cursor. </p>
<p>Set the position of the mouse cursor (generates a mouse motion event). </p>
<p>Binds to C-function call in SDL_mouse.h: </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">void</span> <a class="code" href="_sdl_8cs.html#a1f870df2b13fdb36e3ea8a10aab057ca" title="Set the position of the mouse cursor.">SDL_WarpMouse</a>(Uint16 x, Uint16 y);
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>SDL_MouseMotionEvent</dd></dl>

</div>
</div>
<a class="anchor" id="ac89483738346b9445fd60502f9f93e71"></a><!-- doxytag: member="Sdl.cs::SDL_WarpMouse" ref="ac89483738346b9445fd60502f9f93e71" args="(ushort x, ushort y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_WarpMouse </td>
          <td>(</td>
          <td class="paramtype">ushort&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the position of the mouse cursor. </p>
<p>Set the position of the mouse cursor (generates a mouse motion event). </p>
<p>Binds to C-function call in SDL_mouse.h: </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">void</span> <a class="code" href="_sdl_8cs.html#a1f870df2b13fdb36e3ea8a10aab057ca" title="Set the position of the mouse cursor.">SDL_WarpMouse</a>(Uint16 x, Uint16 y);
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>SDL_MouseMotionEvent</dd></dl>

</div>
</div>
<a class="anchor" id="a566e12eb1fbcbae53808b0124a5b29b4"></a><!-- doxytag: member="Sdl.cs::SDL_WasInit" ref="a566e12eb1fbcbae53808b0124a5b29b4" args="(int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_WasInit </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks which SDL subsystems are initialized. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Specifies the subsystems you wish to check: <table  type="table">
<tr>
<th>Flag</b> </th><th>Description  </th></tr>
<tr>
<td>SDL_INIT_TIMER</b> </td><td>The timer subsystem.  </td></tr>
<tr>
<td>SDL_INIT_AUDIO</b> </td><td>The audio subsystem.  </td></tr>
<tr>
<td>SDL_INIT_VIDEO</b> </td><td>The video subsystem.  </td></tr>
<tr>
<td>SDL_INIT_CDROM</b> </td><td>The CD-ROM subsystem.  </td></tr>
<tr>
<td>SDL_INIT_JOYSTICK</b> </td><td>The joystick subsystem.  </td></tr>
<tr>
<td>SDL_INIT_EVERYTHING</b> </td><td>All subsystems.  </td></tr>
<tr>
<td>SDL_INIT_NOPARACHUTE</b> </td><td>Prevents SDL from catching fatal signals.  </td></tr>
<tr>
<td>SDL_INIT_EVENTTHREAD</b> </td><td>Not supported on all OS's.  </td></tr>
</table>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A bitwised OR'd combination of the initialized subsystems. </dd></dl>
<p><b>SDL_WasInit</b> allows you to see which SDL subsytems have been initialized. </p>
<p>Binds to C-function call in SDL.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC Uint32 SDLCALL <a class="code" href="_sdl_8cs.html#a566e12eb1fbcbae53808b0124a5b29b4" title="Checks which SDL subsystems are initialized.">SDL_WasInit</a>(Uint32 flags)
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd>SDL_Init(int), SDL_InitSubSystem(int)</dd></dl>

</div>
</div>
<a class="anchor" id="ad2572facb30aa0280ff452ce779ece11"></a><!-- doxytag: member="Sdl.cs::SDL_WasInit" ref="ad2572facb30aa0280ff452ce779ece11" args="(uint flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint SDL_WasInit </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>flags</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks which SDL subsystems are initialized. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Specifies the subsystems you wish to check: <table  type="table">
<tr>
<th>Flag</b> </th><th>Description  </th></tr>
<tr>
<td>SDL_INIT_TIMER</b> </td><td>The timer subsystem.  </td></tr>
<tr>
<td>SDL_INIT_AUDIO</b> </td><td>The audio subsystem.  </td></tr>
<tr>
<td>SDL_INIT_VIDEO</b> </td><td>The video subsystem.  </td></tr>
<tr>
<td>SDL_INIT_CDROM</b> </td><td>The CD-ROM subsystem.  </td></tr>
<tr>
<td>SDL_INIT_JOYSTICK</b> </td><td>The joystick subsystem.  </td></tr>
<tr>
<td>SDL_INIT_EVERYTHING</b> </td><td>All subsystems.  </td></tr>
<tr>
<td>SDL_INIT_NOPARACHUTE</b> </td><td>Prevents SDL from catching fatal signals.  </td></tr>
<tr>
<td>SDL_INIT_EVENTTHREAD</b> </td><td>Not supported on all OS's.  </td></tr>
</table>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A bitwised OR'd combination of the initialized subsystems. </dd></dl>
<p><b>SDL_WasInit</b> allows you to see which SDL subsytems have been initialized. </p>
<p>Binds to C-function call in SDL.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC Uint32 SDLCALL <a class="code" href="_sdl_8cs.html#a566e12eb1fbcbae53808b0124a5b29b4" title="Checks which SDL subsystems are initialized.">SDL_WasInit</a>(Uint32 flags)
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd>SDL_Init(int), SDL_InitSubSystem(int)</dd></dl>

</div>
</div>
<a class="anchor" id="a5de3159d742c3e4c81a54a341702700c"></a><!-- doxytag: member="Sdl.cs::SDL_WM_GetCaption" ref="a5de3159d742c3e4c81a54a341702700c" args="(out string title, out string icon)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_WM_GetCaption </td>
          <td>(</td>
          <td class="paramtype">out string&nbsp;</td>
          <td class="paramname"> <em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out string&nbsp;</td>
          <td class="paramname"> <em>icon</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the title and icon text of the display window. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">void</span> SDLCALL <a class="code" href="_sdl_8cs.html#a5de3159d742c3e4c81a54a341702700c" title="Gets the title and icon text of the display window.">SDL_WM_GetCaption</a>(<span class="keywordtype">char</span> **title, <span class="keywordtype">char</span> **icon)
</pre></div>  <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>title</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>icon</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a166b37121b66298e3f76a4fd8a4890fc" title="Sets the title and icon text of the display window.">SDL_WM_SetCaption</a></dd></dl>
<p>SDL_WM_SetCaption</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a4812354ffe2ef55699b0190e6a41ebf3" title="Sets the icon for the display window.">SDL_WM_SetIcon</a></dd></dl>
<p>SDL_WM_SetIcon</p>

</div>
</div>
<a class="anchor" id="ad70ae8fd84dc3156a6d670ae8532da28"></a><!-- doxytag: member="Sdl.cs::SDL_WM_GrabInput" ref="ad70ae8fd84dc3156a6d670ae8532da28" args="(int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_WM_GrabInput </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Grabs mouse and keyboard input. </p>
<p>Grabbing means that the mouse is confined to the application window, and nearly all keyboard input is passed directly to the application, and not interpreted by a window manager, if any. </p>
<p>When mode is SDL_GRAB_QUERY the grab mode is not changed, but the current grab mode is returned.  </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment">SDL_GrabMode <a class="code" href="_sdl_8cs.html#ad70ae8fd84dc3156a6d670ae8532da28" title="Grabs mouse and keyboard input.">SDL_WM_GrabInput</a>(SDL_GrabMode mode)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>SDL_GrabMode</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current/new SDL_GrabMode. </dd></dl>

</div>
</div>
<a class="anchor" id="aacb3f37a88ecea9a6fe7bd7257ceee7a"></a><!-- doxytag: member="Sdl.cs::SDL_WM_IconifyWindow" ref="aacb3f37a88ecea9a6fe7bd7257ceee7a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_WM_IconifyWindow </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iconify/Minimise the window. </p>
<p>This function iconifies/minimizes the window, and returns 1 if it succeeded. If the function succeeds, it generates an SDL_APPACTIVE loss event. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#aacb3f37a88ecea9a6fe7bd7257ceee7a" title="Iconify/Minimise the window.">SDL_WM_IconifyWindow</a>(<span class="keywordtype">void</span>)
</pre></div><dl class="return"><dt><b>Returns:</b></dt><dd>Returns 1 if it succeeded. This function is a noop and returns 0 in non-windowed environments.</dd></dl>

</div>
</div>
<a class="anchor" id="a166b37121b66298e3f76a4fd8a4890fc"></a><!-- doxytag: member="Sdl.cs::SDL_WM_SetCaption" ref="a166b37121b66298e3f76a4fd8a4890fc" args="(string title, string icon)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_WM_SetCaption </td>
          <td>(</td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>icon</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the title and icon text of the display window. </p>
<p>Sets the title-bar and icon name of the display window. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">void</span> SDLCALL <a class="code" href="_sdl_8cs.html#a166b37121b66298e3f76a4fd8a4890fc" title="Sets the title and icon text of the display window.">SDL_WM_SetCaption</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *title, <span class="keyword">const</span> <span class="keywordtype">char</span> *icon)
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a5de3159d742c3e4c81a54a341702700c" title="Gets the title and icon text of the display window.">SDL_WM_GetCaption</a></dd></dl>
<p>SDL_WM_GetCaption</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a4812354ffe2ef55699b0190e6a41ebf3" title="Sets the icon for the display window.">SDL_WM_SetIcon</a></dd></dl>
<p>SDL_WM_SetIcon</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>title</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>icon</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4812354ffe2ef55699b0190e6a41ebf3"></a><!-- doxytag: member="Sdl.cs::SDL_WM_SetIcon" ref="a4812354ffe2ef55699b0190e6a41ebf3" args="(IntPtr icon, byte[] mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SDL_WM_SetIcon </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>icon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the icon for the display window. </p>
<p>Sets the icon for the display window. Win32 icons must be 32x32. </p>
<p>This function must be called before the first call to <a class="el" href="_sdl_8cs.html#a961f7efdc2a7ec3860e93140853092f7" title="Set up a video mode with the specified width, height and bits-per-pixel.">SDL_SetVideoMode(int, int, int, int)</a>. </p>
<p>The mask is a bitmask that describes the shape of the icon. If mask is NULL, then the shape is determined by the colorkey of icon, if any, or makes the icon rectangular (no transparency) otherwise. </p>
<p>If mask is non-NULL, it points to a bitmap with bits set where the corresponding pixel should be visible. The format of the bitmap is as follows: Scanlines come in the usual top-down order. Each scanline consists of (width / 8) bytes, rounded up. The most significant bit of each byte represents the leftmost pixel. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="_sdl_8cs.html#a4812354ffe2ef55699b0190e6a41ebf3" title="Sets the icon for the display window.">SDL_WM_SetIcon</a>(<a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *icon, Uint8 *mask);
</pre></div><div class="fragment"><pre class="fragment"><a class="code" href="_sdl_8cs.html#a4812354ffe2ef55699b0190e6a41ebf3" title="Sets the icon for the display window.">SDL_WM_SetIcon</a>(SDL_LoadBMP(<span class="stringliteral">&quot;icon.bmp&quot;</span>), NULL);
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>icon</em>&nbsp;</td><td>Pointer to an <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#a961f7efdc2a7ec3860e93140853092f7" title="Set up a video mode with the specified width, height and bits-per-pixel.">SDL_SetVideoMode(int, int, int, int)</a>, <a class="el" href="_sdl_8cs.html#a166b37121b66298e3f76a4fd8a4890fc" title="Sets the title and icon text of the display window.">SDL_WM_SetCaption</a></dd></dl>

</div>
</div>
<a class="anchor" id="ab0e1ad78990e0c3ec5522d9ba29aca74"></a><!-- doxytag: member="Sdl.cs::SDL_WM_ToggleFullScreen" ref="ab0e1ad78990e0c3ec5522d9ba29aca74" args="(IntPtr surface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_WM_ToggleFullScreen </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>surface</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Toggle fullscreen mode without changing the contents of the screen. </p>
<p>If the display surface does not require locking before accessing the pixel information, then the memory pointers will not change. p&gt;If this function was able to toggle fullscreen mode (change from running in a window to fullscreen, or vice-versa), it will return 1. If it is not implemented, or fails, it returns 0. </p>
<p>The next call to <a class="el" href="_sdl_8cs.html#a961f7efdc2a7ec3860e93140853092f7" title="Set up a video mode with the specified width, height and bits-per-pixel.">SDL_SetVideoMode()</a> will set the mode fullscreen attribute based on the flags parameter - if SDL_FULLSCREEN is not set, then the display will be windowed by default where supported. </p>
<p>This is currently only implemented in the X11 video driver. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="_sdl_8cs.html#ab0e1ad78990e0c3ec5522d9ba29aca74" title="Toggle fullscreen mode without changing the contents of the screen.">SDL_WM_ToggleFullScreen</a>(<a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *surface);
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>surface</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 on failure or 1 on success.</dd></dl>

</div>
</div>
<a class="anchor" id="aa002784fe0bca405d0fc88e4267afa4f"></a><!-- doxytag: member="Sdl.cs::SDL_WriteBE16" ref="aa002784fe0bca405d0fc88e4267afa4f" args="(IntPtr dst, short val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_WriteBE16 </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write an item of native format to the specified endianness. </p>
<p>Binds to C-function in SDL_rwops.h </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#aa002784fe0bca405d0fc88e4267afa4f" title="Write an item of native format to the specified endianness.">SDL_WriteBE16</a>(SDL_RWops *dst, Uint16 value)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aa1fe24060926a8679b4a16201728a1e9" title="Allocates an empty, unpopulated SDL_RWops structure.">SDL_AllocRW</a></dd></dl>

</div>
</div>
<a class="anchor" id="a1e57ed59769589d70850e456a28960bb"></a><!-- doxytag: member="Sdl.cs::SDL_WriteBE16" ref="a1e57ed59769589d70850e456a28960bb" args="(IntPtr dst, ushort val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_WriteBE16 </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write an item of native format to the specified endianness. </p>
<p>Binds to C-function in SDL_rwops.h </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#aa002784fe0bca405d0fc88e4267afa4f" title="Write an item of native format to the specified endianness.">SDL_WriteBE16</a>(SDL_RWops *dst, Uint16 value)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aa1fe24060926a8679b4a16201728a1e9" title="Allocates an empty, unpopulated SDL_RWops structure.">SDL_AllocRW</a></dd></dl>

</div>
</div>
<a class="anchor" id="a13cef4fa79dc88cf3cfe6313e757baa7"></a><!-- doxytag: member="Sdl.cs::SDL_WriteBE32" ref="a13cef4fa79dc88cf3cfe6313e757baa7" args="(IntPtr dst, int val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_WriteBE32 </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write an item of native format to the specified endianness. </p>
<p>Binds to C-function in SDL_rwops.h </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#a13cef4fa79dc88cf3cfe6313e757baa7" title="Write an item of native format to the specified endianness.">SDL_WriteBE32</a>(SDL_RWops *dst, Uint32 value)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aa1fe24060926a8679b4a16201728a1e9" title="Allocates an empty, unpopulated SDL_RWops structure.">SDL_AllocRW</a></dd></dl>

</div>
</div>
<a class="anchor" id="a4724532d8936f6d147a3c575eaa22fef"></a><!-- doxytag: member="Sdl.cs::SDL_WriteBE32" ref="a4724532d8936f6d147a3c575eaa22fef" args="(IntPtr dst, uint val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_WriteBE32 </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write an item of native format to the specified endianness. </p>
<p>Binds to C-function in SDL_rwops.h </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#a13cef4fa79dc88cf3cfe6313e757baa7" title="Write an item of native format to the specified endianness.">SDL_WriteBE32</a>(SDL_RWops *dst, Uint32 value)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aa1fe24060926a8679b4a16201728a1e9" title="Allocates an empty, unpopulated SDL_RWops structure.">SDL_AllocRW</a></dd></dl>

</div>
</div>
<a class="anchor" id="a7602949d82e0891d7b80089e86d3ae5c"></a><!-- doxytag: member="Sdl.cs::SDL_WriteBE64" ref="a7602949d82e0891d7b80089e86d3ae5c" args="(IntPtr dst, long val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_WriteBE64 </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write an item of native format to the specified endianness. </p>
<p>Binds to C-function in SDL_rwops.h </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#a7602949d82e0891d7b80089e86d3ae5c" title="Write an item of native format to the specified endianness.">SDL_WriteBE64</a>(SDL_RWops *dst, Uint64 value)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aa1fe24060926a8679b4a16201728a1e9" title="Allocates an empty, unpopulated SDL_RWops structure.">SDL_AllocRW</a></dd></dl>

</div>
</div>
<a class="anchor" id="a2fdae0bf28d3722f3e906047d7ec0182"></a><!-- doxytag: member="Sdl.cs::SDL_WriteLE16" ref="a2fdae0bf28d3722f3e906047d7ec0182" args="(IntPtr dst, short val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_WriteLE16 </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write an item of native format to the specified endianness. </p>
<p>Binds to C-function in SDL_rwops.h </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#a2fdae0bf28d3722f3e906047d7ec0182" title="Write an item of native format to the specified endianness.">SDL_WriteLE16</a>(SDL_RWops *dst, Uint16 value)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aa1fe24060926a8679b4a16201728a1e9" title="Allocates an empty, unpopulated SDL_RWops structure.">SDL_AllocRW</a></dd></dl>

</div>
</div>
<a class="anchor" id="ae1e40cd1122e71b42e882eb93fa00c7a"></a><!-- doxytag: member="Sdl.cs::SDL_WriteLE16" ref="ae1e40cd1122e71b42e882eb93fa00c7a" args="(IntPtr dst, ushort val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_WriteLE16 </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write an item of native format to the specified endianness. </p>
<p>Binds to C-function in SDL_rwops.h </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#a2fdae0bf28d3722f3e906047d7ec0182" title="Write an item of native format to the specified endianness.">SDL_WriteLE16</a>(SDL_RWops *dst, Uint16 value)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aa1fe24060926a8679b4a16201728a1e9" title="Allocates an empty, unpopulated SDL_RWops structure.">SDL_AllocRW</a></dd></dl>

</div>
</div>
<a class="anchor" id="a70425bf77cfada9c4fb991b42ad46393"></a><!-- doxytag: member="Sdl.cs::SDL_WriteLE32" ref="a70425bf77cfada9c4fb991b42ad46393" args="(IntPtr dst, int val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_WriteLE32 </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write an item of native format to the specified endianness. </p>
<p>Binds to C-function in SDL_rwops.h </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#a70425bf77cfada9c4fb991b42ad46393" title="Write an item of native format to the specified endianness.">SDL_WriteLE32</a>(SDL_RWops *dst, Uint32 value)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aa1fe24060926a8679b4a16201728a1e9" title="Allocates an empty, unpopulated SDL_RWops structure.">SDL_AllocRW</a></dd></dl>

</div>
</div>
<a class="anchor" id="a697d3ebce5c06bf8e4a6532b67153dee"></a><!-- doxytag: member="Sdl.cs::SDL_WriteLE32" ref="a697d3ebce5c06bf8e4a6532b67153dee" args="(IntPtr dst, uint val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_WriteLE32 </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write an item of native format to the specified endianness. </p>
<p>Binds to C-function in SDL_rwops.h </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#a70425bf77cfada9c4fb991b42ad46393" title="Write an item of native format to the specified endianness.">SDL_WriteLE32</a>(SDL_RWops *dst, Uint32 value)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aa1fe24060926a8679b4a16201728a1e9" title="Allocates an empty, unpopulated SDL_RWops structure.">SDL_AllocRW</a></dd></dl>

</div>
</div>
<a class="anchor" id="a5e4064a0aa42a4400d879508d187ab11"></a><!-- doxytag: member="Sdl.cs::SDL_WriteLE64" ref="a5e4064a0aa42a4400d879508d187ab11" args="(IntPtr dst, long val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SDL_WriteLE64 </td>
          <td>(</td>
          <td class="paramtype">IntPtr&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write an item of native format to the specified endianness. </p>
<p>Binds to C-function in SDL_rwops.h </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#a5e4064a0aa42a4400d879508d187ab11" title="Write an item of native format to the specified endianness.">SDL_WriteLE64</a>(SDL_RWops *dst, Uint64 value)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="_sdl_8cs.html#aa1fe24060926a8679b4a16201728a1e9" title="Allocates an empty, unpopulated SDL_RWops structure.">SDL_AllocRW</a></dd></dl>

</div>
</div>
<a class="anchor" id="a68ebfaab030d39e9670dc4cad092e7e5"></a><!-- doxytag: member="Sdl.cs::ThreadDelegate" ref="a68ebfaab030d39e9670dc4cad092e7e5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">delegate int ThreadDelegate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>int (SDLCALL *fn)(void *) </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a8ecae7ddf44d437aea0eeac375b14a87"></a><!-- doxytag: member="Sdl.cs::Aloss" ref="a8ecae7ddf44d437aea0eeac375b14a87" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fmt. <a class="el" href="_sdl_8cs.html#a8ecae7ddf44d437aea0eeac375b14a87">Aloss</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a62197192f0fbf4e0675eb37be1c4c175"></a><!-- doxytag: member="Sdl.cs::alpha" ref="a62197192f0fbf4e0675eb37be1c4c175" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_sdl_8cs.html#a62197192f0fbf4e0675eb37be1c4c175">alpha</a> = (Uint8)<a class="el" href="_sdl_8cs.html#a905c521e05ec8042631a912b71d0454e">temp</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab8c1e3f1165d8eaaef52fe2bcbb06726"></a><!-- doxytag: member="Sdl.cs::amask" ref="ab8c1e3f1165d8eaaef52fe2bcbb06726" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 <a class="el" href="_sdl_8cs.html#ab8c1e3f1165d8eaaef52fe2bcbb06726">amask</a> = 0x000000ff</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac854fb38bb0ed1c2af25170f901ee015"></a><!-- doxytag: member="Sdl.cs::Amask" ref="ac854fb38bb0ed1c2af25170f901ee015" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fmt. <a class="el" href="_sdl_8cs.html#ac854fb38bb0ed1c2af25170f901ee015">Amask</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aba94dde19bff2e8b25432d8435e63b8f"></a><!-- doxytag: member="Sdl.cs::Ashift" ref="aba94dde19bff2e8b25432d8435e63b8f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fmt. <a class="el" href="_sdl_8cs.html#aba94dde19bff2e8b25432d8435e63b8f">Ashift</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5bec03af803d707fc82c2315cda02f3e"></a><!-- doxytag: member="Sdl.cs::Bloss" ref="a5bec03af803d707fc82c2315cda02f3e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fmt. <a class="el" href="_sdl_8cs.html#a5bec03af803d707fc82c2315cda02f3e">Bloss</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa6074166cc77c18081343a82d3af99bf"></a><!-- doxytag: member="Sdl.cs::blue" ref="aa6074166cc77c18081343a82d3af99bf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_sdl_8cs.html#aa6074166cc77c18081343a82d3af99bf">blue</a> = (Uint8)<a class="el" href="_sdl_8cs.html#a905c521e05ec8042631a912b71d0454e">temp</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0c79dd52bfbbf1f797424c029b601a4d"></a><!-- doxytag: member="Sdl.cs::Bmask" ref="a0c79dd52bfbbf1f797424c029b601a4d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fmt. <a class="el" href="_sdl_8cs.html#a0c79dd52bfbbf1f797424c029b601a4d">Bmask</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a14b0866344628e753ba7670a11b780b4"></a><!-- doxytag: member="Sdl.cs::bmask" ref="a14b0866344628e753ba7670a11b780b4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 <a class="el" href="_sdl_8cs.html#a14b0866344628e753ba7670a11b780b4">bmask</a> = 0x0000ff00</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad276a57f3d53469698db846f870ff8d2"></a><!-- doxytag: member="Sdl.cs::Bshift" ref="ad276a57f3d53469698db846f870ff8d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fmt. <a class="el" href="_sdl_8cs.html#ad276a57f3d53469698db846f870ff8d2">Bshift</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aece5a7af4770c985f1b8cc20246f5b28"></a><!-- doxytag: member="Sdl.cs::colors" ref="aece5a7af4770c985f1b8cc20246f5b28" args="[256]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_d_l___color.html">SDL_Color</a> <a class="el" href="_sdl_8cs.html#aece5a7af4770c985f1b8cc20246f5b28">colors</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a36910ddc19d1bf237b12507db74f71a2"></a><!-- doxytag: member="Sdl.cs::fmt" ref="a36910ddc19d1bf237b12507db74f71a2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_sdl_8cs.html#a36910ddc19d1bf237b12507db74f71a2">fmt</a> = surface.format</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stores surface format information. </p>
<p>A <a class="el" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a> describes the format of the pixel data stored at the pixels field of a <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a>. Every surface stores a <a class="el" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a> in the format field. </p>
<p>If you wish to do pixel level modifications on a surface, then understanding how SDL stores its color information is essential.  </p>
<p>8-bit pixel formats are the easiest to understand. Since its an 8-bit format, we have 8 BitsPerPixel and 1 BytesPerPixel. Since BytesPerPixel is 1, all pixels are represented by a Uint8 which contains an index into palette.colors. So, to determine the color of a pixel in a 8-bit surface: we read the color index from surface.pixels and we use that index to read the <a class="el" href="struct_s_d_l___color.html" title="Format independent color description.">SDL_Color</a> structure from surface.format.palette.colors. Like so:  </p>
<div class="fragment"><pre class="fragment">                        <a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *surface;
                        <a class="code" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a> *fmt;
                        <a class="code" href="struct_s_d_l___color.html" title="Format independent color description.">SDL_Color</a> *color;
                        Uint8 index;

                        .
                        .

                        <span class="comment">/* Create surface */</span>
                        .
                        .
                        fmt=surface.<a class="code" href="struct_s_d_l___surface.html#ad70ef89eb3879b7310311b3da48aa393" title="Pixel format Pointer to SDL_PixelFormat.">format</a>;

                        <span class="comment">/* Check the bitdepth of the surface */</span>
                        <span class="keywordflow">if</span>(fmt.<a class="code" href="struct_s_d_l___pixel_format.html#a28aabdce8eba3259ddea6b43a8703387" title="The number of bits used to represent each pixel in a surface. Usually 8, 16, 24 or 32...">BitsPerPixel</a>!=8)
                {
                        fprintf(stderr, <span class="stringliteral">&quot;Not an 8-bit surface.\n&quot;</span>);
                        <span class="keywordflow">return</span>(-1);
                }

                <span class="comment">/* Lock the surface */</span>
                <a class="code" href="_sdl_8cs.html#ad1c3562c62aaf55f95641f0bafab9e8f" title="Lock a surface for directly access.">SDL_LockSurface</a>(surface);

                <span class="comment">/* Get the topleft pixel */</span>
                index=*(Uint8 *)surface.<a class="code" href="struct_s_d_l___surface.html#aec4109250396885d55724d1d90493af8" title="Pointer to the actual pixel data Void pointer.">pixels</a>;
                color=fmt.<a class="code" href="struct_s_d_l___pixel_format.html#a5578b72f8e6c6b8f4feb8e9d67d7af04" title="Pointer to the palette, or NULL if the BitsPerPixel&amp;gt;8 Pointer to SDL_Palette">palette</a>.colors[index];

                <span class="comment">/* Unlock the surface */</span>
                <a class="code" href="_sdl_8cs.html#a575d113e5463394a260668c1eb9a7390">SDL_UnlockSurface</a>(surface);
                <a class="code" href="_sdl_8cs.html#acf16cb12f21e38e5544fbe0f6a0869d6">printf</a>(<span class="stringliteral">&quot;Pixel Color- Red: %d, Green: %d, Blue: %d. Index: %d\n&quot;</span>,
                color.<a class="code" href="struct_s_d_l___color.html#a6b604b87f66fec29eb97d00dae9cb83d" title="Red Intensity.">r</a>, color.<a class="code" href="struct_s_d_l___color.html#a00e502b139916cdd32418c00c6d3af96" title="Green Intensity.">g</a>, color.<a class="code" href="struct_s_d_l___color.html#afcab9cae0bb36b286b472fd2d90f9ea5" title="Blue Intensity.">b</a>, index);
                .
                .
</pre></div>  <p>Pixel formats above 8-bit are an entirely different experience. They are considered to be "TrueColor" formats and the color information is stored in the pixels themselves, not in a palette. The mask, shift and loss fields tell us how the color information is encoded. The mask fields allow us to isolate each color component, the shift fields tell us the number of bits to the right of each component in the pixel value and the loss fields tell us the number of bits lost from each component when packing 8-bit color component in a pixel. </p>
<p>code&gt; /* Extracting color components from a 32-bit color value </p>

</div>
</div>
<a class="anchor" id="aed8345802a260785e5cc4fead969a627"></a><!-- doxytag: member="Sdl.cs::given" ref="aed8345802a260785e5cc4fead969a627" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">&lt;/code &gt;&lt;/example &gt;&lt; paramname=&quot;surface&quot;&gt;&lt;/param &gt;&lt; paramname=&quot;colors&quot;&gt;&lt;/param &gt;&lt; paramname=&quot;firstcolor&quot;&gt;&lt;/param &gt;&lt; paramname=&quot;flags&quot;&gt;&lt;/param &gt;&lt; paramname=&quot;ncolors&quot;&gt;&lt;/param &gt;&lt; returns &gt; If <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a> is not a palettized this function does returning If all of the <a class="el" href="_sdl_8cs.html#aece5a7af4770c985f1b8cc20246f5b28">colors</a> were set as passed to it will <a class="el" href="_sdl_8cs.html#a1691110f5eb29093dc96488738dc6b1c">return</a> If not all the color entries were set exactly as <a class="el" href="_sdl_8cs.html#aed8345802a260785e5cc4fead969a627">given</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab9cc005962591e6805dd39a2fda8a836"></a><!-- doxytag: member="Sdl.cs::Gloss" ref="ab9cc005962591e6805dd39a2fda8a836" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fmt. <a class="el" href="_sdl_8cs.html#ab9cc005962591e6805dd39a2fda8a836">Gloss</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a43613889bd9d644775e8da9db3a32375"></a><!-- doxytag: member="Sdl.cs::gmask" ref="a43613889bd9d644775e8da9db3a32375" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 <a class="el" href="_sdl_8cs.html#a43613889bd9d644775e8da9db3a32375">gmask</a> = 0x00ff0000</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8ee5a0cd4f45561ba2ec1768f71b4824"></a><!-- doxytag: member="Sdl.cs::Gmask" ref="a8ee5a0cd4f45561ba2ec1768f71b4824" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fmt. <a class="el" href="_sdl_8cs.html#a8ee5a0cd4f45561ba2ec1768f71b4824">Gmask</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad83fb941855ba7c4aa2bb65245437777"></a><!-- doxytag: member="Sdl.cs::green" ref="ad83fb941855ba7c4aa2bb65245437777" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_sdl_8cs.html#ad83fb941855ba7c4aa2bb65245437777">green</a> = (Uint8)<a class="el" href="_sdl_8cs.html#a905c521e05ec8042631a912b71d0454e">temp</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab7727e8f2b2c186d78fa81914102e219"></a><!-- doxytag: member="Sdl.cs::Gshift" ref="ab7727e8f2b2c186d78fa81914102e219" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fmt. <a class="el" href="_sdl_8cs.html#ab7727e8f2b2c186d78fa81914102e219">Gshift</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aed7a7f1f82df5fd3dd11622b2e8a0351"></a><!-- doxytag: member="Sdl.cs::gt" ref="aed7a7f1f82df5fd3dd11622b2e8a0351" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">&amp; <a class="el" href="_sdl_8cs.html#aed7a7f1f82df5fd3dd11622b2e8a0351">gt</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae53b59602879361d91ef9a2bdd5ae091"></a><!-- doxytag: member="Sdl.cs::h" ref="ae53b59602879361d91ef9a2bdd5ae091" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">.&lt;/code&gt;&lt;p&gt; Binds to C function call in SDL_video. <a class="el" href="_sdl_8cs.html#ae53b59602879361d91ef9a2bdd5ae091">h</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acb559820d9ca11295b4500f179ef6392"></a><!-- doxytag: member="Sdl.cs::i" ref="acb559820d9ca11295b4500f179ef6392" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="_sdl_8cs.html#acb559820d9ca11295b4500f179ef6392">i</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a857c8c8ca640fb2283d751a715bd1ee9"></a><!-- doxytag: member="Sdl.cs::lt" ref="a857c8c8ca640fb2283d751a715bd1ee9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">&amp; <a class="el" href="_sdl_8cs.html#a857c8c8ca640fb2283d751a715bd1ee9">lt</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a46376027f1df32e5005ec65e91495448"></a><!-- doxytag: member="Sdl.cs::nothing" ref="a46376027f1df32e5005ec65e91495448" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">&lt;/code &gt;&lt;/example &gt;&lt; paramname=&quot;surface&quot;&gt;&lt;/param &gt;&lt; paramname=&quot;colors&quot;&gt;&lt;/param &gt;&lt; paramname=&quot;firstcolor&quot;&gt;&lt;/param &gt;&lt; paramname=&quot;flags&quot;&gt;&lt;/param &gt;&lt; paramname=&quot;ncolors&quot;&gt;&lt;/param &gt;&lt; returns &gt; If <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a> is not a palettized this function does <a class="el" href="_sdl_8cs.html#a46376027f1df32e5005ec65e91495448">nothing</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a36392890a1aba4cacbe1cad263a699f0"></a><!-- doxytag: member="Sdl.cs::pixel" ref="a36392890a1aba4cacbe1cad263a699f0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_sdl_8cs.html#a36392890a1aba4cacbe1cad263a699f0">pixel</a> = *((Uint32*)surface.pixels)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a42c3a4a0281e61ee592e36a3eda020f2"></a><!-- doxytag: member="Sdl.cs::red" ref="a42c3a4a0281e61ee592e36a3eda020f2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_sdl_8cs.html#a42c3a4a0281e61ee592e36a3eda020f2">red</a> = (Uint8)<a class="el" href="_sdl_8cs.html#a905c521e05ec8042631a912b71d0454e">temp</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1691110f5eb29093dc96488738dc6b1c"></a><!-- doxytag: member="Sdl.cs::return" ref="a1691110f5eb29093dc96488738dc6b1c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">&lt;/code &gt;&lt;/example &gt;&lt; paramname=&quot;surface&quot;&gt;&lt;/param &gt;&lt; paramname=&quot;colors&quot;&gt;&lt;/param &gt;&lt; paramname=&quot;firstcolor&quot;&gt;&lt;/param &gt;&lt; paramname=&quot;flags&quot;&gt;&lt;/param &gt;&lt; paramname=&quot;ncolors&quot;&gt;&lt;/param &gt;&lt; returns &gt; If <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a> is not a palettized this function does returning If all of the <a class="el" href="_sdl_8cs.html#aece5a7af4770c985f1b8cc20246f5b28">colors</a> were set as passed to it will <a class="el" href="_sdl_8cs.html#a1691110f5eb29093dc96488738dc6b1c">return</a> If not all the color entries were set exactly as it will <a class="el" href="_sdl_8cs.html#a1691110f5eb29093dc96488738dc6b1c">return</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3870e0709fa0202243f20d4af0406d5f"></a><!-- doxytag: member="Sdl.cs::Rloss" ref="a3870e0709fa0202243f20d4af0406d5f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fmt. <a class="el" href="_sdl_8cs.html#a3870e0709fa0202243f20d4af0406d5f">Rloss</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a94cbfe2c2213491558b156027ec63238"></a><!-- doxytag: member="Sdl.cs::rmask" ref="a94cbfe2c2213491558b156027ec63238" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">else <a class="el" href="_sdl_8cs.html#a94cbfe2c2213491558b156027ec63238">rmask</a> = 0x000000ff</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6a9df771fdb653ae2056012af21af56f"></a><!-- doxytag: member="Sdl.cs::Rmask" ref="a6a9df771fdb653ae2056012af21af56f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fmt. <a class="el" href="_sdl_8cs.html#a6a9df771fdb653ae2056012af21af56f">Rmask</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2809d746eb2856c5a293ad74282e7cdd"></a><!-- doxytag: member="Sdl.cs::Rshift" ref="a2809d746eb2856c5a293ad74282e7cdd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fmt. <a class="el" href="_sdl_8cs.html#a2809d746eb2856c5a293ad74282e7cdd">Rshift</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a968bba55c7ad32b326939fefd1bbb017"></a><!-- doxytag: member="Sdl.cs::screen" ref="a968bba55c7ad32b326939fefd1bbb017" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_d_l___surface.html">SDL_Surface</a> * <a class="el" href="_sdl_8cs.html#a968bba55c7ad32b326939fefd1bbb017">screen</a> = SDL_SetVideoMode(640, 480, 8, SDL_HWPALETTE)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a portion of the colormap for the given 8-bit surface. </p>
<p>Sets the colors in the palette of an 8-bit surface.</p>
<p>When surface is the surface associated with the current display, the display colormap will be updated with the requested colors. If SDL_HWPALETTE was set in <a class="el" href="_sdl_8cs.html#a961f7efdc2a7ec3860e93140853092f7" title="Set up a video mode with the specified width, height and bits-per-pixel.">SDL_SetVideoMode(int, int, int, int)</a> flags, SDL_SetColors will always return 1, and the palette is guaranteed to be set the way you desire, even if the window colormap has to be warped or run under emulation.</p>
<p>The color components of a <a class="el" href="struct_s_d_l___color.html" title="Format independent color description.">SDL_Color</a> structure are 8-bits in size, giving you a total of 256^3 =16777216 colors. </p>
<p>Palettized (8-bit) screen surfaces with the SDL_HWPALETTE flag have two palettes, a logical palette that is used for mapping blits to/from the surface and a physical palette (that determines how the hardware will map the colors to the display). SDL_SetColors modifies both palettes (if present), and is equivalent to calling SDL_SetPalette with the flags set to (SDL_LOGPAL | SDL_PHYSPAL).  </p>
<p>When 'surface' is the surface associated with the current display, the display colormap will be updated with the requested colors. If SDL_HWPALETTE was set in <a class="el" href="_sdl_8cs.html#a961f7efdc2a7ec3860e93140853092f7" title="Set up a video mode with the specified width, height and bits-per-pixel.">SDL_SetVideoMode()</a> flags, <a class="el" href="_sdl_8cs.html#ad3dd27ac574c77908bc25298e847f77a">SDL_SetColors()</a> will always return 1, and the palette is guaranteed to be set the way you desire, even if the window colormap has to be warped or run under emulation. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#ad3dd27ac574c77908bc25298e847f77a">SDL_SetColors</a>(<a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *surface, <a class="code" href="struct_s_d_l___color.html" title="Format independent color description.">SDL_Color</a> *<a class="code" href="_sdl_8cs.html#aece5a7af4770c985f1b8cc20246f5b28">colors</a>, <span class="keywordtype">int</span> firstcolor, <span class="keywordtype">int</span> ncolors)
</pre></div> <p>/* Create a display surface with a grayscale palette</p>
<p>Palettized (8-bit) screen surfaces with the SDL_HWPALETTE flag have two palettes, a logical palette that is used for mapping blits to/from the surface and a physical palette (that determines how the hardware will map the colors to the display). SDL_BlitSurface always uses the logical palette when blitting surfaces (if it has to convert between surface pixel formats). Because of this, it is often useful to modify only one or the other palette to achieve various special color effects (e.g., screen fading, color flashes, screen dimming).</p>
<p>This function can modify either the logical or physical palette by specifing SDL_LOGPAL or SDL_PHYSPALthe in the flags parameter.</p>
<p>When surface is the surface associated with the current display, the display colormap will be updated with the requested colors. If SDL_HWPALETTE was set in SDL_SetVideoMode flags, SDL_SetPalette will always return 1, and the palette is guaranteed to be set the way you desire, even if the window colormap has to be warped or run under emulation. </p>
<p>The color components of a <a class="el" href="struct_s_d_l___color.html" title="Format independent color description.">SDL_Color</a> structure are 8-bits in size, giving you a total of 2563=16777216 colors. </p>
<p>'flags' is one or both of: SDL_LOGPAL -- set logical palette, which controls how blits are mapped to/from the surface, SDL_PHYSPAL -- set physical palette, which controls how pixels look on the screen Only screens have physical palettes. Separate change of physical/logical palettes is only possible if the screen has SDL_HWPALETTE set. /p&gt;</p>
<p><a class="el" href="_sdl_8cs.html#ad3dd27ac574c77908bc25298e847f77a">SDL_SetColors()</a> is equivalent to calling this function with flags = (SDL_LOGPAL|SDL_PHYSPAL). </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> DECLSPEC <span class="keywordtype">int</span> SDLCALL <a class="code" href="_sdl_8cs.html#a1e7f5af13949fa7719cf5c4e3b19b059">SDL_SetPalette</a>(<a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *surface, <span class="keywordtype">int</span> flags, <a class="code" href="struct_s_d_l___color.html" title="Format independent color description.">SDL_Color</a> *colors, <span class="keywordtype">int</span> firstcolor, <span class="keywordtype">int</span> ncolors)
</pre></div> <div class="fragment"><pre class="fragment">                <span class="comment">/* Create a display surface with a grayscale palette  </span>
</pre></div>
</div>
</div>
<a class="anchor" id="a1e7f5af13949fa7719cf5c4e3b19b059"></a><!-- doxytag: member="Sdl.cs::SDL_SetPalette" ref="a1e7f5af13949fa7719cf5c4e3b19b059" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">....&lt;/code&gt;&lt;/example&gt;&lt;paramname=&quot;surface&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;colors&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;firstcolor&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;flags&quot;&gt;&lt;/param&gt;&lt;paramname=&quot;ncolors&quot;&gt;&lt;/param&gt;&lt;returns&gt; If <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a> is not a palettized this function does returning.If all of the <a class="el" href="_sdl_8cs.html#aece5a7af4770c985f1b8cc20246f5b28">colors</a> were set as passed to SDL_SetPalette</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a63bb1d55c833f19b63071bbacc7bb5e1"></a><!-- doxytag: member="Sdl.cs::surface" ref="a63bb1d55c833f19b63071bbacc7bb5e1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">endif <a class="el" href="_sdl_8cs.html#a63bb1d55c833f19b63071bbacc7bb5e1">surface</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> <a class="code" href="_sdl_8cs.html#aa732dd717414124c4710c0d25f8e07ce">SDL_CreateRGBSurface</a>(SDL_SWSURFACE, width, height, 32,
                        <a class="code" href="_sdl_8cs.html#a94cbfe2c2213491558b156027ec63238">rmask</a>, <a class="code" href="_sdl_8cs.html#a43613889bd9d644775e8da9db3a32375">gmask</a>, <a class="code" href="_sdl_8cs.html#a14b0866344628e753ba7670a11b780b4">bmask</a>, <a class="code" href="_sdl_8cs.html#ab8c1e3f1165d8eaaef52fe2bcbb06726">amask</a>)
</pre></div>
<p>Create an empty <a class="el" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a>. </p>
<p>Allocate an empty surface (must be called after <a class="el" href="_sdl_8cs.html#a961f7efdc2a7ec3860e93140853092f7" title="Set up a video mode with the specified width, height and bits-per-pixel.">SDL_SetVideoMode(int, int, int, int)</a>). </p>
<p>If depth is 8 bits an empty palette is allocated for the surface, otherwise a 'packed-pixel' <a class="el" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a> is created using the [RGBA]mask's provided (see <a class="el" href="struct_s_d_l___pixel_format.html">SDL_PixelFormat</a>). The flags specifies the type of surface that should be created, it is an OR'd combination of the following possible values. </p>
<table  type="table">
<tr>
<td>SDL_SWSURFACE</b> </td><td>SDL will create the surface in system memory. This improves the performance of pixel level access, however you may not be able to take advantage of some types of hardware blitting.   </td></tr>
<tr>
<td>SDL_HWSURFACE</b> </td><td>SDL will attempt to create the surface in video memory. This will allow SDL to take advantage of Video-&gt;Video blits (which are often accelerated).   </td></tr>
<tr>
<td>SDL_SRCCOLORKEY</b> </td><td>This flag turns on colourkeying for blits from this surface. If SDL_HWSURFACE is also specified and colourkeyed blits are hardware-accelerated, then SDL will attempt to place the surface in video memory. Use <a class="el" href="_sdl_8cs.html#a6143709fbf5b39f734e9de78cfa1d6c8" title="Sets the color key (transparent pixel) in a blittable surface and RLE acceleration.">SDL_SetColorKey(IntPtr, int, int)</a> to set or clear this flag after surface creation.   </td></tr>
<tr>
<td>SDL_SRCALPHA</b> </td><td>This flag turns on alpha-blending for blits from this surface. If SDL_HWSURFACE is also specified and alpha-blending blits are hardware-accelerated, then the surface will be placed in video memory if possible. Use <a class="el" href="_sdl_8cs.html#a77f6839de15f85b6c5afd9174894a41a" title="Adjust the alpha properties of a surface.">SDL_SetAlpha(IntPtr, int, byte)</a> to set or clear this flag after surface creation.   </td></tr>
</table>
<p><b>Note:</b> If an alpha-channel is specified (that is, if Amask is nonzero), then the SDL_SRCALPHA flag is automatically set. You may remove this flag by calling <a class="el" href="_sdl_8cs.html#a77f6839de15f85b6c5afd9174894a41a" title="Adjust the alpha properties of a surface.">SDL_SetAlpha(IntPtr, int, byte)</a> after surface creation. </p>
<p>Binds to C-function call in SDL_video.h: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="struct_s_d_l___surface.html" title="Graphical Surface Structure.">SDL_Surface</a> *<a class="code" href="_sdl_8cs.html#aa732dd717414124c4710c0d25f8e07ce">SDL_CreateRGBSurface</a>(Uint32 flags, <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height, <span class="keywordtype">int</span> depth, Uint32 <a class="code" href="_sdl_8cs.html#a6a9df771fdb653ae2056012af21af56f">Rmask</a>, Uint32 <a class="code" href="_sdl_8cs.html#a8ee5a0cd4f45561ba2ec1768f71b4824">Gmask</a>, Uint32 <a class="code" href="_sdl_8cs.html#a0c79dd52bfbbf1f797424c029b601a4d">Bmask</a>, Uint32 <a class="code" href="_sdl_8cs.html#ac854fb38bb0ed1c2af25170f901ee015">Amask</a>)
</pre></div> <p>/* Create a 32-bit surface with the bytes of each pixel in R,G,B,A order, as expected by OpenGL for textures </p>

</div>
</div>
<a class="anchor" id="a905c521e05ec8042631a912b71d0454e"></a><!-- doxytag: member="Sdl.cs::temp" ref="a905c521e05ec8042631a912b71d0454e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_sdl_8cs.html#a905c521e05ec8042631a912b71d0454e">temp</a> = <a class="el" href="_sdl_8cs.html#a36392890a1aba4cacbe1cad263a699f0">pixel</a>&amp;amp</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a599562a2f2f1687da586208c2c326ada"></a><!-- doxytag: member="Sdl.cs::to&lt; see cref=&quot;SDL_Surface&quot;/&gt;" ref="a599562a2f2f1687da586208c2c326ada" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">&lt;/example &gt;&lt; paramname=&quot;flags&quot;&gt;&lt;/param &gt;&lt; paramname=&quot;width&quot;&gt;&lt;/param &gt;&lt; paramname=&quot;height&quot;&gt;&lt;/param &gt;&lt; paramname=&quot;depth&quot;&gt;&lt;/param &gt;&lt; paramname=&quot;Rmask&quot;&gt;&lt;/param &gt;&lt; paramname=&quot;Gmask&quot;&gt;&lt;/param &gt;&lt; paramname=&quot;Bmask&quot;&gt;&lt;/param &gt;&lt; paramname=&quot;Amask&quot;&gt;&lt;/param &gt;&lt; returns &gt; IntPtr to&lt; see cref=&quot;SDL_Surface&quot;/&gt;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Properties</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sun Nov 14 2010 13:06:16 for Tao by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
