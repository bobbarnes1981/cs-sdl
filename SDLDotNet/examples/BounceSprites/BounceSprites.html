<html>
<head>
    <title>Using Sprites in SDL</title>
</head>
<h1 align="center" style='TEXT-ALIGN:center'>Using Sprites in SDL.NET</h1> 
A tutorial by David Hudson (jendave at yahoo dot com)
 
<h2>Introduction:</h2>

At the simplest level, sprite is a 2D object that can be shown on and moved around the screen. Each sprite has a Surface and a Rectangle to define what the sprite looks like and where it is located.
<p>

This tutorial will provide some insight into creating sprites, displaying them and having them respond to input events such as the mouse or keyboard.

<h2>Sprite Class</h2>

The sprite class consists of a Surface and a Rectangle. The Surface object is displayed when the Sprite is Blitted to the screen. The Surface can consist of a graphic image, a rendered text string or a primitive for example.
<p>

The rectangle is used to show what part of the Surface should be displayed. Typically, the rectangle should encompass the entire surface, but there may be reasons that the rectangle differs from the size of the surface. For example if the Surface actually consists of multiple images to be used for animation, the rectangle can be used to mark which part of the image is to be currently displayed.
<p>

The Sprite class has virtual Update() methods which are to be overridden by inheriting classes. These methods, used in conjunction with SpriteCollections will update the Sprite’s position and/or Surface when input events such as mouse button presses, mouse motion, keyboard presses occur.
<p>

The Render() method is provided to perform an action on a Surface before it is Blit to the Screen. In the Sprite class, the Render() method simply returns the Surface. In an inherited class, however, this method is often overridden to perform a task on the surface before it is Blit. For example, when a text string may need to be converted to a Surface before it is Blit to the screen. The Render() method can be overridden to do that.
<p>

The are some other properties of a Sprite:
<p>
<table border="1" cellspacing="0" cellpadding="0" >
<tr>
<td width="251" valign="top" height="41">
AllowDrag (bool)
</td>
<td>
Can the sprite be dragged (usually with the mouse)?
</td>
</tr>
<tr>
<td width="251" valign="top" height="41"> 
Visible (bool)
</td>
<td>
Is the Sprite supposed to visible on the screen?
</td>
</tr>
<tr>
<td width="251" valign="top" height="41">
BeingDragged (bool)
</td>
<td>
Is the Sprite currently being dragged?
</td>
</table>
<p>
The Sprite class itself does not do much; its Update()  methods are empty. The Sprite class is really meant to be extended with its Update() methods overridden by new logic. The BounceSprite class has overridden Update methods that determine what happens when a mouse button, mouse motion or tick event happens.
<p>
Some classes extended from Sprite are included in SDL.NET. The TextSprite displays text rendered as a sprite. The AnimatedSprite provides a basis for displaying multiple surfaces over time to create the animation.
<p>
<h2>SpriteCollection class</h2>
The SpriteCollection class is a strongly-typed collection that helps aggregate sprites and execute events on them.
<p>
Besides having methods for adding, removing and accessing the Sprites in the collection, SpriteCollection has methods for enabling events on the Sprites it contains. For example, the SpriteCollection.EnableMouseButtonEvent() allows all the sprites in the collection to respond to mouse button clicks. Once the event is fired, the SpriteCollection passes the event and EventArgs to each sprite. 
<p>

<pre>
private void Update(object sender, MouseButtonEventArgs e)
            {
                  for (int i = 0; i < this.Count; i++)
                  {
                        this[i].Update(e);
                  }
            } 
</pre>
<p>
The sprite can then decide how to respond. Usually, the sprite will have logic to check if the mouse click happened on which sprite. For example:
<p>
<pre>
public override void Update(MouseButtonEventArgs args)
{ 
          if (this.IntersectsWith(new Point(args.X, args.Y))) 
          { 
                // If we are being held down, pick up the marble 
                if (args.ButtonPressed) 
                { 
                      if (args.Button == MouseButton.PrimaryButton) 
                      { 
                            this.BeingDragged = true; 
                      } 
                      else 
                      { 
                            this.Kill(); 
                      } 
                } 
                else 
                { 
                      this.BeingDragged = false; 
                } 
          } 
    }
</pre>
<p>
If you click on the spirte with the primary mouse button, you can drag the sprite. If you click on it with the secondary button, it will remove the sprite from the screen and the SpriteCollection.
<p>
SpriteCollections can be used to categorize sprites into logical groups. A program may have SpriteCollection for the player’s spaceship and another collection for the enemies. Another SpriteCollection could contain only those sprites that are close to the player’s ship to do faster collision detection.
<p>
<h2>SpriteContainer</h2>
SpriteContainer extends from Sprite and includes a field that holds a SpriteCollection. The Render() method has been overridden to Blit() the Sprites contained in the collection to the SpriteContainer’s Surface before rendering it to the screen. 
<p>
This class is particularly useful if the app wants to have a sprite that contains other Sprites and move the SpriteContainer as a whole. Gui windows are a good example of this. Take a look at the SpriteGuiDemo and the GuiExample included in the SDL.NET source to see how this works.
<p>
<h2>BounceSprites Demo</h2>
Let’s take a look at the Sprites in action. This demo is included with the SDL.NET source. BounceSprite.cs is the sprite class. BounceSprites.cs is the demo app itself.
<p>
<h3>BounceSprite.cs</h3>
<p>
<pre>
using System;
using System.Drawing;
using System.Collections;

using SdlDotNet;
using SdlDotNet.Sprites;

namespace SdlDotNet.Examples 
{
	/// <summary>
	/// Demo of Bouncing Balls using Sprites. 
	/// The Bouncesprites will respond to Tick Events by spinning. 
	/// You can click on each sprite and move them around the 
	/// screen as well (MouseButton and MouseMotion events).
	/// </summary>
	class BounceSprites
	{
		#region Fields
		private Surface screen; //video screen
		private SpriteCollection master = new SpriteCollection(); //holds all sprites
		private int width = 640; //screen width
		private int height = 480; //screen height
		private int maxBalls = 10; //number of balls to display
		private Random rand = new Random(); //randomizer
		private Surface background = new Surface("../../Data/background.png");
		#endregion Fields

		#region EventHandler Methods
		//Handles keyboard events. The 'Escape' and 'Q'keys will cause the app to exit
		private void OnKeyboardDown(object sender, KeyboardEventArgs e) 
		{
			if (e.Key == Key.Escape || e.Key == Key.Q)
			{
				Events.QuitApplication();
			}
		}

		RectangleCollection rects = new RectangleCollection();

		//A ticker is running to update the sprites constantly.
		//This method will fill the screen with black to clear it of the sprites.
		//Then it will Blit all of the sprites to the screen.
		//Then it will refresh the screen and display it.
		private void OnTick(object sender, TickEventArgs args)
		{	
			rects = screen.Blit(master);
			screen.Update(rects);	
			screen.Erase(master, background);
		}
		#endregion EventHandler Methods

		#region Methods
		//Main program loop
		private void Go() 
		{
			//Set up screen
			screen = Video.SetVideoModeWindow(width, height, true);
			screen.Blit(background);
			screen.Update();
			Video.WindowCaption = "SdlDotNet - Bounce Sprites";

			//This loads the various images (provided by Moonfire) 
			// into a SurfaceCollection for animation
			SurfaceCollection marbleSurfaces = 
				new SurfaceCollection(new Surface("../../Data/marble1.png"), new Size(50, 50)); 

			for (int i = 0; i < this.maxBalls; i++)
			{
				//Create a new Sprite at a random location on the screen
				BounceSprite bounceSprite = 
					new BounceSprite(marbleSurfaces,
					new Vector(rand.Next(screen.Rectangle.Left, screen.Rectangle.Right),
					rand.Next(screen.Rectangle.Top, screen.Rectangle.Bottom),
					0));
				//Add the sprite to the SpriteCollection
				master.Add(bounceSprite);
			}
			//The collection will respond to mouse button clicks, mouse movement and the ticker.
			master.EnableMouseButtonEvent();
			master.EnableMouseMotionEvent();
			master.EnableTickEvent();
      
			//These bind the events to the above methods.
			Events.KeyboardDown +=
				new KeyboardEventHandler(this.OnKeyboardDown);
			Events.Tick += new TickEventHandler(this.OnTick);

			//Start the event ticker
			Events.Run();
		}

		/// <summary>
		/// Entry point for App.
		/// </summary>
		static void Main() 
		{
			BounceSprites bounce = new BounceSprites();
			bounce.Go();
		}
		#endregion Methods
	}
}
</pre>
<p>
<h3>BounceSprites.cs</h3>
<p>
<pre>
using System;
using System.Drawing;
using System.Collections;

using SdlDotNet;
using SdlDotNet.Sprites;

namespace SdlDotNet.Examples 
{
	/// <summary>
	/// Demo of Bouncing Balls using Sprites. 
	/// The Bouncesprites will respond to Tick Events by spinning. 
	/// You can click on each sprite and move them around the 
	/// screen as well (MouseButton and MouseMotion events).
	/// </summary>
	class BounceSprites
	{
		#region Fields
		private Surface screen; //video screen
		private SpriteCollection master = new SpriteCollection(); //holds all sprites
		private int width = 640; //screen width
		private int height = 480; //screen height
		private int maxBalls = 10; //number of balls to display
		private Random rand = new Random(); //randomizer
		private Surface background = new Surface("../../Data/background.png");
		#endregion Fields

		#region EventHandler Methods
		//Handles keyboard events. The 'Escape' and 'Q'keys will cause the app to exit
		private void OnKeyboardDown(object sender, KeyboardEventArgs e) 
		{
			if (e.Key == Key.Escape || e.Key == Key.Q)
			{
				Events.QuitApplication();
			}
		}

		RectangleCollection rects = new RectangleCollection();

		//A ticker is running to update the sprites constantly.
		//This method will fill the screen with black to clear it of the sprites.
		//Then it will Blit all of the sprites to the screen.
		//Then it will refresh the screen and display it.
		private void OnTick(object sender, TickEventArgs args)
		{	
			rects = screen.Blit(master);
			screen.Update(rects);	
			screen.Erase(master, background);
		}
		#endregion EventHandler Methods

		#region Methods
		//Main program loop
		private void Go() 
		{
			//Set up screen
			screen = Video.SetVideoModeWindow(width, height, true);
			screen.Blit(background);
			screen.Update();
			Video.WindowCaption = "SdlDotNet - Bounce Sprites";

			//This loads the various images (provided by Moonfire) 
			// into a SurfaceCollection for animation
			SurfaceCollection marbleSurfaces = 
				new SurfaceCollection(new Surface("../../Data/marble1.png"), new Size(50, 50)); 

			for (int i = 0; i < this.maxBalls; i++)
			{
				//Create a new Sprite at a random location on the screen
				BounceSprite bounceSprite = 
					new BounceSprite(marbleSurfaces,
					new Vector(rand.Next(screen.Rectangle.Left, screen.Rectangle.Right),
					rand.Next(screen.Rectangle.Top, screen.Rectangle.Bottom),
					0));
				//Add the sprite to the SpriteCollection
				master.Add(bounceSprite);
			}
			//The collection will respond to mouse button clicks, mouse movement and the ticker.
			master.EnableMouseButtonEvent();
			master.EnableMouseMotionEvent();
			master.EnableTickEvent();
      
			//These bind the events to the above methods.
			Events.KeyboardDown +=
				new KeyboardEventHandler(this.OnKeyboardDown);
			Events.Tick += new TickEventHandler(this.OnTick);

			//Start the event ticker
			Events.Run();
		}

		/// <summary>
		/// Entry point for App.
		/// </summary>
		static void Main() 
		{
			BounceSprites bounce = new BounceSprites();
			bounce.Go();
		}
		#endregion Methods
	}
}
</pre>
<p>
The demo app will create a 800x600 screen that features 10 rotating gray sprites. They will respond to Tick events by spinning. If a user clicks on one with a mouse, the marble will stop moving and be dragged along with the mouse (MouseButton and MouseMotion events).
<p> 
Sprite surfaces were created by D.R.E. Moonfire (d.moonfire AT mfgames DOT com)
</html>
